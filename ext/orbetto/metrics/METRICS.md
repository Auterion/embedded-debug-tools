# Trace Metrics with Plotly in Dash

As already explained in the TRACE.md readme, perfetto is a very helpful tool in displaying trace data,
but is limit in data size and display variability.
Therefore, as a proof of concept, a couple of metrics are computed in python.
We are making use of the perfbuf file generated by orbetto, the sql trace processor from perfetto
and a Program counter bitmap generated by CRoaring in orbetto.

## Visualize Metrics:

To start the local dash server you need to provide a perfbuf file when analyzing itm data or a bitmap for instruction data.
Depending on which argument you provide different metrics can be displayed. Use -h to see all options.
When  using the -diff flag you need to provide a second perfbuf file to display the metrics based on the difference between
the two files. This is very helpful for comparing different versions or settings between two runs.

```sh
# cd orbetto/metrics
# two metric
python3 metrics.py -f /path/to/orbetto.perf -wq -dwq
# difference between two trace on one metric
python3 metrics.py -f /path/to/orbetto_1.perf -f2 /path/to/orbetto_1.perf -hp -diff
# code coverage for pc bitmap (beta not completely accurate)
python3 metrics.py -bm /path/to/bitmap.roar -elf /path/to/elf_file.elf -cc
```

After executing, copy the https address into your browser and use the plotly interface to display the desired plot.

Hint: Some metrics take a bit to be computed (mainly code coverage).

## Advanced Metrics and Goal

There are already some easy statistic techniques included that might detect outliers, however the bigger picture of this work
is to do regression testing and fuzzing with statistic derived from instruction trace. Such as:
- Sensor Reading Regularity [done]
- Comm Link Throughputs
- Scheduling Latency vs Timeouts [done]
- Thread Progress vs Semaphores
- Callstack Changes (Code coverage) [done]

All these metrics need to be combined into a big latent space that can be diffed (some kind of distance measure) between different versions
of PX4 to detect bugs in code before flying.

## GCOV

There has been a quick investigation to use a more advanced and also tested tool. The most common is gcov, which is a
test coverage program from GCC.
Two files are needed for gcov to show display code coverage:
- .gcno which is a advanced source file you get when compiling with the GCC -ftest-coverage option
- .gcda build when GCC -fprofile-arcs option is executed

It should be easy .gcno file as the flag is already a compile option in PX4.
Theoretically, it should be possible to reverse engineer the .gcda file from the PC values only,
(documentation can be found here: https://github.com/gcc-mirror/gcc/blob/master/gcc/gcov-io.h)
however it is unclear how long this takes and how robust this will be.