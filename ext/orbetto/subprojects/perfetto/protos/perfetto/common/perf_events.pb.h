// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/perf_events.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto;
namespace perfetto {
namespace protos {
class PerfEvents;
struct PerfEventsDefaultTypeInternal;
extern PerfEventsDefaultTypeInternal _PerfEvents_default_instance_;
class PerfEvents_RawEvent;
struct PerfEvents_RawEventDefaultTypeInternal;
extern PerfEvents_RawEventDefaultTypeInternal _PerfEvents_RawEvent_default_instance_;
class PerfEvents_Timebase;
struct PerfEvents_TimebaseDefaultTypeInternal;
extern PerfEvents_TimebaseDefaultTypeInternal _PerfEvents_Timebase_default_instance_;
class PerfEvents_Tracepoint;
struct PerfEvents_TracepointDefaultTypeInternal;
extern PerfEvents_TracepointDefaultTypeInternal _PerfEvents_Tracepoint_default_instance_;
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template <>
::perfetto::protos::PerfEvents* Arena::CreateMaybeMessage<::perfetto::protos::PerfEvents>(Arena*);
template <>
::perfetto::protos::PerfEvents_RawEvent* Arena::CreateMaybeMessage<::perfetto::protos::PerfEvents_RawEvent>(Arena*);
template <>
::perfetto::protos::PerfEvents_Timebase* Arena::CreateMaybeMessage<::perfetto::protos::PerfEvents_Timebase>(Arena*);
template <>
::perfetto::protos::PerfEvents_Tracepoint* Arena::CreateMaybeMessage<::perfetto::protos::PerfEvents_Tracepoint>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace perfetto {
namespace protos {
enum PerfEvents_Counter : int {
  PerfEvents_Counter_UNKNOWN_COUNTER = 0,
  PerfEvents_Counter_SW_CPU_CLOCK = 1,
  PerfEvents_Counter_SW_PAGE_FAULTS = 2,
  PerfEvents_Counter_SW_TASK_CLOCK = 3,
  PerfEvents_Counter_SW_CONTEXT_SWITCHES = 4,
  PerfEvents_Counter_SW_CPU_MIGRATIONS = 5,
  PerfEvents_Counter_SW_PAGE_FAULTS_MIN = 6,
  PerfEvents_Counter_SW_PAGE_FAULTS_MAJ = 7,
  PerfEvents_Counter_SW_ALIGNMENT_FAULTS = 8,
  PerfEvents_Counter_SW_EMULATION_FAULTS = 9,
  PerfEvents_Counter_SW_DUMMY = 20,
  PerfEvents_Counter_HW_CPU_CYCLES = 10,
  PerfEvents_Counter_HW_INSTRUCTIONS = 11,
  PerfEvents_Counter_HW_CACHE_REFERENCES = 12,
  PerfEvents_Counter_HW_CACHE_MISSES = 13,
  PerfEvents_Counter_HW_BRANCH_INSTRUCTIONS = 14,
  PerfEvents_Counter_HW_BRANCH_MISSES = 15,
  PerfEvents_Counter_HW_BUS_CYCLES = 16,
  PerfEvents_Counter_HW_STALLED_CYCLES_FRONTEND = 17,
  PerfEvents_Counter_HW_STALLED_CYCLES_BACKEND = 18,
  PerfEvents_Counter_HW_REF_CPU_CYCLES = 19,
};

bool PerfEvents_Counter_IsValid(int value);
constexpr PerfEvents_Counter PerfEvents_Counter_Counter_MIN = static_cast<PerfEvents_Counter>(0);
constexpr PerfEvents_Counter PerfEvents_Counter_Counter_MAX = static_cast<PerfEvents_Counter>(20);
constexpr int PerfEvents_Counter_Counter_ARRAYSIZE = 20 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PerfEvents_Counter_descriptor();
template <typename T>
const std::string& PerfEvents_Counter_Name(T value) {
  static_assert(std::is_same<T, PerfEvents_Counter>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Counter_Name().");
  return PerfEvents_Counter_Name(static_cast<PerfEvents_Counter>(value));
}
template <>
inline const std::string& PerfEvents_Counter_Name(PerfEvents_Counter value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PerfEvents_Counter_descriptor,
                                                 0, 20>(
      static_cast<int>(value));
}
inline bool PerfEvents_Counter_Parse(absl::string_view name, PerfEvents_Counter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerfEvents_Counter>(
      PerfEvents_Counter_descriptor(), name, value);
}
enum PerfEvents_PerfClock : int {
  PerfEvents_PerfClock_UNKNOWN_PERF_CLOCK = 0,
  PerfEvents_PerfClock_PERF_CLOCK_REALTIME = 1,
  PerfEvents_PerfClock_PERF_CLOCK_MONOTONIC = 2,
  PerfEvents_PerfClock_PERF_CLOCK_MONOTONIC_RAW = 3,
  PerfEvents_PerfClock_PERF_CLOCK_BOOTTIME = 4,
};

bool PerfEvents_PerfClock_IsValid(int value);
constexpr PerfEvents_PerfClock PerfEvents_PerfClock_PerfClock_MIN = static_cast<PerfEvents_PerfClock>(0);
constexpr PerfEvents_PerfClock PerfEvents_PerfClock_PerfClock_MAX = static_cast<PerfEvents_PerfClock>(4);
constexpr int PerfEvents_PerfClock_PerfClock_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PerfEvents_PerfClock_descriptor();
template <typename T>
const std::string& PerfEvents_PerfClock_Name(T value) {
  static_assert(std::is_same<T, PerfEvents_PerfClock>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PerfClock_Name().");
  return PerfEvents_PerfClock_Name(static_cast<PerfEvents_PerfClock>(value));
}
template <>
inline const std::string& PerfEvents_PerfClock_Name(PerfEvents_PerfClock value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PerfEvents_PerfClock_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool PerfEvents_PerfClock_Parse(absl::string_view name, PerfEvents_PerfClock* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerfEvents_PerfClock>(
      PerfEvents_PerfClock_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PerfEvents_Timebase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.PerfEvents.Timebase) */ {
 public:
  inline PerfEvents_Timebase() : PerfEvents_Timebase(nullptr) {}
  ~PerfEvents_Timebase() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerfEvents_Timebase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerfEvents_Timebase(const PerfEvents_Timebase& from);
  PerfEvents_Timebase(PerfEvents_Timebase&& from) noexcept
    : PerfEvents_Timebase() {
    *this = ::std::move(from);
  }

  inline PerfEvents_Timebase& operator=(const PerfEvents_Timebase& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerfEvents_Timebase& operator=(PerfEvents_Timebase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerfEvents_Timebase& default_instance() {
    return *internal_default_instance();
  }
  enum IntervalCase {
    kFrequency = 2,
    kPeriod = 1,
    INTERVAL_NOT_SET = 0,
  };

  enum EventCase {
    kCounter = 4,
    kTracepoint = 3,
    kRawEvent = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const PerfEvents_Timebase* internal_default_instance() {
    return reinterpret_cast<const PerfEvents_Timebase*>(
               &_PerfEvents_Timebase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PerfEvents_Timebase& a, PerfEvents_Timebase& b) {
    a.Swap(&b);
  }
  inline void Swap(PerfEvents_Timebase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerfEvents_Timebase* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerfEvents_Timebase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerfEvents_Timebase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerfEvents_Timebase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerfEvents_Timebase& from) {
    PerfEvents_Timebase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerfEvents_Timebase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.PerfEvents.Timebase";
  }
  protected:
  explicit PerfEvents_Timebase(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 10,
    kTimestampClockFieldNumber = 11,
    kFrequencyFieldNumber = 2,
    kPeriodFieldNumber = 1,
    kCounterFieldNumber = 4,
    kTracepointFieldNumber = 3,
    kRawEventFieldNumber = 5,
  };
  // optional string name = 10;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .perfetto.protos.PerfEvents.PerfClock timestamp_clock = 11;
  bool has_timestamp_clock() const;
  void clear_timestamp_clock() ;
  ::perfetto::protos::PerfEvents_PerfClock timestamp_clock() const;
  void set_timestamp_clock(::perfetto::protos::PerfEvents_PerfClock value);

  private:
  ::perfetto::protos::PerfEvents_PerfClock _internal_timestamp_clock() const;
  void _internal_set_timestamp_clock(::perfetto::protos::PerfEvents_PerfClock value);

  public:
  // uint64 frequency = 2;
  bool has_frequency() const;
  void clear_frequency() ;
  ::uint64_t frequency() const;
  void set_frequency(::uint64_t value);

  private:
  ::uint64_t _internal_frequency() const;
  void _internal_set_frequency(::uint64_t value);

  public:
  // uint64 period = 1;
  bool has_period() const;
  void clear_period() ;
  ::uint64_t period() const;
  void set_period(::uint64_t value);

  private:
  ::uint64_t _internal_period() const;
  void _internal_set_period(::uint64_t value);

  public:
  // .perfetto.protos.PerfEvents.Counter counter = 4;
  bool has_counter() const;
  void clear_counter() ;
  ::perfetto::protos::PerfEvents_Counter counter() const;
  void set_counter(::perfetto::protos::PerfEvents_Counter value);

  private:
  ::perfetto::protos::PerfEvents_Counter _internal_counter() const;
  void _internal_set_counter(::perfetto::protos::PerfEvents_Counter value);

  public:
  // .perfetto.protos.PerfEvents.Tracepoint tracepoint = 3;
  bool has_tracepoint() const;
  private:
  bool _internal_has_tracepoint() const;

  public:
  void clear_tracepoint() ;
  const ::perfetto::protos::PerfEvents_Tracepoint& tracepoint() const;
  PROTOBUF_NODISCARD ::perfetto::protos::PerfEvents_Tracepoint* release_tracepoint();
  ::perfetto::protos::PerfEvents_Tracepoint* mutable_tracepoint();
  void set_allocated_tracepoint(::perfetto::protos::PerfEvents_Tracepoint* tracepoint);
  private:
  const ::perfetto::protos::PerfEvents_Tracepoint& _internal_tracepoint() const;
  ::perfetto::protos::PerfEvents_Tracepoint* _internal_mutable_tracepoint();
  public:
  void unsafe_arena_set_allocated_tracepoint(
      ::perfetto::protos::PerfEvents_Tracepoint* tracepoint);
  ::perfetto::protos::PerfEvents_Tracepoint* unsafe_arena_release_tracepoint();
  // .perfetto.protos.PerfEvents.RawEvent raw_event = 5;
  bool has_raw_event() const;
  private:
  bool _internal_has_raw_event() const;

  public:
  void clear_raw_event() ;
  const ::perfetto::protos::PerfEvents_RawEvent& raw_event() const;
  PROTOBUF_NODISCARD ::perfetto::protos::PerfEvents_RawEvent* release_raw_event();
  ::perfetto::protos::PerfEvents_RawEvent* mutable_raw_event();
  void set_allocated_raw_event(::perfetto::protos::PerfEvents_RawEvent* raw_event);
  private:
  const ::perfetto::protos::PerfEvents_RawEvent& _internal_raw_event() const;
  ::perfetto::protos::PerfEvents_RawEvent* _internal_mutable_raw_event();
  public:
  void unsafe_arena_set_allocated_raw_event(
      ::perfetto::protos::PerfEvents_RawEvent* raw_event);
  ::perfetto::protos::PerfEvents_RawEvent* unsafe_arena_release_raw_event();
  void clear_interval();
  IntervalCase interval_case() const;
  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.PerfEvents.Timebase)
 private:
  class _Internal;
  void set_has_frequency();
  void set_has_period();
  void set_has_counter();
  void set_has_tracepoint();
  void set_has_raw_event();

  inline bool has_interval() const;
  inline void clear_has_interval();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int timestamp_clock_;
    union IntervalUnion {
      constexpr IntervalUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::uint64_t frequency_;
      ::uint64_t period_;
    } interval_;
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int counter_;
      ::perfetto::protos::PerfEvents_Tracepoint* tracepoint_;
      ::perfetto::protos::PerfEvents_RawEvent* raw_event_;
    } event_;
    ::uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto;
};// -------------------------------------------------------------------

class PerfEvents_Tracepoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.PerfEvents.Tracepoint) */ {
 public:
  inline PerfEvents_Tracepoint() : PerfEvents_Tracepoint(nullptr) {}
  ~PerfEvents_Tracepoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerfEvents_Tracepoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerfEvents_Tracepoint(const PerfEvents_Tracepoint& from);
  PerfEvents_Tracepoint(PerfEvents_Tracepoint&& from) noexcept
    : PerfEvents_Tracepoint() {
    *this = ::std::move(from);
  }

  inline PerfEvents_Tracepoint& operator=(const PerfEvents_Tracepoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerfEvents_Tracepoint& operator=(PerfEvents_Tracepoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerfEvents_Tracepoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerfEvents_Tracepoint* internal_default_instance() {
    return reinterpret_cast<const PerfEvents_Tracepoint*>(
               &_PerfEvents_Tracepoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PerfEvents_Tracepoint& a, PerfEvents_Tracepoint& b) {
    a.Swap(&b);
  }
  inline void Swap(PerfEvents_Tracepoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerfEvents_Tracepoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerfEvents_Tracepoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerfEvents_Tracepoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerfEvents_Tracepoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerfEvents_Tracepoint& from) {
    PerfEvents_Tracepoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerfEvents_Tracepoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.PerfEvents.Tracepoint";
  }
  protected:
  explicit PerfEvents_Tracepoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFilterFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string filter = 2;
  bool has_filter() const;
  void clear_filter() ;
  const std::string& filter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filter(Arg_&& arg, Args_... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* ptr);

  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(
      const std::string& value);
  std::string* _internal_mutable_filter();

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.PerfEvents.Tracepoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto;
};// -------------------------------------------------------------------

class PerfEvents_RawEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.PerfEvents.RawEvent) */ {
 public:
  inline PerfEvents_RawEvent() : PerfEvents_RawEvent(nullptr) {}
  ~PerfEvents_RawEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerfEvents_RawEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerfEvents_RawEvent(const PerfEvents_RawEvent& from);
  PerfEvents_RawEvent(PerfEvents_RawEvent&& from) noexcept
    : PerfEvents_RawEvent() {
    *this = ::std::move(from);
  }

  inline PerfEvents_RawEvent& operator=(const PerfEvents_RawEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerfEvents_RawEvent& operator=(PerfEvents_RawEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerfEvents_RawEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerfEvents_RawEvent* internal_default_instance() {
    return reinterpret_cast<const PerfEvents_RawEvent*>(
               &_PerfEvents_RawEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PerfEvents_RawEvent& a, PerfEvents_RawEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PerfEvents_RawEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerfEvents_RawEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerfEvents_RawEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerfEvents_RawEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerfEvents_RawEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerfEvents_RawEvent& from) {
    PerfEvents_RawEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerfEvents_RawEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.PerfEvents.RawEvent";
  }
  protected:
  explicit PerfEvents_RawEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 2,
    kConfig1FieldNumber = 3,
    kConfig2FieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // optional uint64 config = 2;
  bool has_config() const;
  void clear_config() ;
  ::uint64_t config() const;
  void set_config(::uint64_t value);

  private:
  ::uint64_t _internal_config() const;
  void _internal_set_config(::uint64_t value);

  public:
  // optional uint64 config1 = 3;
  bool has_config1() const;
  void clear_config1() ;
  ::uint64_t config1() const;
  void set_config1(::uint64_t value);

  private:
  ::uint64_t _internal_config1() const;
  void _internal_set_config1(::uint64_t value);

  public:
  // optional uint64 config2 = 4;
  bool has_config2() const;
  void clear_config2() ;
  ::uint64_t config2() const;
  void set_config2(::uint64_t value);

  private:
  ::uint64_t _internal_config2() const;
  void _internal_set_config2(::uint64_t value);

  public:
  // optional uint32 type = 1;
  bool has_type() const;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.PerfEvents.RawEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t config_;
    ::uint64_t config1_;
    ::uint64_t config2_;
    ::uint32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto;
};// -------------------------------------------------------------------

class PerfEvents final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:perfetto.protos.PerfEvents) */ {
 public:
  inline PerfEvents() : PerfEvents(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerfEvents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerfEvents(const PerfEvents& from);
  PerfEvents(PerfEvents&& from) noexcept
    : PerfEvents() {
    *this = ::std::move(from);
  }

  inline PerfEvents& operator=(const PerfEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerfEvents& operator=(PerfEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerfEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerfEvents* internal_default_instance() {
    return reinterpret_cast<const PerfEvents*>(
               &_PerfEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PerfEvents& a, PerfEvents& b) {
    a.Swap(&b);
  }
  inline void Swap(PerfEvents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerfEvents* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerfEvents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerfEvents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PerfEvents& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PerfEvents& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.PerfEvents";
  }
  protected:
  explicit PerfEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PerfEvents_Timebase Timebase;
  typedef PerfEvents_Tracepoint Tracepoint;
  typedef PerfEvents_RawEvent RawEvent;

  using Counter = PerfEvents_Counter;
  static constexpr Counter UNKNOWN_COUNTER = PerfEvents_Counter_UNKNOWN_COUNTER;
  static constexpr Counter SW_CPU_CLOCK = PerfEvents_Counter_SW_CPU_CLOCK;
  static constexpr Counter SW_PAGE_FAULTS = PerfEvents_Counter_SW_PAGE_FAULTS;
  static constexpr Counter SW_TASK_CLOCK = PerfEvents_Counter_SW_TASK_CLOCK;
  static constexpr Counter SW_CONTEXT_SWITCHES = PerfEvents_Counter_SW_CONTEXT_SWITCHES;
  static constexpr Counter SW_CPU_MIGRATIONS = PerfEvents_Counter_SW_CPU_MIGRATIONS;
  static constexpr Counter SW_PAGE_FAULTS_MIN = PerfEvents_Counter_SW_PAGE_FAULTS_MIN;
  static constexpr Counter SW_PAGE_FAULTS_MAJ = PerfEvents_Counter_SW_PAGE_FAULTS_MAJ;
  static constexpr Counter SW_ALIGNMENT_FAULTS = PerfEvents_Counter_SW_ALIGNMENT_FAULTS;
  static constexpr Counter SW_EMULATION_FAULTS = PerfEvents_Counter_SW_EMULATION_FAULTS;
  static constexpr Counter SW_DUMMY = PerfEvents_Counter_SW_DUMMY;
  static constexpr Counter HW_CPU_CYCLES = PerfEvents_Counter_HW_CPU_CYCLES;
  static constexpr Counter HW_INSTRUCTIONS = PerfEvents_Counter_HW_INSTRUCTIONS;
  static constexpr Counter HW_CACHE_REFERENCES = PerfEvents_Counter_HW_CACHE_REFERENCES;
  static constexpr Counter HW_CACHE_MISSES = PerfEvents_Counter_HW_CACHE_MISSES;
  static constexpr Counter HW_BRANCH_INSTRUCTIONS = PerfEvents_Counter_HW_BRANCH_INSTRUCTIONS;
  static constexpr Counter HW_BRANCH_MISSES = PerfEvents_Counter_HW_BRANCH_MISSES;
  static constexpr Counter HW_BUS_CYCLES = PerfEvents_Counter_HW_BUS_CYCLES;
  static constexpr Counter HW_STALLED_CYCLES_FRONTEND = PerfEvents_Counter_HW_STALLED_CYCLES_FRONTEND;
  static constexpr Counter HW_STALLED_CYCLES_BACKEND = PerfEvents_Counter_HW_STALLED_CYCLES_BACKEND;
  static constexpr Counter HW_REF_CPU_CYCLES = PerfEvents_Counter_HW_REF_CPU_CYCLES;
  static inline bool Counter_IsValid(int value) {
    return PerfEvents_Counter_IsValid(value);
  }
  static constexpr Counter Counter_MIN = PerfEvents_Counter_Counter_MIN;
  static constexpr Counter Counter_MAX = PerfEvents_Counter_Counter_MAX;
  static constexpr int Counter_ARRAYSIZE = PerfEvents_Counter_Counter_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Counter_descriptor() {
    return PerfEvents_Counter_descriptor();
  }
  template <typename T>
  static inline const std::string& Counter_Name(T value) {
    return PerfEvents_Counter_Name(value);
  }
  static inline bool Counter_Parse(absl::string_view name, Counter* value) {
    return PerfEvents_Counter_Parse(name, value);
  }

  using PerfClock = PerfEvents_PerfClock;
  static constexpr PerfClock UNKNOWN_PERF_CLOCK = PerfEvents_PerfClock_UNKNOWN_PERF_CLOCK;
  static constexpr PerfClock PERF_CLOCK_REALTIME = PerfEvents_PerfClock_PERF_CLOCK_REALTIME;
  static constexpr PerfClock PERF_CLOCK_MONOTONIC = PerfEvents_PerfClock_PERF_CLOCK_MONOTONIC;
  static constexpr PerfClock PERF_CLOCK_MONOTONIC_RAW = PerfEvents_PerfClock_PERF_CLOCK_MONOTONIC_RAW;
  static constexpr PerfClock PERF_CLOCK_BOOTTIME = PerfEvents_PerfClock_PERF_CLOCK_BOOTTIME;
  static inline bool PerfClock_IsValid(int value) {
    return PerfEvents_PerfClock_IsValid(value);
  }
  static constexpr PerfClock PerfClock_MIN = PerfEvents_PerfClock_PerfClock_MIN;
  static constexpr PerfClock PerfClock_MAX = PerfEvents_PerfClock_PerfClock_MAX;
  static constexpr int PerfClock_ARRAYSIZE = PerfEvents_PerfClock_PerfClock_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerfClock_descriptor() {
    return PerfEvents_PerfClock_descriptor();
  }
  template <typename T>
  static inline const std::string& PerfClock_Name(T value) {
    return PerfEvents_PerfClock_Name(value);
  }
  static inline bool PerfClock_Parse(absl::string_view name, PerfClock* value) {
    return PerfEvents_PerfClock_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.PerfEvents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PerfEvents_Timebase

// uint64 frequency = 2;
inline bool PerfEvents_Timebase::has_frequency() const {
  return interval_case() == kFrequency;
}
inline void PerfEvents_Timebase::set_has_frequency() {
  _impl_._oneof_case_[0] = kFrequency;
}
inline void PerfEvents_Timebase::clear_frequency() {
  if (interval_case() == kFrequency) {
    _impl_.interval_.frequency_ = ::uint64_t{0u};
    clear_has_interval();
  }
}
inline ::uint64_t PerfEvents_Timebase::frequency() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.Timebase.frequency)
  return _internal_frequency();
}
inline void PerfEvents_Timebase::set_frequency(::uint64_t value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.Timebase.frequency)
}
inline ::uint64_t PerfEvents_Timebase::_internal_frequency() const {
  if (interval_case() == kFrequency) {
    return _impl_.interval_.frequency_;
  }
  return ::uint64_t{0u};
}
inline void PerfEvents_Timebase::_internal_set_frequency(::uint64_t value) {
  if (interval_case() != kFrequency) {
    clear_interval();
    set_has_frequency();
  }
  _impl_.interval_.frequency_ = value;
}

// uint64 period = 1;
inline bool PerfEvents_Timebase::has_period() const {
  return interval_case() == kPeriod;
}
inline void PerfEvents_Timebase::set_has_period() {
  _impl_._oneof_case_[0] = kPeriod;
}
inline void PerfEvents_Timebase::clear_period() {
  if (interval_case() == kPeriod) {
    _impl_.interval_.period_ = ::uint64_t{0u};
    clear_has_interval();
  }
}
inline ::uint64_t PerfEvents_Timebase::period() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.Timebase.period)
  return _internal_period();
}
inline void PerfEvents_Timebase::set_period(::uint64_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.Timebase.period)
}
inline ::uint64_t PerfEvents_Timebase::_internal_period() const {
  if (interval_case() == kPeriod) {
    return _impl_.interval_.period_;
  }
  return ::uint64_t{0u};
}
inline void PerfEvents_Timebase::_internal_set_period(::uint64_t value) {
  if (interval_case() != kPeriod) {
    clear_interval();
    set_has_period();
  }
  _impl_.interval_.period_ = value;
}

// .perfetto.protos.PerfEvents.Counter counter = 4;
inline bool PerfEvents_Timebase::has_counter() const {
  return event_case() == kCounter;
}
inline void PerfEvents_Timebase::set_has_counter() {
  _impl_._oneof_case_[1] = kCounter;
}
inline void PerfEvents_Timebase::clear_counter() {
  if (event_case() == kCounter) {
    _impl_.event_.counter_ = 0;
    clear_has_event();
  }
}
inline ::perfetto::protos::PerfEvents_Counter PerfEvents_Timebase::counter() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.Timebase.counter)
  return _internal_counter();
}
inline void PerfEvents_Timebase::set_counter(::perfetto::protos::PerfEvents_Counter value) {
   _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.Timebase.counter)
}
inline ::perfetto::protos::PerfEvents_Counter PerfEvents_Timebase::_internal_counter() const {
  if (event_case() == kCounter) {
    return static_cast<::perfetto::protos::PerfEvents_Counter>(_impl_.event_.counter_);
  }
  return static_cast<::perfetto::protos::PerfEvents_Counter>(0);
}
inline void PerfEvents_Timebase::_internal_set_counter(::perfetto::protos::PerfEvents_Counter value) {
  assert(::perfetto::protos::PerfEvents_Counter_IsValid(value));
  if (event_case() != kCounter) {
    clear_event();
    set_has_counter();
  }
  _impl_.event_.counter_ = value;
}

// .perfetto.protos.PerfEvents.Tracepoint tracepoint = 3;
inline bool PerfEvents_Timebase::has_tracepoint() const {
  return event_case() == kTracepoint;
}
inline bool PerfEvents_Timebase::_internal_has_tracepoint() const {
  return event_case() == kTracepoint;
}
inline void PerfEvents_Timebase::set_has_tracepoint() {
  _impl_._oneof_case_[1] = kTracepoint;
}
inline void PerfEvents_Timebase::clear_tracepoint() {
  if (event_case() == kTracepoint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.tracepoint_;
    }
    clear_has_event();
  }
}
inline ::perfetto::protos::PerfEvents_Tracepoint* PerfEvents_Timebase::release_tracepoint() {
  // @@protoc_insertion_point(field_release:perfetto.protos.PerfEvents.Timebase.tracepoint)
  if (event_case() == kTracepoint) {
    clear_has_event();
    ::perfetto::protos::PerfEvents_Tracepoint* temp = _impl_.event_.tracepoint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.tracepoint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perfetto::protos::PerfEvents_Tracepoint& PerfEvents_Timebase::_internal_tracepoint() const {
  return event_case() == kTracepoint
      ? *_impl_.event_.tracepoint_
      : reinterpret_cast<::perfetto::protos::PerfEvents_Tracepoint&>(::perfetto::protos::_PerfEvents_Tracepoint_default_instance_);
}
inline const ::perfetto::protos::PerfEvents_Tracepoint& PerfEvents_Timebase::tracepoint() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.Timebase.tracepoint)
  return _internal_tracepoint();
}
inline ::perfetto::protos::PerfEvents_Tracepoint* PerfEvents_Timebase::unsafe_arena_release_tracepoint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:perfetto.protos.PerfEvents.Timebase.tracepoint)
  if (event_case() == kTracepoint) {
    clear_has_event();
    ::perfetto::protos::PerfEvents_Tracepoint* temp = _impl_.event_.tracepoint_;
    _impl_.event_.tracepoint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PerfEvents_Timebase::unsafe_arena_set_allocated_tracepoint(::perfetto::protos::PerfEvents_Tracepoint* tracepoint) {
  clear_event();
  if (tracepoint) {
    set_has_tracepoint();
    _impl_.event_.tracepoint_ = tracepoint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perfetto.protos.PerfEvents.Timebase.tracepoint)
}
inline ::perfetto::protos::PerfEvents_Tracepoint* PerfEvents_Timebase::_internal_mutable_tracepoint() {
  if (event_case() != kTracepoint) {
    clear_event();
    set_has_tracepoint();
    _impl_.event_.tracepoint_ = CreateMaybeMessage< ::perfetto::protos::PerfEvents_Tracepoint >(GetArenaForAllocation());
  }
  return _impl_.event_.tracepoint_;
}
inline ::perfetto::protos::PerfEvents_Tracepoint* PerfEvents_Timebase::mutable_tracepoint() {
  ::perfetto::protos::PerfEvents_Tracepoint* _msg = _internal_mutable_tracepoint();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.PerfEvents.Timebase.tracepoint)
  return _msg;
}

// .perfetto.protos.PerfEvents.RawEvent raw_event = 5;
inline bool PerfEvents_Timebase::has_raw_event() const {
  return event_case() == kRawEvent;
}
inline bool PerfEvents_Timebase::_internal_has_raw_event() const {
  return event_case() == kRawEvent;
}
inline void PerfEvents_Timebase::set_has_raw_event() {
  _impl_._oneof_case_[1] = kRawEvent;
}
inline void PerfEvents_Timebase::clear_raw_event() {
  if (event_case() == kRawEvent) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.raw_event_;
    }
    clear_has_event();
  }
}
inline ::perfetto::protos::PerfEvents_RawEvent* PerfEvents_Timebase::release_raw_event() {
  // @@protoc_insertion_point(field_release:perfetto.protos.PerfEvents.Timebase.raw_event)
  if (event_case() == kRawEvent) {
    clear_has_event();
    ::perfetto::protos::PerfEvents_RawEvent* temp = _impl_.event_.raw_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.raw_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perfetto::protos::PerfEvents_RawEvent& PerfEvents_Timebase::_internal_raw_event() const {
  return event_case() == kRawEvent
      ? *_impl_.event_.raw_event_
      : reinterpret_cast<::perfetto::protos::PerfEvents_RawEvent&>(::perfetto::protos::_PerfEvents_RawEvent_default_instance_);
}
inline const ::perfetto::protos::PerfEvents_RawEvent& PerfEvents_Timebase::raw_event() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.Timebase.raw_event)
  return _internal_raw_event();
}
inline ::perfetto::protos::PerfEvents_RawEvent* PerfEvents_Timebase::unsafe_arena_release_raw_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:perfetto.protos.PerfEvents.Timebase.raw_event)
  if (event_case() == kRawEvent) {
    clear_has_event();
    ::perfetto::protos::PerfEvents_RawEvent* temp = _impl_.event_.raw_event_;
    _impl_.event_.raw_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PerfEvents_Timebase::unsafe_arena_set_allocated_raw_event(::perfetto::protos::PerfEvents_RawEvent* raw_event) {
  clear_event();
  if (raw_event) {
    set_has_raw_event();
    _impl_.event_.raw_event_ = raw_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perfetto.protos.PerfEvents.Timebase.raw_event)
}
inline ::perfetto::protos::PerfEvents_RawEvent* PerfEvents_Timebase::_internal_mutable_raw_event() {
  if (event_case() != kRawEvent) {
    clear_event();
    set_has_raw_event();
    _impl_.event_.raw_event_ = CreateMaybeMessage< ::perfetto::protos::PerfEvents_RawEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.raw_event_;
}
inline ::perfetto::protos::PerfEvents_RawEvent* PerfEvents_Timebase::mutable_raw_event() {
  ::perfetto::protos::PerfEvents_RawEvent* _msg = _internal_mutable_raw_event();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.PerfEvents.Timebase.raw_event)
  return _msg;
}

// optional .perfetto.protos.PerfEvents.PerfClock timestamp_clock = 11;
inline bool PerfEvents_Timebase::has_timestamp_clock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PerfEvents_Timebase::clear_timestamp_clock() {
  _impl_.timestamp_clock_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::perfetto::protos::PerfEvents_PerfClock PerfEvents_Timebase::timestamp_clock() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.Timebase.timestamp_clock)
  return _internal_timestamp_clock();
}
inline void PerfEvents_Timebase::set_timestamp_clock(::perfetto::protos::PerfEvents_PerfClock value) {
   _internal_set_timestamp_clock(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.Timebase.timestamp_clock)
}
inline ::perfetto::protos::PerfEvents_PerfClock PerfEvents_Timebase::_internal_timestamp_clock() const {
  return static_cast<::perfetto::protos::PerfEvents_PerfClock>(_impl_.timestamp_clock_);
}
inline void PerfEvents_Timebase::_internal_set_timestamp_clock(::perfetto::protos::PerfEvents_PerfClock value) {
  assert(::perfetto::protos::PerfEvents_PerfClock_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_clock_ = value;
}

// optional string name = 10;
inline bool PerfEvents_Timebase::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PerfEvents_Timebase::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PerfEvents_Timebase::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.Timebase.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerfEvents_Timebase::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.Timebase.name)
}
inline std::string* PerfEvents_Timebase::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.PerfEvents.Timebase.name)
  return _s;
}
inline const std::string& PerfEvents_Timebase::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PerfEvents_Timebase::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PerfEvents_Timebase::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* PerfEvents_Timebase::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.PerfEvents.Timebase.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PerfEvents_Timebase::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.PerfEvents.Timebase.name)
}

inline bool PerfEvents_Timebase::has_interval() const {
  return interval_case() != INTERVAL_NOT_SET;
}
inline void PerfEvents_Timebase::clear_has_interval() {
  _impl_._oneof_case_[0] = INTERVAL_NOT_SET;
}
inline bool PerfEvents_Timebase::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void PerfEvents_Timebase::clear_has_event() {
  _impl_._oneof_case_[1] = EVENT_NOT_SET;
}
inline PerfEvents_Timebase::IntervalCase PerfEvents_Timebase::interval_case() const {
  return PerfEvents_Timebase::IntervalCase(_impl_._oneof_case_[0]);
}
inline PerfEvents_Timebase::EventCase PerfEvents_Timebase::event_case() const {
  return PerfEvents_Timebase::EventCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// PerfEvents_Tracepoint

// optional string name = 1;
inline bool PerfEvents_Tracepoint::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PerfEvents_Tracepoint::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PerfEvents_Tracepoint::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.Tracepoint.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerfEvents_Tracepoint::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.Tracepoint.name)
}
inline std::string* PerfEvents_Tracepoint::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.PerfEvents.Tracepoint.name)
  return _s;
}
inline const std::string& PerfEvents_Tracepoint::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PerfEvents_Tracepoint::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PerfEvents_Tracepoint::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* PerfEvents_Tracepoint::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.PerfEvents.Tracepoint.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PerfEvents_Tracepoint::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.PerfEvents.Tracepoint.name)
}

// optional string filter = 2;
inline bool PerfEvents_Tracepoint::has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PerfEvents_Tracepoint::clear_filter() {
  _impl_.filter_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PerfEvents_Tracepoint::filter() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.Tracepoint.filter)
  return _internal_filter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerfEvents_Tracepoint::set_filter(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.Tracepoint.filter)
}
inline std::string* PerfEvents_Tracepoint::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.PerfEvents.Tracepoint.filter)
  return _s;
}
inline const std::string& PerfEvents_Tracepoint::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void PerfEvents_Tracepoint::_internal_set_filter(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* PerfEvents_Tracepoint::_internal_mutable_filter() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.filter_.Mutable( GetArenaForAllocation());
}
inline std::string* PerfEvents_Tracepoint::release_filter() {
  // @@protoc_insertion_point(field_release:perfetto.protos.PerfEvents.Tracepoint.filter)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.filter_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filter_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PerfEvents_Tracepoint::set_allocated_filter(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filter_.IsDefault()) {
          _impl_.filter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.PerfEvents.Tracepoint.filter)
}

// -------------------------------------------------------------------

// PerfEvents_RawEvent

// optional uint32 type = 1;
inline bool PerfEvents_RawEvent::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PerfEvents_RawEvent::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t PerfEvents_RawEvent::type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.RawEvent.type)
  return _internal_type();
}
inline void PerfEvents_RawEvent::set_type(::uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.RawEvent.type)
}
inline ::uint32_t PerfEvents_RawEvent::_internal_type() const {
  return _impl_.type_;
}
inline void PerfEvents_RawEvent::_internal_set_type(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// optional uint64 config = 2;
inline bool PerfEvents_RawEvent::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PerfEvents_RawEvent::clear_config() {
  _impl_.config_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t PerfEvents_RawEvent::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.RawEvent.config)
  return _internal_config();
}
inline void PerfEvents_RawEvent::set_config(::uint64_t value) {
  _internal_set_config(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.RawEvent.config)
}
inline ::uint64_t PerfEvents_RawEvent::_internal_config() const {
  return _impl_.config_;
}
inline void PerfEvents_RawEvent::_internal_set_config(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.config_ = value;
}

// optional uint64 config1 = 3;
inline bool PerfEvents_RawEvent::has_config1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PerfEvents_RawEvent::clear_config1() {
  _impl_.config1_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t PerfEvents_RawEvent::config1() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.RawEvent.config1)
  return _internal_config1();
}
inline void PerfEvents_RawEvent::set_config1(::uint64_t value) {
  _internal_set_config1(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.RawEvent.config1)
}
inline ::uint64_t PerfEvents_RawEvent::_internal_config1() const {
  return _impl_.config1_;
}
inline void PerfEvents_RawEvent::_internal_set_config1(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.config1_ = value;
}

// optional uint64 config2 = 4;
inline bool PerfEvents_RawEvent::has_config2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PerfEvents_RawEvent::clear_config2() {
  _impl_.config2_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t PerfEvents_RawEvent::config2() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PerfEvents.RawEvent.config2)
  return _internal_config2();
}
inline void PerfEvents_RawEvent::set_config2(::uint64_t value) {
  _internal_set_config2(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.PerfEvents.RawEvent.config2)
}
inline ::uint64_t PerfEvents_RawEvent::_internal_config2() const {
  return _impl_.config2_;
}
inline void PerfEvents_RawEvent::_internal_set_config2(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.config2_ = value;
}

// -------------------------------------------------------------------

// PerfEvents

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::perfetto::protos::PerfEvents_Counter> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::perfetto::protos::PerfEvents_Counter>() {
  return ::perfetto::protos::PerfEvents_Counter_descriptor();
}
template <>
struct is_proto_enum<::perfetto::protos::PerfEvents_PerfClock> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::perfetto::protos::PerfEvents_PerfClock>() {
  return ::perfetto::protos::PerfEvents_PerfClock_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2fcommon_2fperf_5fevents_2eproto_2epb_2eh
