// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/block.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
namespace perfetto {
namespace protos {
class BlockBioBackmergeFtraceEvent;
struct BlockBioBackmergeFtraceEventDefaultTypeInternal;
extern BlockBioBackmergeFtraceEventDefaultTypeInternal _BlockBioBackmergeFtraceEvent_default_instance_;
class BlockBioBounceFtraceEvent;
struct BlockBioBounceFtraceEventDefaultTypeInternal;
extern BlockBioBounceFtraceEventDefaultTypeInternal _BlockBioBounceFtraceEvent_default_instance_;
class BlockBioCompleteFtraceEvent;
struct BlockBioCompleteFtraceEventDefaultTypeInternal;
extern BlockBioCompleteFtraceEventDefaultTypeInternal _BlockBioCompleteFtraceEvent_default_instance_;
class BlockBioFrontmergeFtraceEvent;
struct BlockBioFrontmergeFtraceEventDefaultTypeInternal;
extern BlockBioFrontmergeFtraceEventDefaultTypeInternal _BlockBioFrontmergeFtraceEvent_default_instance_;
class BlockBioQueueFtraceEvent;
struct BlockBioQueueFtraceEventDefaultTypeInternal;
extern BlockBioQueueFtraceEventDefaultTypeInternal _BlockBioQueueFtraceEvent_default_instance_;
class BlockBioRemapFtraceEvent;
struct BlockBioRemapFtraceEventDefaultTypeInternal;
extern BlockBioRemapFtraceEventDefaultTypeInternal _BlockBioRemapFtraceEvent_default_instance_;
class BlockDirtyBufferFtraceEvent;
struct BlockDirtyBufferFtraceEventDefaultTypeInternal;
extern BlockDirtyBufferFtraceEventDefaultTypeInternal _BlockDirtyBufferFtraceEvent_default_instance_;
class BlockGetrqFtraceEvent;
struct BlockGetrqFtraceEventDefaultTypeInternal;
extern BlockGetrqFtraceEventDefaultTypeInternal _BlockGetrqFtraceEvent_default_instance_;
class BlockPlugFtraceEvent;
struct BlockPlugFtraceEventDefaultTypeInternal;
extern BlockPlugFtraceEventDefaultTypeInternal _BlockPlugFtraceEvent_default_instance_;
class BlockRqAbortFtraceEvent;
struct BlockRqAbortFtraceEventDefaultTypeInternal;
extern BlockRqAbortFtraceEventDefaultTypeInternal _BlockRqAbortFtraceEvent_default_instance_;
class BlockRqCompleteFtraceEvent;
struct BlockRqCompleteFtraceEventDefaultTypeInternal;
extern BlockRqCompleteFtraceEventDefaultTypeInternal _BlockRqCompleteFtraceEvent_default_instance_;
class BlockRqInsertFtraceEvent;
struct BlockRqInsertFtraceEventDefaultTypeInternal;
extern BlockRqInsertFtraceEventDefaultTypeInternal _BlockRqInsertFtraceEvent_default_instance_;
class BlockRqIssueFtraceEvent;
struct BlockRqIssueFtraceEventDefaultTypeInternal;
extern BlockRqIssueFtraceEventDefaultTypeInternal _BlockRqIssueFtraceEvent_default_instance_;
class BlockRqRemapFtraceEvent;
struct BlockRqRemapFtraceEventDefaultTypeInternal;
extern BlockRqRemapFtraceEventDefaultTypeInternal _BlockRqRemapFtraceEvent_default_instance_;
class BlockRqRequeueFtraceEvent;
struct BlockRqRequeueFtraceEventDefaultTypeInternal;
extern BlockRqRequeueFtraceEventDefaultTypeInternal _BlockRqRequeueFtraceEvent_default_instance_;
class BlockSleeprqFtraceEvent;
struct BlockSleeprqFtraceEventDefaultTypeInternal;
extern BlockSleeprqFtraceEventDefaultTypeInternal _BlockSleeprqFtraceEvent_default_instance_;
class BlockSplitFtraceEvent;
struct BlockSplitFtraceEventDefaultTypeInternal;
extern BlockSplitFtraceEventDefaultTypeInternal _BlockSplitFtraceEvent_default_instance_;
class BlockTouchBufferFtraceEvent;
struct BlockTouchBufferFtraceEventDefaultTypeInternal;
extern BlockTouchBufferFtraceEventDefaultTypeInternal _BlockTouchBufferFtraceEvent_default_instance_;
class BlockUnplugFtraceEvent;
struct BlockUnplugFtraceEventDefaultTypeInternal;
extern BlockUnplugFtraceEventDefaultTypeInternal _BlockUnplugFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template <>
::perfetto::protos::BlockBioBackmergeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockBioBackmergeFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockBioBounceFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockBioBounceFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockBioCompleteFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockBioCompleteFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockBioFrontmergeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockBioFrontmergeFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockBioQueueFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockBioQueueFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockBioRemapFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockBioRemapFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockDirtyBufferFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockDirtyBufferFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockGetrqFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockGetrqFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockPlugFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockPlugFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockRqAbortFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockRqAbortFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockRqCompleteFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockRqCompleteFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockRqInsertFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockRqInsertFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockRqIssueFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockRqIssueFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockRqRemapFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockRqRemapFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockRqRequeueFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockRqRequeueFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockSleeprqFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockSleeprqFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockSplitFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockSplitFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockTouchBufferFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockTouchBufferFtraceEvent>(Arena*);
template <>
::perfetto::protos::BlockUnplugFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::BlockUnplugFtraceEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace perfetto {
namespace protos {

// ===================================================================


// -------------------------------------------------------------------

class BlockRqIssueFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockRqIssueFtraceEvent) */ {
 public:
  inline BlockRqIssueFtraceEvent() : BlockRqIssueFtraceEvent(nullptr) {}
  ~BlockRqIssueFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockRqIssueFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockRqIssueFtraceEvent(const BlockRqIssueFtraceEvent& from);
  BlockRqIssueFtraceEvent(BlockRqIssueFtraceEvent&& from) noexcept
    : BlockRqIssueFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockRqIssueFtraceEvent& operator=(const BlockRqIssueFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRqIssueFtraceEvent& operator=(BlockRqIssueFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRqIssueFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockRqIssueFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockRqIssueFtraceEvent*>(
               &_BlockRqIssueFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BlockRqIssueFtraceEvent& a, BlockRqIssueFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockRqIssueFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRqIssueFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRqIssueFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockRqIssueFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockRqIssueFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockRqIssueFtraceEvent& from) {
    BlockRqIssueFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockRqIssueFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockRqIssueFtraceEvent";
  }
  protected:
  explicit BlockRqIssueFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 5,
    kCommFieldNumber = 6,
    kCmdFieldNumber = 7,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kBytesFieldNumber = 4,
  };
  // optional string rwbs = 5;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string comm = 6;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional string cmd = 7;
  bool has_cmd() const;
  void clear_cmd() ;
  const std::string& cmd() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* ptr);

  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(
      const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // optional uint32 bytes = 4;
  bool has_bytes() const;
  void clear_bytes() ;
  ::uint32_t bytes() const;
  void set_bytes(::uint32_t value);

  private:
  ::uint32_t _internal_bytes() const;
  void _internal_set_bytes(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockRqIssueFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
    ::uint32_t bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockBioBackmergeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockBioBackmergeFtraceEvent) */ {
 public:
  inline BlockBioBackmergeFtraceEvent() : BlockBioBackmergeFtraceEvent(nullptr) {}
  ~BlockBioBackmergeFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBioBackmergeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBioBackmergeFtraceEvent(const BlockBioBackmergeFtraceEvent& from);
  BlockBioBackmergeFtraceEvent(BlockBioBackmergeFtraceEvent&& from) noexcept
    : BlockBioBackmergeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockBioBackmergeFtraceEvent& operator=(const BlockBioBackmergeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBioBackmergeFtraceEvent& operator=(BlockBioBackmergeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBioBackmergeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBioBackmergeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockBioBackmergeFtraceEvent*>(
               &_BlockBioBackmergeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BlockBioBackmergeFtraceEvent& a, BlockBioBackmergeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBioBackmergeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBioBackmergeFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBioBackmergeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBioBackmergeFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBioBackmergeFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBioBackmergeFtraceEvent& from) {
    BlockBioBackmergeFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBioBackmergeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockBioBackmergeFtraceEvent";
  }
  protected:
  explicit BlockBioBackmergeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
  };
  // optional string rwbs = 4;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string comm = 5;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockBioBackmergeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockBioBounceFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockBioBounceFtraceEvent) */ {
 public:
  inline BlockBioBounceFtraceEvent() : BlockBioBounceFtraceEvent(nullptr) {}
  ~BlockBioBounceFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBioBounceFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBioBounceFtraceEvent(const BlockBioBounceFtraceEvent& from);
  BlockBioBounceFtraceEvent(BlockBioBounceFtraceEvent&& from) noexcept
    : BlockBioBounceFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockBioBounceFtraceEvent& operator=(const BlockBioBounceFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBioBounceFtraceEvent& operator=(BlockBioBounceFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBioBounceFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBioBounceFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockBioBounceFtraceEvent*>(
               &_BlockBioBounceFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BlockBioBounceFtraceEvent& a, BlockBioBounceFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBioBounceFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBioBounceFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBioBounceFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBioBounceFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBioBounceFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBioBounceFtraceEvent& from) {
    BlockBioBounceFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBioBounceFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockBioBounceFtraceEvent";
  }
  protected:
  explicit BlockBioBounceFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
  };
  // optional string rwbs = 4;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string comm = 5;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockBioBounceFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockBioCompleteFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockBioCompleteFtraceEvent) */ {
 public:
  inline BlockBioCompleteFtraceEvent() : BlockBioCompleteFtraceEvent(nullptr) {}
  ~BlockBioCompleteFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBioCompleteFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBioCompleteFtraceEvent(const BlockBioCompleteFtraceEvent& from);
  BlockBioCompleteFtraceEvent(BlockBioCompleteFtraceEvent&& from) noexcept
    : BlockBioCompleteFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockBioCompleteFtraceEvent& operator=(const BlockBioCompleteFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBioCompleteFtraceEvent& operator=(BlockBioCompleteFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBioCompleteFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBioCompleteFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockBioCompleteFtraceEvent*>(
               &_BlockBioCompleteFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BlockBioCompleteFtraceEvent& a, BlockBioCompleteFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBioCompleteFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBioCompleteFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBioCompleteFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBioCompleteFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBioCompleteFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBioCompleteFtraceEvent& from) {
    BlockBioCompleteFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBioCompleteFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockBioCompleteFtraceEvent";
  }
  protected:
  explicit BlockBioCompleteFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 5,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string rwbs = 5;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // optional int32 error = 4;
  bool has_error() const;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockBioCompleteFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
    ::int32_t error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockBioFrontmergeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockBioFrontmergeFtraceEvent) */ {
 public:
  inline BlockBioFrontmergeFtraceEvent() : BlockBioFrontmergeFtraceEvent(nullptr) {}
  ~BlockBioFrontmergeFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBioFrontmergeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBioFrontmergeFtraceEvent(const BlockBioFrontmergeFtraceEvent& from);
  BlockBioFrontmergeFtraceEvent(BlockBioFrontmergeFtraceEvent&& from) noexcept
    : BlockBioFrontmergeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockBioFrontmergeFtraceEvent& operator=(const BlockBioFrontmergeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBioFrontmergeFtraceEvent& operator=(BlockBioFrontmergeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBioFrontmergeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBioFrontmergeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockBioFrontmergeFtraceEvent*>(
               &_BlockBioFrontmergeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BlockBioFrontmergeFtraceEvent& a, BlockBioFrontmergeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBioFrontmergeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBioFrontmergeFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBioFrontmergeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBioFrontmergeFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBioFrontmergeFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBioFrontmergeFtraceEvent& from) {
    BlockBioFrontmergeFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBioFrontmergeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockBioFrontmergeFtraceEvent";
  }
  protected:
  explicit BlockBioFrontmergeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
  };
  // optional string rwbs = 4;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string comm = 5;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockBioFrontmergeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockBioQueueFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockBioQueueFtraceEvent) */ {
 public:
  inline BlockBioQueueFtraceEvent() : BlockBioQueueFtraceEvent(nullptr) {}
  ~BlockBioQueueFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBioQueueFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBioQueueFtraceEvent(const BlockBioQueueFtraceEvent& from);
  BlockBioQueueFtraceEvent(BlockBioQueueFtraceEvent&& from) noexcept
    : BlockBioQueueFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockBioQueueFtraceEvent& operator=(const BlockBioQueueFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBioQueueFtraceEvent& operator=(BlockBioQueueFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBioQueueFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBioQueueFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockBioQueueFtraceEvent*>(
               &_BlockBioQueueFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BlockBioQueueFtraceEvent& a, BlockBioQueueFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBioQueueFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBioQueueFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBioQueueFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBioQueueFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBioQueueFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBioQueueFtraceEvent& from) {
    BlockBioQueueFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBioQueueFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockBioQueueFtraceEvent";
  }
  protected:
  explicit BlockBioQueueFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
  };
  // optional string rwbs = 4;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string comm = 5;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockBioQueueFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockBioRemapFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockBioRemapFtraceEvent) */ {
 public:
  inline BlockBioRemapFtraceEvent() : BlockBioRemapFtraceEvent(nullptr) {}
  ~BlockBioRemapFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBioRemapFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBioRemapFtraceEvent(const BlockBioRemapFtraceEvent& from);
  BlockBioRemapFtraceEvent(BlockBioRemapFtraceEvent&& from) noexcept
    : BlockBioRemapFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockBioRemapFtraceEvent& operator=(const BlockBioRemapFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBioRemapFtraceEvent& operator=(BlockBioRemapFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBioRemapFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBioRemapFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockBioRemapFtraceEvent*>(
               &_BlockBioRemapFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlockBioRemapFtraceEvent& a, BlockBioRemapFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBioRemapFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBioRemapFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBioRemapFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBioRemapFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBioRemapFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBioRemapFtraceEvent& from) {
    BlockBioRemapFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBioRemapFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockBioRemapFtraceEvent";
  }
  protected:
  explicit BlockBioRemapFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 6,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kOldDevFieldNumber = 4,
    kOldSectorFieldNumber = 5,
    kNrSectorFieldNumber = 3,
  };
  // optional string rwbs = 6;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint64 old_dev = 4;
  bool has_old_dev() const;
  void clear_old_dev() ;
  ::uint64_t old_dev() const;
  void set_old_dev(::uint64_t value);

  private:
  ::uint64_t _internal_old_dev() const;
  void _internal_set_old_dev(::uint64_t value);

  public:
  // optional uint64 old_sector = 5;
  bool has_old_sector() const;
  void clear_old_sector() ;
  ::uint64_t old_sector() const;
  void set_old_sector(::uint64_t value);

  private:
  ::uint64_t _internal_old_sector() const;
  void _internal_set_old_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockBioRemapFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint64_t old_dev_;
    ::uint64_t old_sector_;
    ::uint32_t nr_sector_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockDirtyBufferFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockDirtyBufferFtraceEvent) */ {
 public:
  inline BlockDirtyBufferFtraceEvent() : BlockDirtyBufferFtraceEvent(nullptr) {}
  ~BlockDirtyBufferFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockDirtyBufferFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockDirtyBufferFtraceEvent(const BlockDirtyBufferFtraceEvent& from);
  BlockDirtyBufferFtraceEvent(BlockDirtyBufferFtraceEvent&& from) noexcept
    : BlockDirtyBufferFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockDirtyBufferFtraceEvent& operator=(const BlockDirtyBufferFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockDirtyBufferFtraceEvent& operator=(BlockDirtyBufferFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockDirtyBufferFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockDirtyBufferFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockDirtyBufferFtraceEvent*>(
               &_BlockDirtyBufferFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BlockDirtyBufferFtraceEvent& a, BlockDirtyBufferFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockDirtyBufferFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockDirtyBufferFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockDirtyBufferFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockDirtyBufferFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockDirtyBufferFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockDirtyBufferFtraceEvent& from) {
    BlockDirtyBufferFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockDirtyBufferFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockDirtyBufferFtraceEvent";
  }
  protected:
  explicit BlockDirtyBufferFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint64 size = 3;
  bool has_size() const;
  void clear_size() ;
  ::uint64_t size() const;
  void set_size(::uint64_t value);

  private:
  ::uint64_t _internal_size() const;
  void _internal_set_size(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockDirtyBufferFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockGetrqFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockGetrqFtraceEvent) */ {
 public:
  inline BlockGetrqFtraceEvent() : BlockGetrqFtraceEvent(nullptr) {}
  ~BlockGetrqFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockGetrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockGetrqFtraceEvent(const BlockGetrqFtraceEvent& from);
  BlockGetrqFtraceEvent(BlockGetrqFtraceEvent&& from) noexcept
    : BlockGetrqFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockGetrqFtraceEvent& operator=(const BlockGetrqFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockGetrqFtraceEvent& operator=(BlockGetrqFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockGetrqFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockGetrqFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockGetrqFtraceEvent*>(
               &_BlockGetrqFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BlockGetrqFtraceEvent& a, BlockGetrqFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockGetrqFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockGetrqFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockGetrqFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockGetrqFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockGetrqFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockGetrqFtraceEvent& from) {
    BlockGetrqFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockGetrqFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockGetrqFtraceEvent";
  }
  protected:
  explicit BlockGetrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
  };
  // optional string rwbs = 4;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string comm = 5;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockGetrqFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockPlugFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockPlugFtraceEvent) */ {
 public:
  inline BlockPlugFtraceEvent() : BlockPlugFtraceEvent(nullptr) {}
  ~BlockPlugFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockPlugFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockPlugFtraceEvent(const BlockPlugFtraceEvent& from);
  BlockPlugFtraceEvent(BlockPlugFtraceEvent&& from) noexcept
    : BlockPlugFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockPlugFtraceEvent& operator=(const BlockPlugFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockPlugFtraceEvent& operator=(BlockPlugFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockPlugFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockPlugFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockPlugFtraceEvent*>(
               &_BlockPlugFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BlockPlugFtraceEvent& a, BlockPlugFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockPlugFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockPlugFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockPlugFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockPlugFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockPlugFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockPlugFtraceEvent& from) {
    BlockPlugFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockPlugFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockPlugFtraceEvent";
  }
  protected:
  explicit BlockPlugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockPlugFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockRqAbortFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockRqAbortFtraceEvent) */ {
 public:
  inline BlockRqAbortFtraceEvent() : BlockRqAbortFtraceEvent(nullptr) {}
  ~BlockRqAbortFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockRqAbortFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockRqAbortFtraceEvent(const BlockRqAbortFtraceEvent& from);
  BlockRqAbortFtraceEvent(BlockRqAbortFtraceEvent&& from) noexcept
    : BlockRqAbortFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockRqAbortFtraceEvent& operator=(const BlockRqAbortFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRqAbortFtraceEvent& operator=(BlockRqAbortFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRqAbortFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockRqAbortFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockRqAbortFtraceEvent*>(
               &_BlockRqAbortFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BlockRqAbortFtraceEvent& a, BlockRqAbortFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockRqAbortFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRqAbortFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRqAbortFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockRqAbortFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockRqAbortFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockRqAbortFtraceEvent& from) {
    BlockRqAbortFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockRqAbortFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockRqAbortFtraceEvent";
  }
  protected:
  explicit BlockRqAbortFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
  };
  // optional string rwbs = 5;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string cmd = 6;
  bool has_cmd() const;
  void clear_cmd() ;
  const std::string& cmd() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* ptr);

  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(
      const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // optional int32 errors = 4;
  bool has_errors() const;
  void clear_errors() ;
  ::int32_t errors() const;
  void set_errors(::int32_t value);

  private:
  ::int32_t _internal_errors() const;
  void _internal_set_errors(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockRqAbortFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
    ::int32_t errors_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockRqCompleteFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockRqCompleteFtraceEvent) */ {
 public:
  inline BlockRqCompleteFtraceEvent() : BlockRqCompleteFtraceEvent(nullptr) {}
  ~BlockRqCompleteFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockRqCompleteFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockRqCompleteFtraceEvent(const BlockRqCompleteFtraceEvent& from);
  BlockRqCompleteFtraceEvent(BlockRqCompleteFtraceEvent&& from) noexcept
    : BlockRqCompleteFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockRqCompleteFtraceEvent& operator=(const BlockRqCompleteFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRqCompleteFtraceEvent& operator=(BlockRqCompleteFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRqCompleteFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockRqCompleteFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockRqCompleteFtraceEvent*>(
               &_BlockRqCompleteFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BlockRqCompleteFtraceEvent& a, BlockRqCompleteFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockRqCompleteFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRqCompleteFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRqCompleteFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockRqCompleteFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockRqCompleteFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockRqCompleteFtraceEvent& from) {
    BlockRqCompleteFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockRqCompleteFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockRqCompleteFtraceEvent";
  }
  protected:
  explicit BlockRqCompleteFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kErrorFieldNumber = 7,
  };
  // optional string rwbs = 5;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string cmd = 6;
  bool has_cmd() const;
  void clear_cmd() ;
  const std::string& cmd() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* ptr);

  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(
      const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // optional int32 errors = 4;
  bool has_errors() const;
  void clear_errors() ;
  ::int32_t errors() const;
  void set_errors(::int32_t value);

  private:
  ::int32_t _internal_errors() const;
  void _internal_set_errors(::int32_t value);

  public:
  // optional int32 error = 7;
  bool has_error() const;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockRqCompleteFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
    ::int32_t errors_;
    ::int32_t error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockRqInsertFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockRqInsertFtraceEvent) */ {
 public:
  inline BlockRqInsertFtraceEvent() : BlockRqInsertFtraceEvent(nullptr) {}
  ~BlockRqInsertFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockRqInsertFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockRqInsertFtraceEvent(const BlockRqInsertFtraceEvent& from);
  BlockRqInsertFtraceEvent(BlockRqInsertFtraceEvent&& from) noexcept
    : BlockRqInsertFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockRqInsertFtraceEvent& operator=(const BlockRqInsertFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRqInsertFtraceEvent& operator=(BlockRqInsertFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRqInsertFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockRqInsertFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockRqInsertFtraceEvent*>(
               &_BlockRqInsertFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BlockRqInsertFtraceEvent& a, BlockRqInsertFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockRqInsertFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRqInsertFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRqInsertFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockRqInsertFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockRqInsertFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockRqInsertFtraceEvent& from) {
    BlockRqInsertFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockRqInsertFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockRqInsertFtraceEvent";
  }
  protected:
  explicit BlockRqInsertFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 5,
    kCommFieldNumber = 6,
    kCmdFieldNumber = 7,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kBytesFieldNumber = 4,
  };
  // optional string rwbs = 5;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string comm = 6;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional string cmd = 7;
  bool has_cmd() const;
  void clear_cmd() ;
  const std::string& cmd() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* ptr);

  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(
      const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // optional uint32 bytes = 4;
  bool has_bytes() const;
  void clear_bytes() ;
  ::uint32_t bytes() const;
  void set_bytes(::uint32_t value);

  private:
  ::uint32_t _internal_bytes() const;
  void _internal_set_bytes(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockRqInsertFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
    ::uint32_t bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockRqRemapFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockRqRemapFtraceEvent) */ {
 public:
  inline BlockRqRemapFtraceEvent() : BlockRqRemapFtraceEvent(nullptr) {}
  ~BlockRqRemapFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockRqRemapFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockRqRemapFtraceEvent(const BlockRqRemapFtraceEvent& from);
  BlockRqRemapFtraceEvent(BlockRqRemapFtraceEvent&& from) noexcept
    : BlockRqRemapFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockRqRemapFtraceEvent& operator=(const BlockRqRemapFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRqRemapFtraceEvent& operator=(BlockRqRemapFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRqRemapFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockRqRemapFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockRqRemapFtraceEvent*>(
               &_BlockRqRemapFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BlockRqRemapFtraceEvent& a, BlockRqRemapFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockRqRemapFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRqRemapFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRqRemapFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockRqRemapFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockRqRemapFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockRqRemapFtraceEvent& from) {
    BlockRqRemapFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockRqRemapFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockRqRemapFtraceEvent";
  }
  protected:
  explicit BlockRqRemapFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 7,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kOldDevFieldNumber = 4,
    kNrSectorFieldNumber = 3,
    kNrBiosFieldNumber = 6,
    kOldSectorFieldNumber = 5,
  };
  // optional string rwbs = 7;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint64 old_dev = 4;
  bool has_old_dev() const;
  void clear_old_dev() ;
  ::uint64_t old_dev() const;
  void set_old_dev(::uint64_t value);

  private:
  ::uint64_t _internal_old_dev() const;
  void _internal_set_old_dev(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // optional uint32 nr_bios = 6;
  bool has_nr_bios() const;
  void clear_nr_bios() ;
  ::uint32_t nr_bios() const;
  void set_nr_bios(::uint32_t value);

  private:
  ::uint32_t _internal_nr_bios() const;
  void _internal_set_nr_bios(::uint32_t value);

  public:
  // optional uint64 old_sector = 5;
  bool has_old_sector() const;
  void clear_old_sector() ;
  ::uint64_t old_sector() const;
  void set_old_sector(::uint64_t value);

  private:
  ::uint64_t _internal_old_sector() const;
  void _internal_set_old_sector(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockRqRemapFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint64_t old_dev_;
    ::uint32_t nr_sector_;
    ::uint32_t nr_bios_;
    ::uint64_t old_sector_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockRqRequeueFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockRqRequeueFtraceEvent) */ {
 public:
  inline BlockRqRequeueFtraceEvent() : BlockRqRequeueFtraceEvent(nullptr) {}
  ~BlockRqRequeueFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockRqRequeueFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockRqRequeueFtraceEvent(const BlockRqRequeueFtraceEvent& from);
  BlockRqRequeueFtraceEvent(BlockRqRequeueFtraceEvent&& from) noexcept
    : BlockRqRequeueFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockRqRequeueFtraceEvent& operator=(const BlockRqRequeueFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRqRequeueFtraceEvent& operator=(BlockRqRequeueFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRqRequeueFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockRqRequeueFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockRqRequeueFtraceEvent*>(
               &_BlockRqRequeueFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BlockRqRequeueFtraceEvent& a, BlockRqRequeueFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockRqRequeueFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRqRequeueFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRqRequeueFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockRqRequeueFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockRqRequeueFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockRqRequeueFtraceEvent& from) {
    BlockRqRequeueFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockRqRequeueFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockRqRequeueFtraceEvent";
  }
  protected:
  explicit BlockRqRequeueFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
  };
  // optional string rwbs = 5;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string cmd = 6;
  bool has_cmd() const;
  void clear_cmd() ;
  const std::string& cmd() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* ptr);

  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(
      const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // optional int32 errors = 4;
  bool has_errors() const;
  void clear_errors() ;
  ::int32_t errors() const;
  void set_errors(::int32_t value);

  private:
  ::int32_t _internal_errors() const;
  void _internal_set_errors(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockRqRequeueFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
    ::int32_t errors_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockSleeprqFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockSleeprqFtraceEvent) */ {
 public:
  inline BlockSleeprqFtraceEvent() : BlockSleeprqFtraceEvent(nullptr) {}
  ~BlockSleeprqFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockSleeprqFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockSleeprqFtraceEvent(const BlockSleeprqFtraceEvent& from);
  BlockSleeprqFtraceEvent(BlockSleeprqFtraceEvent&& from) noexcept
    : BlockSleeprqFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockSleeprqFtraceEvent& operator=(const BlockSleeprqFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockSleeprqFtraceEvent& operator=(BlockSleeprqFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockSleeprqFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockSleeprqFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockSleeprqFtraceEvent*>(
               &_BlockSleeprqFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BlockSleeprqFtraceEvent& a, BlockSleeprqFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockSleeprqFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockSleeprqFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockSleeprqFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockSleeprqFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockSleeprqFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockSleeprqFtraceEvent& from) {
    BlockSleeprqFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockSleeprqFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockSleeprqFtraceEvent";
  }
  protected:
  explicit BlockSleeprqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
  };
  // optional string rwbs = 4;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string comm = 5;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint32 nr_sector = 3;
  bool has_nr_sector() const;
  void clear_nr_sector() ;
  ::uint32_t nr_sector() const;
  void set_nr_sector(::uint32_t value);

  private:
  ::uint32_t _internal_nr_sector() const;
  void _internal_set_nr_sector(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockSleeprqFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint32_t nr_sector_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockSplitFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockSplitFtraceEvent) */ {
 public:
  inline BlockSplitFtraceEvent() : BlockSplitFtraceEvent(nullptr) {}
  ~BlockSplitFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockSplitFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockSplitFtraceEvent(const BlockSplitFtraceEvent& from);
  BlockSplitFtraceEvent(BlockSplitFtraceEvent&& from) noexcept
    : BlockSplitFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockSplitFtraceEvent& operator=(const BlockSplitFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockSplitFtraceEvent& operator=(BlockSplitFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockSplitFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockSplitFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockSplitFtraceEvent*>(
               &_BlockSplitFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BlockSplitFtraceEvent& a, BlockSplitFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockSplitFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockSplitFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockSplitFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockSplitFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockSplitFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockSplitFtraceEvent& from) {
    BlockSplitFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockSplitFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockSplitFtraceEvent";
  }
  protected:
  explicit BlockSplitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNewSectorFieldNumber = 3,
  };
  // optional string rwbs = 4;
  bool has_rwbs() const;
  void clear_rwbs() ;
  const std::string& rwbs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rwbs(Arg_&& arg, Args_... args);
  std::string* mutable_rwbs();
  PROTOBUF_NODISCARD std::string* release_rwbs();
  void set_allocated_rwbs(std::string* ptr);

  private:
  const std::string& _internal_rwbs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rwbs(
      const std::string& value);
  std::string* _internal_mutable_rwbs();

  public:
  // optional string comm = 5;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint64 new_sector = 3;
  bool has_new_sector() const;
  void clear_new_sector() ;
  ::uint64_t new_sector() const;
  void set_new_sector(::uint64_t value);

  private:
  ::uint64_t _internal_new_sector() const;
  void _internal_set_new_sector(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockSplitFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rwbs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint64_t new_sector_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockTouchBufferFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockTouchBufferFtraceEvent) */ {
 public:
  inline BlockTouchBufferFtraceEvent() : BlockTouchBufferFtraceEvent(nullptr) {}
  ~BlockTouchBufferFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockTouchBufferFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockTouchBufferFtraceEvent(const BlockTouchBufferFtraceEvent& from);
  BlockTouchBufferFtraceEvent(BlockTouchBufferFtraceEvent&& from) noexcept
    : BlockTouchBufferFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockTouchBufferFtraceEvent& operator=(const BlockTouchBufferFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockTouchBufferFtraceEvent& operator=(BlockTouchBufferFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockTouchBufferFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockTouchBufferFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockTouchBufferFtraceEvent*>(
               &_BlockTouchBufferFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BlockTouchBufferFtraceEvent& a, BlockTouchBufferFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockTouchBufferFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockTouchBufferFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockTouchBufferFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockTouchBufferFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockTouchBufferFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockTouchBufferFtraceEvent& from) {
    BlockTouchBufferFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockTouchBufferFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockTouchBufferFtraceEvent";
  }
  protected:
  explicit BlockTouchBufferFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // optional uint64 dev = 1;
  bool has_dev() const;
  void clear_dev() ;
  ::uint64_t dev() const;
  void set_dev(::uint64_t value);

  private:
  ::uint64_t _internal_dev() const;
  void _internal_set_dev(::uint64_t value);

  public:
  // optional uint64 sector = 2;
  bool has_sector() const;
  void clear_sector() ;
  ::uint64_t sector() const;
  void set_sector(::uint64_t value);

  private:
  ::uint64_t _internal_sector() const;
  void _internal_set_sector(::uint64_t value);

  public:
  // optional uint64 size = 3;
  bool has_size() const;
  void clear_size() ;
  ::uint64_t size() const;
  void set_size(::uint64_t value);

  private:
  ::uint64_t _internal_size() const;
  void _internal_set_size(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockTouchBufferFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t dev_;
    ::uint64_t sector_;
    ::uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};// -------------------------------------------------------------------

class BlockUnplugFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.BlockUnplugFtraceEvent) */ {
 public:
  inline BlockUnplugFtraceEvent() : BlockUnplugFtraceEvent(nullptr) {}
  ~BlockUnplugFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockUnplugFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockUnplugFtraceEvent(const BlockUnplugFtraceEvent& from);
  BlockUnplugFtraceEvent(BlockUnplugFtraceEvent&& from) noexcept
    : BlockUnplugFtraceEvent() {
    *this = ::std::move(from);
  }

  inline BlockUnplugFtraceEvent& operator=(const BlockUnplugFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockUnplugFtraceEvent& operator=(BlockUnplugFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockUnplugFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockUnplugFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const BlockUnplugFtraceEvent*>(
               &_BlockUnplugFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BlockUnplugFtraceEvent& a, BlockUnplugFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockUnplugFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockUnplugFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockUnplugFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockUnplugFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockUnplugFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockUnplugFtraceEvent& from) {
    BlockUnplugFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockUnplugFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.BlockUnplugFtraceEvent";
  }
  protected:
  explicit BlockUnplugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 2,
    kNrRqFieldNumber = 1,
  };
  // optional string comm = 2;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional int32 nr_rq = 1;
  bool has_nr_rq() const;
  void clear_nr_rq() ;
  ::int32_t nr_rq() const;
  void set_nr_rq(::int32_t value);

  private:
  ::int32_t _internal_nr_rq() const;
  void _internal_set_nr_rq(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.BlockUnplugFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::int32_t nr_rq_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// BlockRqIssueFtraceEvent

// optional uint64 dev = 1;
inline bool BlockRqIssueFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockRqIssueFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockRqIssueFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqIssueFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockRqIssueFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqIssueFtraceEvent.dev)
}
inline ::uint64_t BlockRqIssueFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockRqIssueFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockRqIssueFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockRqIssueFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t BlockRqIssueFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqIssueFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockRqIssueFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqIssueFtraceEvent.sector)
}
inline ::uint64_t BlockRqIssueFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockRqIssueFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockRqIssueFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BlockRqIssueFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t BlockRqIssueFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqIssueFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockRqIssueFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqIssueFtraceEvent.nr_sector)
}
inline ::uint32_t BlockRqIssueFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockRqIssueFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.nr_sector_ = value;
}

// optional uint32 bytes = 4;
inline bool BlockRqIssueFtraceEvent::has_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BlockRqIssueFtraceEvent::clear_bytes() {
  _impl_.bytes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t BlockRqIssueFtraceEvent::bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqIssueFtraceEvent.bytes)
  return _internal_bytes();
}
inline void BlockRqIssueFtraceEvent::set_bytes(::uint32_t value) {
  _internal_set_bytes(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqIssueFtraceEvent.bytes)
}
inline ::uint32_t BlockRqIssueFtraceEvent::_internal_bytes() const {
  return _impl_.bytes_;
}
inline void BlockRqIssueFtraceEvent::_internal_set_bytes(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.bytes_ = value;
}

// optional string rwbs = 5;
inline bool BlockRqIssueFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockRqIssueFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockRqIssueFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqIssueFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqIssueFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqIssueFtraceEvent.rwbs)
}
inline std::string* BlockRqIssueFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqIssueFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockRqIssueFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockRqIssueFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqIssueFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqIssueFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqIssueFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqIssueFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqIssueFtraceEvent.rwbs)
}

// optional string comm = 6;
inline bool BlockRqIssueFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockRqIssueFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockRqIssueFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqIssueFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqIssueFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqIssueFtraceEvent.comm)
}
inline std::string* BlockRqIssueFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqIssueFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockRqIssueFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockRqIssueFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqIssueFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqIssueFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqIssueFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqIssueFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqIssueFtraceEvent.comm)
}

// optional string cmd = 7;
inline bool BlockRqIssueFtraceEvent::has_cmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockRqIssueFtraceEvent::clear_cmd() {
  _impl_.cmd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BlockRqIssueFtraceEvent::cmd() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqIssueFtraceEvent.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqIssueFtraceEvent::set_cmd(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cmd_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqIssueFtraceEvent.cmd)
}
inline std::string* BlockRqIssueFtraceEvent::mutable_cmd() {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqIssueFtraceEvent.cmd)
  return _s;
}
inline const std::string& BlockRqIssueFtraceEvent::_internal_cmd() const {
  return _impl_.cmd_.Get();
}
inline void BlockRqIssueFtraceEvent::_internal_set_cmd(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.cmd_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqIssueFtraceEvent::_internal_mutable_cmd() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.cmd_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqIssueFtraceEvent::release_cmd() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqIssueFtraceEvent.cmd)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.cmd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqIssueFtraceEvent::set_allocated_cmd(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cmd_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_.IsDefault()) {
          _impl_.cmd_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqIssueFtraceEvent.cmd)
}

// -------------------------------------------------------------------

// BlockBioBackmergeFtraceEvent

// optional uint64 dev = 1;
inline bool BlockBioBackmergeFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockBioBackmergeFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockBioBackmergeFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBackmergeFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockBioBackmergeFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBackmergeFtraceEvent.dev)
}
inline ::uint64_t BlockBioBackmergeFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockBioBackmergeFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockBioBackmergeFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockBioBackmergeFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockBioBackmergeFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBackmergeFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockBioBackmergeFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBackmergeFtraceEvent.sector)
}
inline ::uint64_t BlockBioBackmergeFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockBioBackmergeFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockBioBackmergeFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockBioBackmergeFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockBioBackmergeFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBackmergeFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockBioBackmergeFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBackmergeFtraceEvent.nr_sector)
}
inline ::uint32_t BlockBioBackmergeFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockBioBackmergeFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional string rwbs = 4;
inline bool BlockBioBackmergeFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockBioBackmergeFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockBioBackmergeFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBackmergeFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioBackmergeFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBackmergeFtraceEvent.rwbs)
}
inline std::string* BlockBioBackmergeFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioBackmergeFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockBioBackmergeFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockBioBackmergeFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioBackmergeFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioBackmergeFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioBackmergeFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioBackmergeFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioBackmergeFtraceEvent.rwbs)
}

// optional string comm = 5;
inline bool BlockBioBackmergeFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockBioBackmergeFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockBioBackmergeFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBackmergeFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioBackmergeFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBackmergeFtraceEvent.comm)
}
inline std::string* BlockBioBackmergeFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioBackmergeFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockBioBackmergeFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockBioBackmergeFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioBackmergeFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioBackmergeFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioBackmergeFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioBackmergeFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioBackmergeFtraceEvent.comm)
}

// -------------------------------------------------------------------

// BlockBioBounceFtraceEvent

// optional uint64 dev = 1;
inline bool BlockBioBounceFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockBioBounceFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockBioBounceFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBounceFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockBioBounceFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBounceFtraceEvent.dev)
}
inline ::uint64_t BlockBioBounceFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockBioBounceFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockBioBounceFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockBioBounceFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockBioBounceFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBounceFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockBioBounceFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBounceFtraceEvent.sector)
}
inline ::uint64_t BlockBioBounceFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockBioBounceFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockBioBounceFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockBioBounceFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockBioBounceFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBounceFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockBioBounceFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBounceFtraceEvent.nr_sector)
}
inline ::uint32_t BlockBioBounceFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockBioBounceFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional string rwbs = 4;
inline bool BlockBioBounceFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockBioBounceFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockBioBounceFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBounceFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioBounceFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBounceFtraceEvent.rwbs)
}
inline std::string* BlockBioBounceFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioBounceFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockBioBounceFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockBioBounceFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioBounceFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioBounceFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioBounceFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioBounceFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioBounceFtraceEvent.rwbs)
}

// optional string comm = 5;
inline bool BlockBioBounceFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockBioBounceFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockBioBounceFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioBounceFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioBounceFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioBounceFtraceEvent.comm)
}
inline std::string* BlockBioBounceFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioBounceFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockBioBounceFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockBioBounceFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioBounceFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioBounceFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioBounceFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioBounceFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioBounceFtraceEvent.comm)
}

// -------------------------------------------------------------------

// BlockBioCompleteFtraceEvent

// optional uint64 dev = 1;
inline bool BlockBioCompleteFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockBioCompleteFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BlockBioCompleteFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioCompleteFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockBioCompleteFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioCompleteFtraceEvent.dev)
}
inline ::uint64_t BlockBioCompleteFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockBioCompleteFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockBioCompleteFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockBioCompleteFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockBioCompleteFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioCompleteFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockBioCompleteFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioCompleteFtraceEvent.sector)
}
inline ::uint64_t BlockBioCompleteFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockBioCompleteFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockBioCompleteFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockBioCompleteFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t BlockBioCompleteFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioCompleteFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockBioCompleteFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioCompleteFtraceEvent.nr_sector)
}
inline ::uint32_t BlockBioCompleteFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockBioCompleteFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.nr_sector_ = value;
}

// optional int32 error = 4;
inline bool BlockBioCompleteFtraceEvent::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockBioCompleteFtraceEvent::clear_error() {
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t BlockBioCompleteFtraceEvent::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioCompleteFtraceEvent.error)
  return _internal_error();
}
inline void BlockBioCompleteFtraceEvent::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioCompleteFtraceEvent.error)
}
inline ::int32_t BlockBioCompleteFtraceEvent::_internal_error() const {
  return _impl_.error_;
}
inline void BlockBioCompleteFtraceEvent::_internal_set_error(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}

// optional string rwbs = 5;
inline bool BlockBioCompleteFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockBioCompleteFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockBioCompleteFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioCompleteFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioCompleteFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioCompleteFtraceEvent.rwbs)
}
inline std::string* BlockBioCompleteFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioCompleteFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockBioCompleteFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockBioCompleteFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioCompleteFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioCompleteFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioCompleteFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioCompleteFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioCompleteFtraceEvent.rwbs)
}

// -------------------------------------------------------------------

// BlockBioFrontmergeFtraceEvent

// optional uint64 dev = 1;
inline bool BlockBioFrontmergeFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockBioFrontmergeFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockBioFrontmergeFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioFrontmergeFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockBioFrontmergeFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioFrontmergeFtraceEvent.dev)
}
inline ::uint64_t BlockBioFrontmergeFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockBioFrontmergeFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockBioFrontmergeFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockBioFrontmergeFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockBioFrontmergeFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioFrontmergeFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockBioFrontmergeFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioFrontmergeFtraceEvent.sector)
}
inline ::uint64_t BlockBioFrontmergeFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockBioFrontmergeFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockBioFrontmergeFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockBioFrontmergeFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockBioFrontmergeFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioFrontmergeFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockBioFrontmergeFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioFrontmergeFtraceEvent.nr_sector)
}
inline ::uint32_t BlockBioFrontmergeFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockBioFrontmergeFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional string rwbs = 4;
inline bool BlockBioFrontmergeFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockBioFrontmergeFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockBioFrontmergeFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioFrontmergeFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioFrontmergeFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioFrontmergeFtraceEvent.rwbs)
}
inline std::string* BlockBioFrontmergeFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioFrontmergeFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockBioFrontmergeFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockBioFrontmergeFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioFrontmergeFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioFrontmergeFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioFrontmergeFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioFrontmergeFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioFrontmergeFtraceEvent.rwbs)
}

// optional string comm = 5;
inline bool BlockBioFrontmergeFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockBioFrontmergeFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockBioFrontmergeFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioFrontmergeFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioFrontmergeFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioFrontmergeFtraceEvent.comm)
}
inline std::string* BlockBioFrontmergeFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioFrontmergeFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockBioFrontmergeFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockBioFrontmergeFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioFrontmergeFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioFrontmergeFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioFrontmergeFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioFrontmergeFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioFrontmergeFtraceEvent.comm)
}

// -------------------------------------------------------------------

// BlockBioQueueFtraceEvent

// optional uint64 dev = 1;
inline bool BlockBioQueueFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockBioQueueFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockBioQueueFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioQueueFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockBioQueueFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioQueueFtraceEvent.dev)
}
inline ::uint64_t BlockBioQueueFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockBioQueueFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockBioQueueFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockBioQueueFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockBioQueueFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioQueueFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockBioQueueFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioQueueFtraceEvent.sector)
}
inline ::uint64_t BlockBioQueueFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockBioQueueFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockBioQueueFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockBioQueueFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockBioQueueFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioQueueFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockBioQueueFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioQueueFtraceEvent.nr_sector)
}
inline ::uint32_t BlockBioQueueFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockBioQueueFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional string rwbs = 4;
inline bool BlockBioQueueFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockBioQueueFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockBioQueueFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioQueueFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioQueueFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioQueueFtraceEvent.rwbs)
}
inline std::string* BlockBioQueueFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioQueueFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockBioQueueFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockBioQueueFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioQueueFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioQueueFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioQueueFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioQueueFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioQueueFtraceEvent.rwbs)
}

// optional string comm = 5;
inline bool BlockBioQueueFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockBioQueueFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockBioQueueFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioQueueFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioQueueFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioQueueFtraceEvent.comm)
}
inline std::string* BlockBioQueueFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioQueueFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockBioQueueFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockBioQueueFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioQueueFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioQueueFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioQueueFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioQueueFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioQueueFtraceEvent.comm)
}

// -------------------------------------------------------------------

// BlockBioRemapFtraceEvent

// optional uint64 dev = 1;
inline bool BlockBioRemapFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockBioRemapFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BlockBioRemapFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioRemapFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockBioRemapFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioRemapFtraceEvent.dev)
}
inline ::uint64_t BlockBioRemapFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockBioRemapFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockBioRemapFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockBioRemapFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockBioRemapFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioRemapFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockBioRemapFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioRemapFtraceEvent.sector)
}
inline ::uint64_t BlockBioRemapFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockBioRemapFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockBioRemapFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BlockBioRemapFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t BlockBioRemapFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioRemapFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockBioRemapFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioRemapFtraceEvent.nr_sector)
}
inline ::uint32_t BlockBioRemapFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockBioRemapFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.nr_sector_ = value;
}

// optional uint64 old_dev = 4;
inline bool BlockBioRemapFtraceEvent::has_old_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockBioRemapFtraceEvent::clear_old_dev() {
  _impl_.old_dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockBioRemapFtraceEvent::old_dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioRemapFtraceEvent.old_dev)
  return _internal_old_dev();
}
inline void BlockBioRemapFtraceEvent::set_old_dev(::uint64_t value) {
  _internal_set_old_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioRemapFtraceEvent.old_dev)
}
inline ::uint64_t BlockBioRemapFtraceEvent::_internal_old_dev() const {
  return _impl_.old_dev_;
}
inline void BlockBioRemapFtraceEvent::_internal_set_old_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.old_dev_ = value;
}

// optional uint64 old_sector = 5;
inline bool BlockBioRemapFtraceEvent::has_old_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockBioRemapFtraceEvent::clear_old_sector() {
  _impl_.old_sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t BlockBioRemapFtraceEvent::old_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioRemapFtraceEvent.old_sector)
  return _internal_old_sector();
}
inline void BlockBioRemapFtraceEvent::set_old_sector(::uint64_t value) {
  _internal_set_old_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioRemapFtraceEvent.old_sector)
}
inline ::uint64_t BlockBioRemapFtraceEvent::_internal_old_sector() const {
  return _impl_.old_sector_;
}
inline void BlockBioRemapFtraceEvent::_internal_set_old_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.old_sector_ = value;
}

// optional string rwbs = 6;
inline bool BlockBioRemapFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockBioRemapFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockBioRemapFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockBioRemapFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockBioRemapFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockBioRemapFtraceEvent.rwbs)
}
inline std::string* BlockBioRemapFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockBioRemapFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockBioRemapFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockBioRemapFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockBioRemapFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockBioRemapFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockBioRemapFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockBioRemapFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockBioRemapFtraceEvent.rwbs)
}

// -------------------------------------------------------------------

// BlockDirtyBufferFtraceEvent

// optional uint64 dev = 1;
inline bool BlockDirtyBufferFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockDirtyBufferFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t BlockDirtyBufferFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockDirtyBufferFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockDirtyBufferFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockDirtyBufferFtraceEvent.dev)
}
inline ::uint64_t BlockDirtyBufferFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockDirtyBufferFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockDirtyBufferFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockDirtyBufferFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BlockDirtyBufferFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockDirtyBufferFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockDirtyBufferFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockDirtyBufferFtraceEvent.sector)
}
inline ::uint64_t BlockDirtyBufferFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockDirtyBufferFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sector_ = value;
}

// optional uint64 size = 3;
inline bool BlockDirtyBufferFtraceEvent::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockDirtyBufferFtraceEvent::clear_size() {
  _impl_.size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockDirtyBufferFtraceEvent::size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockDirtyBufferFtraceEvent.size)
  return _internal_size();
}
inline void BlockDirtyBufferFtraceEvent::set_size(::uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockDirtyBufferFtraceEvent.size)
}
inline ::uint64_t BlockDirtyBufferFtraceEvent::_internal_size() const {
  return _impl_.size_;
}
inline void BlockDirtyBufferFtraceEvent::_internal_set_size(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// BlockGetrqFtraceEvent

// optional uint64 dev = 1;
inline bool BlockGetrqFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockGetrqFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockGetrqFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockGetrqFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockGetrqFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockGetrqFtraceEvent.dev)
}
inline ::uint64_t BlockGetrqFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockGetrqFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockGetrqFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockGetrqFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockGetrqFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockGetrqFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockGetrqFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockGetrqFtraceEvent.sector)
}
inline ::uint64_t BlockGetrqFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockGetrqFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockGetrqFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockGetrqFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockGetrqFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockGetrqFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockGetrqFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockGetrqFtraceEvent.nr_sector)
}
inline ::uint32_t BlockGetrqFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockGetrqFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional string rwbs = 4;
inline bool BlockGetrqFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockGetrqFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockGetrqFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockGetrqFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockGetrqFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockGetrqFtraceEvent.rwbs)
}
inline std::string* BlockGetrqFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockGetrqFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockGetrqFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockGetrqFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockGetrqFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockGetrqFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockGetrqFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockGetrqFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockGetrqFtraceEvent.rwbs)
}

// optional string comm = 5;
inline bool BlockGetrqFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockGetrqFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockGetrqFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockGetrqFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockGetrqFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockGetrqFtraceEvent.comm)
}
inline std::string* BlockGetrqFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockGetrqFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockGetrqFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockGetrqFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockGetrqFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockGetrqFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockGetrqFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockGetrqFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockGetrqFtraceEvent.comm)
}

// -------------------------------------------------------------------

// BlockPlugFtraceEvent

// optional string comm = 1;
inline bool BlockPlugFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockPlugFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockPlugFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockPlugFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockPlugFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockPlugFtraceEvent.comm)
}
inline std::string* BlockPlugFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockPlugFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockPlugFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockPlugFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockPlugFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockPlugFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockPlugFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockPlugFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockPlugFtraceEvent.comm)
}

// -------------------------------------------------------------------

// BlockRqAbortFtraceEvent

// optional uint64 dev = 1;
inline bool BlockRqAbortFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockRqAbortFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockRqAbortFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqAbortFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockRqAbortFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqAbortFtraceEvent.dev)
}
inline ::uint64_t BlockRqAbortFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockRqAbortFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockRqAbortFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockRqAbortFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockRqAbortFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqAbortFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockRqAbortFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqAbortFtraceEvent.sector)
}
inline ::uint64_t BlockRqAbortFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockRqAbortFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockRqAbortFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockRqAbortFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockRqAbortFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqAbortFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockRqAbortFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqAbortFtraceEvent.nr_sector)
}
inline ::uint32_t BlockRqAbortFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockRqAbortFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional int32 errors = 4;
inline bool BlockRqAbortFtraceEvent::has_errors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BlockRqAbortFtraceEvent::clear_errors() {
  _impl_.errors_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BlockRqAbortFtraceEvent::errors() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqAbortFtraceEvent.errors)
  return _internal_errors();
}
inline void BlockRqAbortFtraceEvent::set_errors(::int32_t value) {
  _internal_set_errors(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqAbortFtraceEvent.errors)
}
inline ::int32_t BlockRqAbortFtraceEvent::_internal_errors() const {
  return _impl_.errors_;
}
inline void BlockRqAbortFtraceEvent::_internal_set_errors(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.errors_ = value;
}

// optional string rwbs = 5;
inline bool BlockRqAbortFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockRqAbortFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockRqAbortFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqAbortFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqAbortFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqAbortFtraceEvent.rwbs)
}
inline std::string* BlockRqAbortFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqAbortFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockRqAbortFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockRqAbortFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqAbortFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqAbortFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqAbortFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqAbortFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqAbortFtraceEvent.rwbs)
}

// optional string cmd = 6;
inline bool BlockRqAbortFtraceEvent::has_cmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockRqAbortFtraceEvent::clear_cmd() {
  _impl_.cmd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockRqAbortFtraceEvent::cmd() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqAbortFtraceEvent.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqAbortFtraceEvent::set_cmd(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cmd_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqAbortFtraceEvent.cmd)
}
inline std::string* BlockRqAbortFtraceEvent::mutable_cmd() {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqAbortFtraceEvent.cmd)
  return _s;
}
inline const std::string& BlockRqAbortFtraceEvent::_internal_cmd() const {
  return _impl_.cmd_.Get();
}
inline void BlockRqAbortFtraceEvent::_internal_set_cmd(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.cmd_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqAbortFtraceEvent::_internal_mutable_cmd() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cmd_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqAbortFtraceEvent::release_cmd() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqAbortFtraceEvent.cmd)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.cmd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqAbortFtraceEvent::set_allocated_cmd(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cmd_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_.IsDefault()) {
          _impl_.cmd_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqAbortFtraceEvent.cmd)
}

// -------------------------------------------------------------------

// BlockRqCompleteFtraceEvent

// optional uint64 dev = 1;
inline bool BlockRqCompleteFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockRqCompleteFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockRqCompleteFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqCompleteFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockRqCompleteFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqCompleteFtraceEvent.dev)
}
inline ::uint64_t BlockRqCompleteFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockRqCompleteFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockRqCompleteFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockRqCompleteFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockRqCompleteFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqCompleteFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockRqCompleteFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqCompleteFtraceEvent.sector)
}
inline ::uint64_t BlockRqCompleteFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockRqCompleteFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockRqCompleteFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockRqCompleteFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockRqCompleteFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqCompleteFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockRqCompleteFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqCompleteFtraceEvent.nr_sector)
}
inline ::uint32_t BlockRqCompleteFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockRqCompleteFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional int32 errors = 4;
inline bool BlockRqCompleteFtraceEvent::has_errors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BlockRqCompleteFtraceEvent::clear_errors() {
  _impl_.errors_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BlockRqCompleteFtraceEvent::errors() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqCompleteFtraceEvent.errors)
  return _internal_errors();
}
inline void BlockRqCompleteFtraceEvent::set_errors(::int32_t value) {
  _internal_set_errors(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqCompleteFtraceEvent.errors)
}
inline ::int32_t BlockRqCompleteFtraceEvent::_internal_errors() const {
  return _impl_.errors_;
}
inline void BlockRqCompleteFtraceEvent::_internal_set_errors(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.errors_ = value;
}

// optional string rwbs = 5;
inline bool BlockRqCompleteFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockRqCompleteFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockRqCompleteFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqCompleteFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqCompleteFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqCompleteFtraceEvent.rwbs)
}
inline std::string* BlockRqCompleteFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqCompleteFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockRqCompleteFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockRqCompleteFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqCompleteFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqCompleteFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqCompleteFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqCompleteFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqCompleteFtraceEvent.rwbs)
}

// optional string cmd = 6;
inline bool BlockRqCompleteFtraceEvent::has_cmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockRqCompleteFtraceEvent::clear_cmd() {
  _impl_.cmd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockRqCompleteFtraceEvent::cmd() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqCompleteFtraceEvent.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqCompleteFtraceEvent::set_cmd(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cmd_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqCompleteFtraceEvent.cmd)
}
inline std::string* BlockRqCompleteFtraceEvent::mutable_cmd() {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqCompleteFtraceEvent.cmd)
  return _s;
}
inline const std::string& BlockRqCompleteFtraceEvent::_internal_cmd() const {
  return _impl_.cmd_.Get();
}
inline void BlockRqCompleteFtraceEvent::_internal_set_cmd(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.cmd_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqCompleteFtraceEvent::_internal_mutable_cmd() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cmd_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqCompleteFtraceEvent::release_cmd() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqCompleteFtraceEvent.cmd)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.cmd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqCompleteFtraceEvent::set_allocated_cmd(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cmd_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_.IsDefault()) {
          _impl_.cmd_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqCompleteFtraceEvent.cmd)
}

// optional int32 error = 7;
inline bool BlockRqCompleteFtraceEvent::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BlockRqCompleteFtraceEvent::clear_error() {
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t BlockRqCompleteFtraceEvent::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqCompleteFtraceEvent.error)
  return _internal_error();
}
inline void BlockRqCompleteFtraceEvent::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqCompleteFtraceEvent.error)
}
inline ::int32_t BlockRqCompleteFtraceEvent::_internal_error() const {
  return _impl_.error_;
}
inline void BlockRqCompleteFtraceEvent::_internal_set_error(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.error_ = value;
}

// -------------------------------------------------------------------

// BlockRqInsertFtraceEvent

// optional uint64 dev = 1;
inline bool BlockRqInsertFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockRqInsertFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockRqInsertFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqInsertFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockRqInsertFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqInsertFtraceEvent.dev)
}
inline ::uint64_t BlockRqInsertFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockRqInsertFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockRqInsertFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockRqInsertFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t BlockRqInsertFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqInsertFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockRqInsertFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqInsertFtraceEvent.sector)
}
inline ::uint64_t BlockRqInsertFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockRqInsertFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockRqInsertFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BlockRqInsertFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t BlockRqInsertFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqInsertFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockRqInsertFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqInsertFtraceEvent.nr_sector)
}
inline ::uint32_t BlockRqInsertFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockRqInsertFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.nr_sector_ = value;
}

// optional uint32 bytes = 4;
inline bool BlockRqInsertFtraceEvent::has_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BlockRqInsertFtraceEvent::clear_bytes() {
  _impl_.bytes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t BlockRqInsertFtraceEvent::bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqInsertFtraceEvent.bytes)
  return _internal_bytes();
}
inline void BlockRqInsertFtraceEvent::set_bytes(::uint32_t value) {
  _internal_set_bytes(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqInsertFtraceEvent.bytes)
}
inline ::uint32_t BlockRqInsertFtraceEvent::_internal_bytes() const {
  return _impl_.bytes_;
}
inline void BlockRqInsertFtraceEvent::_internal_set_bytes(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.bytes_ = value;
}

// optional string rwbs = 5;
inline bool BlockRqInsertFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockRqInsertFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockRqInsertFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqInsertFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqInsertFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqInsertFtraceEvent.rwbs)
}
inline std::string* BlockRqInsertFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqInsertFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockRqInsertFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockRqInsertFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqInsertFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqInsertFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqInsertFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqInsertFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqInsertFtraceEvent.rwbs)
}

// optional string comm = 6;
inline bool BlockRqInsertFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockRqInsertFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockRqInsertFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqInsertFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqInsertFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqInsertFtraceEvent.comm)
}
inline std::string* BlockRqInsertFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqInsertFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockRqInsertFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockRqInsertFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqInsertFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqInsertFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqInsertFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqInsertFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqInsertFtraceEvent.comm)
}

// optional string cmd = 7;
inline bool BlockRqInsertFtraceEvent::has_cmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockRqInsertFtraceEvent::clear_cmd() {
  _impl_.cmd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BlockRqInsertFtraceEvent::cmd() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqInsertFtraceEvent.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqInsertFtraceEvent::set_cmd(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cmd_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqInsertFtraceEvent.cmd)
}
inline std::string* BlockRqInsertFtraceEvent::mutable_cmd() {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqInsertFtraceEvent.cmd)
  return _s;
}
inline const std::string& BlockRqInsertFtraceEvent::_internal_cmd() const {
  return _impl_.cmd_.Get();
}
inline void BlockRqInsertFtraceEvent::_internal_set_cmd(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.cmd_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqInsertFtraceEvent::_internal_mutable_cmd() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.cmd_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqInsertFtraceEvent::release_cmd() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqInsertFtraceEvent.cmd)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.cmd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqInsertFtraceEvent::set_allocated_cmd(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cmd_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_.IsDefault()) {
          _impl_.cmd_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqInsertFtraceEvent.cmd)
}

// -------------------------------------------------------------------

// BlockRqRemapFtraceEvent

// optional uint64 dev = 1;
inline bool BlockRqRemapFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockRqRemapFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BlockRqRemapFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRemapFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockRqRemapFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRemapFtraceEvent.dev)
}
inline ::uint64_t BlockRqRemapFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockRqRemapFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockRqRemapFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockRqRemapFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockRqRemapFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRemapFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockRqRemapFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRemapFtraceEvent.sector)
}
inline ::uint64_t BlockRqRemapFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockRqRemapFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockRqRemapFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockRqRemapFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockRqRemapFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRemapFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockRqRemapFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRemapFtraceEvent.nr_sector)
}
inline ::uint32_t BlockRqRemapFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockRqRemapFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional uint64 old_dev = 4;
inline bool BlockRqRemapFtraceEvent::has_old_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockRqRemapFtraceEvent::clear_old_dev() {
  _impl_.old_dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockRqRemapFtraceEvent::old_dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRemapFtraceEvent.old_dev)
  return _internal_old_dev();
}
inline void BlockRqRemapFtraceEvent::set_old_dev(::uint64_t value) {
  _internal_set_old_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRemapFtraceEvent.old_dev)
}
inline ::uint64_t BlockRqRemapFtraceEvent::_internal_old_dev() const {
  return _impl_.old_dev_;
}
inline void BlockRqRemapFtraceEvent::_internal_set_old_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.old_dev_ = value;
}

// optional uint64 old_sector = 5;
inline bool BlockRqRemapFtraceEvent::has_old_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BlockRqRemapFtraceEvent::clear_old_sector() {
  _impl_.old_sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t BlockRqRemapFtraceEvent::old_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRemapFtraceEvent.old_sector)
  return _internal_old_sector();
}
inline void BlockRqRemapFtraceEvent::set_old_sector(::uint64_t value) {
  _internal_set_old_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRemapFtraceEvent.old_sector)
}
inline ::uint64_t BlockRqRemapFtraceEvent::_internal_old_sector() const {
  return _impl_.old_sector_;
}
inline void BlockRqRemapFtraceEvent::_internal_set_old_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.old_sector_ = value;
}

// optional uint32 nr_bios = 6;
inline bool BlockRqRemapFtraceEvent::has_nr_bios() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BlockRqRemapFtraceEvent::clear_nr_bios() {
  _impl_.nr_bios_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t BlockRqRemapFtraceEvent::nr_bios() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRemapFtraceEvent.nr_bios)
  return _internal_nr_bios();
}
inline void BlockRqRemapFtraceEvent::set_nr_bios(::uint32_t value) {
  _internal_set_nr_bios(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRemapFtraceEvent.nr_bios)
}
inline ::uint32_t BlockRqRemapFtraceEvent::_internal_nr_bios() const {
  return _impl_.nr_bios_;
}
inline void BlockRqRemapFtraceEvent::_internal_set_nr_bios(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.nr_bios_ = value;
}

// optional string rwbs = 7;
inline bool BlockRqRemapFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockRqRemapFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockRqRemapFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRemapFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqRemapFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRemapFtraceEvent.rwbs)
}
inline std::string* BlockRqRemapFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqRemapFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockRqRemapFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockRqRemapFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqRemapFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqRemapFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqRemapFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqRemapFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqRemapFtraceEvent.rwbs)
}

// -------------------------------------------------------------------

// BlockRqRequeueFtraceEvent

// optional uint64 dev = 1;
inline bool BlockRqRequeueFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockRqRequeueFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockRqRequeueFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRequeueFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockRqRequeueFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRequeueFtraceEvent.dev)
}
inline ::uint64_t BlockRqRequeueFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockRqRequeueFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockRqRequeueFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockRqRequeueFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockRqRequeueFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRequeueFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockRqRequeueFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRequeueFtraceEvent.sector)
}
inline ::uint64_t BlockRqRequeueFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockRqRequeueFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockRqRequeueFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockRqRequeueFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockRqRequeueFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRequeueFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockRqRequeueFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRequeueFtraceEvent.nr_sector)
}
inline ::uint32_t BlockRqRequeueFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockRqRequeueFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional int32 errors = 4;
inline bool BlockRqRequeueFtraceEvent::has_errors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BlockRqRequeueFtraceEvent::clear_errors() {
  _impl_.errors_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BlockRqRequeueFtraceEvent::errors() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRequeueFtraceEvent.errors)
  return _internal_errors();
}
inline void BlockRqRequeueFtraceEvent::set_errors(::int32_t value) {
  _internal_set_errors(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRequeueFtraceEvent.errors)
}
inline ::int32_t BlockRqRequeueFtraceEvent::_internal_errors() const {
  return _impl_.errors_;
}
inline void BlockRqRequeueFtraceEvent::_internal_set_errors(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.errors_ = value;
}

// optional string rwbs = 5;
inline bool BlockRqRequeueFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockRqRequeueFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockRqRequeueFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRequeueFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqRequeueFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRequeueFtraceEvent.rwbs)
}
inline std::string* BlockRqRequeueFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqRequeueFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockRqRequeueFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockRqRequeueFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqRequeueFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqRequeueFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqRequeueFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqRequeueFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqRequeueFtraceEvent.rwbs)
}

// optional string cmd = 6;
inline bool BlockRqRequeueFtraceEvent::has_cmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockRqRequeueFtraceEvent::clear_cmd() {
  _impl_.cmd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockRqRequeueFtraceEvent::cmd() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockRqRequeueFtraceEvent.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockRqRequeueFtraceEvent::set_cmd(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cmd_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockRqRequeueFtraceEvent.cmd)
}
inline std::string* BlockRqRequeueFtraceEvent::mutable_cmd() {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockRqRequeueFtraceEvent.cmd)
  return _s;
}
inline const std::string& BlockRqRequeueFtraceEvent::_internal_cmd() const {
  return _impl_.cmd_.Get();
}
inline void BlockRqRequeueFtraceEvent::_internal_set_cmd(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.cmd_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockRqRequeueFtraceEvent::_internal_mutable_cmd() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cmd_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockRqRequeueFtraceEvent::release_cmd() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockRqRequeueFtraceEvent.cmd)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.cmd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockRqRequeueFtraceEvent::set_allocated_cmd(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cmd_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_.IsDefault()) {
          _impl_.cmd_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockRqRequeueFtraceEvent.cmd)
}

// -------------------------------------------------------------------

// BlockSleeprqFtraceEvent

// optional uint64 dev = 1;
inline bool BlockSleeprqFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockSleeprqFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockSleeprqFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSleeprqFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockSleeprqFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSleeprqFtraceEvent.dev)
}
inline ::uint64_t BlockSleeprqFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockSleeprqFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockSleeprqFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockSleeprqFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockSleeprqFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSleeprqFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockSleeprqFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSleeprqFtraceEvent.sector)
}
inline ::uint64_t BlockSleeprqFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockSleeprqFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint32 nr_sector = 3;
inline bool BlockSleeprqFtraceEvent::has_nr_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockSleeprqFtraceEvent::clear_nr_sector() {
  _impl_.nr_sector_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BlockSleeprqFtraceEvent::nr_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSleeprqFtraceEvent.nr_sector)
  return _internal_nr_sector();
}
inline void BlockSleeprqFtraceEvent::set_nr_sector(::uint32_t value) {
  _internal_set_nr_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSleeprqFtraceEvent.nr_sector)
}
inline ::uint32_t BlockSleeprqFtraceEvent::_internal_nr_sector() const {
  return _impl_.nr_sector_;
}
inline void BlockSleeprqFtraceEvent::_internal_set_nr_sector(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nr_sector_ = value;
}

// optional string rwbs = 4;
inline bool BlockSleeprqFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockSleeprqFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockSleeprqFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSleeprqFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockSleeprqFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSleeprqFtraceEvent.rwbs)
}
inline std::string* BlockSleeprqFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockSleeprqFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockSleeprqFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockSleeprqFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockSleeprqFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockSleeprqFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockSleeprqFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockSleeprqFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockSleeprqFtraceEvent.rwbs)
}

// optional string comm = 5;
inline bool BlockSleeprqFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockSleeprqFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockSleeprqFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSleeprqFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockSleeprqFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSleeprqFtraceEvent.comm)
}
inline std::string* BlockSleeprqFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockSleeprqFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockSleeprqFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockSleeprqFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockSleeprqFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockSleeprqFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockSleeprqFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockSleeprqFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockSleeprqFtraceEvent.comm)
}

// -------------------------------------------------------------------

// BlockSplitFtraceEvent

// optional uint64 dev = 1;
inline bool BlockSplitFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockSplitFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockSplitFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSplitFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockSplitFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSplitFtraceEvent.dev)
}
inline ::uint64_t BlockSplitFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockSplitFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockSplitFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BlockSplitFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BlockSplitFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSplitFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockSplitFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSplitFtraceEvent.sector)
}
inline ::uint64_t BlockSplitFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockSplitFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sector_ = value;
}

// optional uint64 new_sector = 3;
inline bool BlockSplitFtraceEvent::has_new_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BlockSplitFtraceEvent::clear_new_sector() {
  _impl_.new_sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t BlockSplitFtraceEvent::new_sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSplitFtraceEvent.new_sector)
  return _internal_new_sector();
}
inline void BlockSplitFtraceEvent::set_new_sector(::uint64_t value) {
  _internal_set_new_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSplitFtraceEvent.new_sector)
}
inline ::uint64_t BlockSplitFtraceEvent::_internal_new_sector() const {
  return _impl_.new_sector_;
}
inline void BlockSplitFtraceEvent::_internal_set_new_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.new_sector_ = value;
}

// optional string rwbs = 4;
inline bool BlockSplitFtraceEvent::has_rwbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockSplitFtraceEvent::clear_rwbs() {
  _impl_.rwbs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockSplitFtraceEvent::rwbs() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSplitFtraceEvent.rwbs)
  return _internal_rwbs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockSplitFtraceEvent::set_rwbs(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rwbs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSplitFtraceEvent.rwbs)
}
inline std::string* BlockSplitFtraceEvent::mutable_rwbs() {
  std::string* _s = _internal_mutable_rwbs();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockSplitFtraceEvent.rwbs)
  return _s;
}
inline const std::string& BlockSplitFtraceEvent::_internal_rwbs() const {
  return _impl_.rwbs_.Get();
}
inline void BlockSplitFtraceEvent::_internal_set_rwbs(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rwbs_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockSplitFtraceEvent::_internal_mutable_rwbs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rwbs_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockSplitFtraceEvent::release_rwbs() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockSplitFtraceEvent.rwbs)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rwbs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rwbs_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockSplitFtraceEvent::set_allocated_rwbs(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rwbs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rwbs_.IsDefault()) {
          _impl_.rwbs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockSplitFtraceEvent.rwbs)
}

// optional string comm = 5;
inline bool BlockSplitFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockSplitFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockSplitFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockSplitFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockSplitFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockSplitFtraceEvent.comm)
}
inline std::string* BlockSplitFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockSplitFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockSplitFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockSplitFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockSplitFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockSplitFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockSplitFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockSplitFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockSplitFtraceEvent.comm)
}

// -------------------------------------------------------------------

// BlockTouchBufferFtraceEvent

// optional uint64 dev = 1;
inline bool BlockTouchBufferFtraceEvent::has_dev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockTouchBufferFtraceEvent::clear_dev() {
  _impl_.dev_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t BlockTouchBufferFtraceEvent::dev() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockTouchBufferFtraceEvent.dev)
  return _internal_dev();
}
inline void BlockTouchBufferFtraceEvent::set_dev(::uint64_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockTouchBufferFtraceEvent.dev)
}
inline ::uint64_t BlockTouchBufferFtraceEvent::_internal_dev() const {
  return _impl_.dev_;
}
inline void BlockTouchBufferFtraceEvent::_internal_set_dev(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dev_ = value;
}

// optional uint64 sector = 2;
inline bool BlockTouchBufferFtraceEvent::has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockTouchBufferFtraceEvent::clear_sector() {
  _impl_.sector_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BlockTouchBufferFtraceEvent::sector() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockTouchBufferFtraceEvent.sector)
  return _internal_sector();
}
inline void BlockTouchBufferFtraceEvent::set_sector(::uint64_t value) {
  _internal_set_sector(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockTouchBufferFtraceEvent.sector)
}
inline ::uint64_t BlockTouchBufferFtraceEvent::_internal_sector() const {
  return _impl_.sector_;
}
inline void BlockTouchBufferFtraceEvent::_internal_set_sector(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sector_ = value;
}

// optional uint64 size = 3;
inline bool BlockTouchBufferFtraceEvent::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BlockTouchBufferFtraceEvent::clear_size() {
  _impl_.size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t BlockTouchBufferFtraceEvent::size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockTouchBufferFtraceEvent.size)
  return _internal_size();
}
inline void BlockTouchBufferFtraceEvent::set_size(::uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockTouchBufferFtraceEvent.size)
}
inline ::uint64_t BlockTouchBufferFtraceEvent::_internal_size() const {
  return _impl_.size_;
}
inline void BlockTouchBufferFtraceEvent::_internal_set_size(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// BlockUnplugFtraceEvent

// optional int32 nr_rq = 1;
inline bool BlockUnplugFtraceEvent::has_nr_rq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BlockUnplugFtraceEvent::clear_nr_rq() {
  _impl_.nr_rq_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BlockUnplugFtraceEvent::nr_rq() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockUnplugFtraceEvent.nr_rq)
  return _internal_nr_rq();
}
inline void BlockUnplugFtraceEvent::set_nr_rq(::int32_t value) {
  _internal_set_nr_rq(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockUnplugFtraceEvent.nr_rq)
}
inline ::int32_t BlockUnplugFtraceEvent::_internal_nr_rq() const {
  return _impl_.nr_rq_;
}
inline void BlockUnplugFtraceEvent::_internal_set_nr_rq(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nr_rq_ = value;
}

// optional string comm = 2;
inline bool BlockUnplugFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlockUnplugFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockUnplugFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.BlockUnplugFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockUnplugFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.BlockUnplugFtraceEvent.comm)
}
inline std::string* BlockUnplugFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.BlockUnplugFtraceEvent.comm)
  return _s;
}
inline const std::string& BlockUnplugFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void BlockUnplugFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockUnplugFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockUnplugFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.BlockUnplugFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BlockUnplugFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.BlockUnplugFtraceEvent.comm)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fblock_2eproto_2epb_2eh
