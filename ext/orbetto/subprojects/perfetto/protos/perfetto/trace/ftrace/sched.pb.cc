// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/sched.proto

#include "protos/perfetto/trace/ftrace/sched.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace perfetto {
namespace protos {
template <typename>
PROTOBUF_CONSTEXPR SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.prev_comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.next_comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.prev_pid_)*/ 0

  , /*decltype(_impl_.prev_prio_)*/ 0

  , /*decltype(_impl_.prev_state_)*/ ::int64_t{0}

  , /*decltype(_impl_.next_pid_)*/ 0

  , /*decltype(_impl_.next_prio_)*/ 0
} {}
struct SchedSwitchFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedSwitchFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedSwitchFtraceEventDefaultTypeInternal() {}
  union {
    SchedSwitchFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedSwitchFtraceEventDefaultTypeInternal _SchedSwitchFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.pid_)*/ 0

  , /*decltype(_impl_.prio_)*/ 0

  , /*decltype(_impl_.success_)*/ 0

  , /*decltype(_impl_.target_cpu_)*/ 0
} {}
struct SchedWakeupFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedWakeupFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedWakeupFtraceEventDefaultTypeInternal() {}
  union {
    SchedWakeupFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedWakeupFtraceEventDefaultTypeInternal _SchedWakeupFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.caller_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pid_)*/ 0

  , /*decltype(_impl_.io_wait_)*/ 0u
} {}
struct SchedBlockedReasonFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedBlockedReasonFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedBlockedReasonFtraceEventDefaultTypeInternal() {}
  union {
    SchedBlockedReasonFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedBlockedReasonFtraceEventDefaultTypeInternal _SchedBlockedReasonFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.affected_cpu_)*/ 0

  , /*decltype(_impl_.error_)*/ 0

  , /*decltype(_impl_.status_)*/ 0
} {}
struct SchedCpuHotplugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedCpuHotplugFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedCpuHotplugFtraceEventDefaultTypeInternal() {}
  union {
    SchedCpuHotplugFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedCpuHotplugFtraceEventDefaultTypeInternal _SchedCpuHotplugFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedWakingFtraceEvent::SchedWakingFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.pid_)*/ 0

  , /*decltype(_impl_.prio_)*/ 0

  , /*decltype(_impl_.success_)*/ 0

  , /*decltype(_impl_.target_cpu_)*/ 0
} {}
struct SchedWakingFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedWakingFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedWakingFtraceEventDefaultTypeInternal() {}
  union {
    SchedWakingFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedWakingFtraceEventDefaultTypeInternal _SchedWakingFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.pid_)*/ 0

  , /*decltype(_impl_.prio_)*/ 0

  , /*decltype(_impl_.success_)*/ 0

  , /*decltype(_impl_.target_cpu_)*/ 0
} {}
struct SchedWakeupNewFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedWakeupNewFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedWakeupNewFtraceEventDefaultTypeInternal() {}
  union {
    SchedWakeupNewFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedWakeupNewFtraceEventDefaultTypeInternal _SchedWakeupNewFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filename_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.pid_)*/ 0

  , /*decltype(_impl_.old_pid_)*/ 0
} {}
struct SchedProcessExecFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessExecFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessExecFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessExecFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessExecFtraceEventDefaultTypeInternal _SchedProcessExecFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.pid_)*/ 0

  , /*decltype(_impl_.tgid_)*/ 0

  , /*decltype(_impl_.prio_)*/ 0
} {}
struct SchedProcessExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessExitFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessExitFtraceEventDefaultTypeInternal _SchedProcessExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.child_comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.parent_pid_)*/ 0

  , /*decltype(_impl_.child_pid_)*/ 0
} {}
struct SchedProcessForkFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessForkFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessForkFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessForkFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessForkFtraceEventDefaultTypeInternal _SchedProcessForkFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.pid_)*/ 0

  , /*decltype(_impl_.prio_)*/ 0
} {}
struct SchedProcessFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessFreeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessFreeFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessFreeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessFreeFtraceEventDefaultTypeInternal _SchedProcessFreeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.pid_)*/ 0
} {}
struct SchedProcessHangFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessHangFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessHangFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessHangFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessHangFtraceEventDefaultTypeInternal _SchedProcessHangFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.pid_)*/ 0

  , /*decltype(_impl_.prio_)*/ 0
} {}
struct SchedProcessWaitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessWaitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessWaitFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessWaitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessWaitFtraceEventDefaultTypeInternal _SchedProcessWaitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.newprio_)*/ 0

  , /*decltype(_impl_.oldprio_)*/ 0

  , /*decltype(_impl_.pid_)*/ 0
} {}
struct SchedPiSetprioFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedPiSetprioFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedPiSetprioFtraceEventDefaultTypeInternal() {}
  union {
    SchedPiSetprioFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedPiSetprioFtraceEventDefaultTypeInternal _SchedPiSetprioFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.capacity_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.active_)*/ 0

  , /*decltype(_impl_.cpu_)*/ 0u

  , /*decltype(_impl_.capacity_orig_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.cpu_importance_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.cpu_util_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.group_capacity_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.exit_lat_)*/ 0u

  , /*decltype(_impl_.grp_overutilized_)*/ 0u

  , /*decltype(_impl_.idle_cpu_)*/ 0u

  , /*decltype(_impl_.nr_running_)*/ 0u

  , /*decltype(_impl_.spare_cap_)*/ ::int64_t{0}

  , /*decltype(_impl_.wake_group_util_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.wake_util_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.task_fits_)*/ 0u
} {}
struct SchedCpuUtilCfsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedCpuUtilCfsFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedCpuUtilCfsFtraceEventDefaultTypeInternal() {}
  union {
    SchedCpuUtilCfsFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedCpuUtilCfsFtraceEventDefaultTypeInternal _SchedCpuUtilCfsFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
static ::_pb::Metadata file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[14];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto = nullptr;
const ::uint32_t TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedSwitchFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedSwitchFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedSwitchFtraceEvent, _impl_.prev_comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedSwitchFtraceEvent, _impl_.prev_pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedSwitchFtraceEvent, _impl_.prev_prio_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedSwitchFtraceEvent, _impl_.prev_state_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedSwitchFtraceEvent, _impl_.next_comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedSwitchFtraceEvent, _impl_.next_pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedSwitchFtraceEvent, _impl_.next_prio_),
    0,
    2,
    3,
    4,
    1,
    5,
    6,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupFtraceEvent, _impl_.comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupFtraceEvent, _impl_.pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupFtraceEvent, _impl_.prio_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupFtraceEvent, _impl_.success_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupFtraceEvent, _impl_.target_cpu_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedBlockedReasonFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedBlockedReasonFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedBlockedReasonFtraceEvent, _impl_.pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedBlockedReasonFtraceEvent, _impl_.caller_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedBlockedReasonFtraceEvent, _impl_.io_wait_),
    1,
    0,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuHotplugFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuHotplugFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuHotplugFtraceEvent, _impl_.affected_cpu_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuHotplugFtraceEvent, _impl_.error_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuHotplugFtraceEvent, _impl_.status_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakingFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakingFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakingFtraceEvent, _impl_.comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakingFtraceEvent, _impl_.pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakingFtraceEvent, _impl_.prio_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakingFtraceEvent, _impl_.success_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakingFtraceEvent, _impl_.target_cpu_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupNewFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupNewFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupNewFtraceEvent, _impl_.comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupNewFtraceEvent, _impl_.pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupNewFtraceEvent, _impl_.prio_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupNewFtraceEvent, _impl_.success_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedWakeupNewFtraceEvent, _impl_.target_cpu_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExecFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExecFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExecFtraceEvent, _impl_.filename_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExecFtraceEvent, _impl_.pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExecFtraceEvent, _impl_.old_pid_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExitFtraceEvent, _impl_.comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExitFtraceEvent, _impl_.pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExitFtraceEvent, _impl_.tgid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessExitFtraceEvent, _impl_.prio_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessForkFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessForkFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessForkFtraceEvent, _impl_.parent_comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessForkFtraceEvent, _impl_.parent_pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessForkFtraceEvent, _impl_.child_comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessForkFtraceEvent, _impl_.child_pid_),
    0,
    2,
    1,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessFreeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessFreeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessFreeFtraceEvent, _impl_.comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessFreeFtraceEvent, _impl_.pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessFreeFtraceEvent, _impl_.prio_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessHangFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessHangFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessHangFtraceEvent, _impl_.comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessHangFtraceEvent, _impl_.pid_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessWaitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessWaitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessWaitFtraceEvent, _impl_.comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessWaitFtraceEvent, _impl_.pid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedProcessWaitFtraceEvent, _impl_.prio_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedPiSetprioFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedPiSetprioFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedPiSetprioFtraceEvent, _impl_.comm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedPiSetprioFtraceEvent, _impl_.newprio_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedPiSetprioFtraceEvent, _impl_.oldprio_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedPiSetprioFtraceEvent, _impl_.pid_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.active_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.capacity_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.capacity_orig_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.cpu_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.cpu_importance_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.cpu_util_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.exit_lat_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.group_capacity_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.grp_overutilized_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.idle_cpu_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.nr_running_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.spare_cap_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.task_fits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.wake_group_util_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::SchedCpuUtilCfsFtraceEvent, _impl_.wake_util_),
    1,
    0,
    3,
    2,
    4,
    5,
    7,
    6,
    8,
    9,
    10,
    11,
    14,
    12,
    13,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 15, -1, sizeof(::perfetto::protos::SchedSwitchFtraceEvent)},
        { 22, 35, -1, sizeof(::perfetto::protos::SchedWakeupFtraceEvent)},
        { 40, 51, -1, sizeof(::perfetto::protos::SchedBlockedReasonFtraceEvent)},
        { 54, 65, -1, sizeof(::perfetto::protos::SchedCpuHotplugFtraceEvent)},
        { 68, 81, -1, sizeof(::perfetto::protos::SchedWakingFtraceEvent)},
        { 86, 99, -1, sizeof(::perfetto::protos::SchedWakeupNewFtraceEvent)},
        { 104, 115, -1, sizeof(::perfetto::protos::SchedProcessExecFtraceEvent)},
        { 118, 130, -1, sizeof(::perfetto::protos::SchedProcessExitFtraceEvent)},
        { 134, 146, -1, sizeof(::perfetto::protos::SchedProcessForkFtraceEvent)},
        { 150, 161, -1, sizeof(::perfetto::protos::SchedProcessFreeFtraceEvent)},
        { 164, 174, -1, sizeof(::perfetto::protos::SchedProcessHangFtraceEvent)},
        { 176, 187, -1, sizeof(::perfetto::protos::SchedProcessWaitFtraceEvent)},
        { 190, 202, -1, sizeof(::perfetto::protos::SchedPiSetprioFtraceEvent)},
        { 206, 229, -1, sizeof(::perfetto::protos::SchedCpuUtilCfsFtraceEvent)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::perfetto::protos::_SchedSwitchFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedWakeupFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedBlockedReasonFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedCpuHotplugFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedWakingFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedWakeupNewFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedProcessExecFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedProcessExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedProcessForkFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedProcessFreeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedProcessHangFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedProcessWaitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedPiSetprioFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_SchedCpuUtilCfsFtraceEvent_default_instance_._instance,
};
const char descriptor_table_protodef_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n(protos/perfetto/trace/ftrace/sched.pro"
    "to\022\017perfetto.protos\"\234\001\n\026SchedSwitchFtrac"
    "eEvent\022\021\n\tprev_comm\030\001 \001(\t\022\020\n\010prev_pid\030\002 "
    "\001(\005\022\021\n\tprev_prio\030\003 \001(\005\022\022\n\nprev_state\030\004 \001"
    "(\003\022\021\n\tnext_comm\030\005 \001(\t\022\020\n\010next_pid\030\006 \001(\005\022"
    "\021\n\tnext_prio\030\007 \001(\005\"f\n\026SchedWakeupFtraceE"
    "vent\022\014\n\004comm\030\001 \001(\t\022\013\n\003pid\030\002 \001(\005\022\014\n\004prio\030"
    "\003 \001(\005\022\017\n\007success\030\004 \001(\005\022\022\n\ntarget_cpu\030\005 \001"
    "(\005\"M\n\035SchedBlockedReasonFtraceEvent\022\013\n\003p"
    "id\030\001 \001(\005\022\016\n\006caller\030\002 \001(\004\022\017\n\007io_wait\030\003 \001("
    "\r\"Q\n\032SchedCpuHotplugFtraceEvent\022\024\n\014affec"
    "ted_cpu\030\001 \001(\005\022\r\n\005error\030\002 \001(\005\022\016\n\006status\030\003"
    " \001(\005\"f\n\026SchedWakingFtraceEvent\022\014\n\004comm\030\001"
    " \001(\t\022\013\n\003pid\030\002 \001(\005\022\014\n\004prio\030\003 \001(\005\022\017\n\007succe"
    "ss\030\004 \001(\005\022\022\n\ntarget_cpu\030\005 \001(\005\"i\n\031SchedWak"
    "eupNewFtraceEvent\022\014\n\004comm\030\001 \001(\t\022\013\n\003pid\030\002"
    " \001(\005\022\014\n\004prio\030\003 \001(\005\022\017\n\007success\030\004 \001(\005\022\022\n\nt"
    "arget_cpu\030\005 \001(\005\"M\n\033SchedProcessExecFtrac"
    "eEvent\022\020\n\010filename\030\001 \001(\t\022\013\n\003pid\030\002 \001(\005\022\017\n"
    "\007old_pid\030\003 \001(\005\"T\n\033SchedProcessExitFtrace"
    "Event\022\014\n\004comm\030\001 \001(\t\022\013\n\003pid\030\002 \001(\005\022\014\n\004tgid"
    "\030\003 \001(\005\022\014\n\004prio\030\004 \001(\005\"m\n\033SchedProcessFork"
    "FtraceEvent\022\023\n\013parent_comm\030\001 \001(\t\022\022\n\npare"
    "nt_pid\030\002 \001(\005\022\022\n\nchild_comm\030\003 \001(\t\022\021\n\tchil"
    "d_pid\030\004 \001(\005\"F\n\033SchedProcessFreeFtraceEve"
    "nt\022\014\n\004comm\030\001 \001(\t\022\013\n\003pid\030\002 \001(\005\022\014\n\004prio\030\003 "
    "\001(\005\"8\n\033SchedProcessHangFtraceEvent\022\014\n\004co"
    "mm\030\001 \001(\t\022\013\n\003pid\030\002 \001(\005\"F\n\033SchedProcessWai"
    "tFtraceEvent\022\014\n\004comm\030\001 \001(\t\022\013\n\003pid\030\002 \001(\005\022"
    "\014\n\004prio\030\003 \001(\005\"X\n\031SchedPiSetprioFtraceEve"
    "nt\022\014\n\004comm\030\001 \001(\t\022\017\n\007newprio\030\002 \001(\005\022\017\n\007old"
    "prio\030\003 \001(\005\022\013\n\003pid\030\004 \001(\005\"\310\002\n\032SchedCpuUtil"
    "CfsFtraceEvent\022\016\n\006active\030\001 \001(\005\022\020\n\010capaci"
    "ty\030\002 \001(\004\022\025\n\rcapacity_orig\030\003 \001(\004\022\013\n\003cpu\030\004"
    " \001(\r\022\026\n\016cpu_importance\030\005 \001(\004\022\020\n\010cpu_util"
    "\030\006 \001(\004\022\020\n\010exit_lat\030\007 \001(\r\022\026\n\016group_capaci"
    "ty\030\010 \001(\004\022\030\n\020grp_overutilized\030\t \001(\r\022\020\n\010id"
    "le_cpu\030\n \001(\r\022\022\n\nnr_running\030\013 \001(\r\022\021\n\tspar"
    "e_cap\030\014 \001(\003\022\021\n\ttask_fits\030\r \001(\r\022\027\n\017wake_g"
    "roup_util\030\016 \001(\004\022\021\n\twake_util\030\017 \001(\004"
};
static ::absl::once_flag descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto = {
    false,
    false,
    1594,
    descriptor_table_protodef_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto,
    "protos/perfetto/trace/ftrace/sched.proto",
    &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
    nullptr,
    0,
    14,
    schemas,
    file_default_instances,
    TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto::offsets,
    file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto,
    file_level_enum_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto,
    file_level_service_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter() {
  return &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto(&descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto);
namespace perfetto {
namespace protos {
// ===================================================================

class SchedSwitchFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedSwitchFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedSwitchFtraceEvent, _impl_._has_bits_);
  static void set_has_prev_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prev_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prev_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_prev_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_next_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_next_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_next_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedSwitchFtraceEvent)
}
SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedSwitchFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prev_comm_) {}

    , decltype(_impl_.next_comm_) {}

    , decltype(_impl_.prev_pid_) {}

    , decltype(_impl_.prev_prio_) {}

    , decltype(_impl_.prev_state_) {}

    , decltype(_impl_.next_pid_) {}

    , decltype(_impl_.next_prio_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.prev_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prev_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.prev_comm_.Set(from._internal_prev_comm(), _this->GetArenaForAllocation());
  }
  _impl_.next_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.next_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.next_comm_.Set(from._internal_next_comm(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.prev_pid_, &from._impl_.prev_pid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.next_prio_) -
    reinterpret_cast<char*>(&_impl_.prev_pid_)) + sizeof(_impl_.next_prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedSwitchFtraceEvent)
}

inline void SchedSwitchFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prev_comm_) {}

    , decltype(_impl_.next_comm_) {}

    , decltype(_impl_.prev_pid_) { 0 }

    , decltype(_impl_.prev_prio_) { 0 }

    , decltype(_impl_.prev_state_) { ::int64_t{0} }

    , decltype(_impl_.next_pid_) { 0 }

    , decltype(_impl_.next_prio_) { 0 }

  };
  _impl_.prev_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prev_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.next_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.next_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedSwitchFtraceEvent::~SchedSwitchFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedSwitchFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedSwitchFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prev_comm_.Destroy();
  _impl_.next_comm_.Destroy();
}

void SchedSwitchFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedSwitchFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedSwitchFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.prev_comm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.next_comm_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.prev_pid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.next_prio_) -
        reinterpret_cast<char*>(&_impl_.prev_pid_)) + sizeof(_impl_.next_prio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedSwitchFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string prev_comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_prev_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedSwitchFtraceEvent.prev_comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 prev_pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_prev_pid(&has_bits);
          _impl_.prev_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 prev_prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_prev_prio(&has_bits);
          _impl_.prev_prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 prev_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_prev_state(&has_bits);
          _impl_.prev_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string next_comm = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_next_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedSwitchFtraceEvent.next_comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 next_pid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_next_pid(&has_bits);
          _impl_.next_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 next_prio = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_next_prio(&has_bits);
          _impl_.next_prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedSwitchFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedSwitchFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string prev_comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_prev_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedSwitchFtraceEvent.prev_comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 prev_pid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_prev_pid(), target);
  }

  // optional int32 prev_prio = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_prev_prio(), target);
  }

  // optional int64 prev_state = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_prev_state(), target);
  }

  // optional string next_comm = 5;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_next_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedSwitchFtraceEvent.next_comm");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional int32 next_pid = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_next_pid(), target);
  }

  // optional int32 next_prio = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_next_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedSwitchFtraceEvent)
  return target;
}

::size_t SchedSwitchFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedSwitchFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string prev_comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_prev_comm());
    }

    // optional string next_comm = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_next_comm());
    }

    // optional int32 prev_pid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_prev_pid());
    }

    // optional int32 prev_prio = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_prev_prio());
    }

    // optional int64 prev_state = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_prev_state());
    }

    // optional int32 next_pid = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_next_pid());
    }

    // optional int32 next_prio = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_next_prio());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedSwitchFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedSwitchFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedSwitchFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedSwitchFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedSwitchFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedSwitchFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedSwitchFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_prev_comm(from._internal_prev_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_next_comm(from._internal_next_comm());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prev_pid_ = from._impl_.prev_pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.prev_prio_ = from._impl_.prev_prio_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.prev_state_ = from._impl_.prev_state_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.next_pid_ = from._impl_.next_pid_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.next_prio_ = from._impl_.next_prio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedSwitchFtraceEvent::CopyFrom(const SchedSwitchFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedSwitchFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedSwitchFtraceEvent::IsInitialized() const {
  return true;
}

void SchedSwitchFtraceEvent::InternalSwap(SchedSwitchFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prev_comm_, lhs_arena,
                                       &other->_impl_.prev_comm_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.next_comm_, lhs_arena,
                                       &other->_impl_.next_comm_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedSwitchFtraceEvent, _impl_.next_prio_)
      + sizeof(SchedSwitchFtraceEvent::_impl_.next_prio_)
      - PROTOBUF_FIELD_OFFSET(SchedSwitchFtraceEvent, _impl_.prev_pid_)>(
          reinterpret_cast<char*>(&_impl_.prev_pid_),
          reinterpret_cast<char*>(&other->_impl_.prev_pid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedSwitchFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[0]);
}
// ===================================================================

class SchedWakeupFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakeupFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedWakeupFtraceEvent, _impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedWakeupFtraceEvent)
}
SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedWakeupFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) {}

    , decltype(_impl_.prio_) {}

    , decltype(_impl_.success_) {}

    , decltype(_impl_.target_cpu_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.comm_.Set(from._internal_comm(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.target_cpu_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakeupFtraceEvent)
}

inline void SchedWakeupFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) { 0 }

    , decltype(_impl_.prio_) { 0 }

    , decltype(_impl_.success_) { 0 }

    , decltype(_impl_.target_cpu_) { 0 }

  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedWakeupFtraceEvent::~SchedWakeupFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakeupFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedWakeupFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedWakeupFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedWakeupFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakeupFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.pid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.target_cpu_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedWakeupFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedWakeupFtraceEvent.comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          _impl_.target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedWakeupFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedWakeupFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedWakeupFtraceEvent.comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_prio(), target);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_success(), target);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_target_cpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedWakeupFtraceEvent)
  return target;
}

::size_t SchedWakeupFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakeupFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_target_cpu());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedWakeupFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedWakeupFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedWakeupFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedWakeupFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedWakeupFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedWakeupFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakeupFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.success_ = from._impl_.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.target_cpu_ = from._impl_.target_cpu_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedWakeupFtraceEvent::CopyFrom(const SchedWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakeupFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakeupFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakeupFtraceEvent::InternalSwap(SchedWakeupFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comm_, lhs_arena,
                                       &other->_impl_.comm_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedWakeupFtraceEvent, _impl_.target_cpu_)
      + sizeof(SchedWakeupFtraceEvent::_impl_.target_cpu_)
      - PROTOBUF_FIELD_OFFSET(SchedWakeupFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedWakeupFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[1]);
}
// ===================================================================

class SchedBlockedReasonFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedBlockedReasonFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedBlockedReasonFtraceEvent, _impl_._has_bits_);
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_caller(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_io_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
}
SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
}

inline void SchedBlockedReasonFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caller_) { ::uint64_t{0u} }

    , decltype(_impl_.pid_) { 0 }

    , decltype(_impl_.io_wait_) { 0u }

  };
}

SchedBlockedReasonFtraceEvent::~SchedBlockedReasonFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedBlockedReasonFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SchedBlockedReasonFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedBlockedReasonFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.caller_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.io_wait_) -
        reinterpret_cast<char*>(&_impl_.caller_)) + sizeof(_impl_.io_wait_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedBlockedReasonFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 caller = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_caller(&has_bits);
          _impl_.caller_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 io_wait = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_io_wait(&has_bits);
          _impl_.io_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedBlockedReasonFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 pid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_pid(), target);
  }

  // optional uint64 caller = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_caller(), target);
  }

  // optional uint32 io_wait = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_io_wait(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedBlockedReasonFtraceEvent)
  return target;
}

::size_t SchedBlockedReasonFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 caller = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_caller());
    }

    // optional int32 pid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

    // optional uint32 io_wait = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_io_wait());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedBlockedReasonFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedBlockedReasonFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedBlockedReasonFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedBlockedReasonFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedBlockedReasonFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedBlockedReasonFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.caller_ = from._impl_.caller_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.io_wait_ = from._impl_.io_wait_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedBlockedReasonFtraceEvent::CopyFrom(const SchedBlockedReasonFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedBlockedReasonFtraceEvent::IsInitialized() const {
  return true;
}

void SchedBlockedReasonFtraceEvent::InternalSwap(SchedBlockedReasonFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedBlockedReasonFtraceEvent, _impl_.io_wait_)
      + sizeof(SchedBlockedReasonFtraceEvent::_impl_.io_wait_)
      - PROTOBUF_FIELD_OFFSET(SchedBlockedReasonFtraceEvent, _impl_.caller_)>(
          reinterpret_cast<char*>(&_impl_.caller_),
          reinterpret_cast<char*>(&other->_impl_.caller_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedBlockedReasonFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[2]);
}
// ===================================================================

class SchedCpuHotplugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedCpuHotplugFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedCpuHotplugFtraceEvent, _impl_._has_bits_);
  static void set_has_affected_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
}
SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
}

inline void SchedCpuHotplugFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.affected_cpu_) { 0 }

    , decltype(_impl_.error_) { 0 }

    , decltype(_impl_.status_) { 0 }

  };
}

SchedCpuHotplugFtraceEvent::~SchedCpuHotplugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedCpuHotplugFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SchedCpuHotplugFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedCpuHotplugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.affected_cpu_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.status_) -
        reinterpret_cast<char*>(&_impl_.affected_cpu_)) + sizeof(_impl_.status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedCpuHotplugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 affected_cpu = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_affected_cpu(&has_bits);
          _impl_.affected_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          _impl_.error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedCpuHotplugFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 affected_cpu = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_affected_cpu(), target);
  }

  // optional int32 error = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_error(), target);
  }

  // optional int32 status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedCpuHotplugFtraceEvent)
  return target;
}

::size_t SchedCpuHotplugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 affected_cpu = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_affected_cpu());
    }

    // optional int32 error = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_error());
    }

    // optional int32 status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedCpuHotplugFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedCpuHotplugFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedCpuHotplugFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedCpuHotplugFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedCpuHotplugFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedCpuHotplugFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.affected_cpu_ = from._impl_.affected_cpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedCpuHotplugFtraceEvent::CopyFrom(const SchedCpuHotplugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedCpuHotplugFtraceEvent::IsInitialized() const {
  return true;
}

void SchedCpuHotplugFtraceEvent::InternalSwap(SchedCpuHotplugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedCpuHotplugFtraceEvent, _impl_.status_)
      + sizeof(SchedCpuHotplugFtraceEvent::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(SchedCpuHotplugFtraceEvent, _impl_.affected_cpu_)>(
          reinterpret_cast<char*>(&_impl_.affected_cpu_),
          reinterpret_cast<char*>(&other->_impl_.affected_cpu_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedCpuHotplugFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[3]);
}
// ===================================================================

class SchedWakingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakingFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedWakingFtraceEvent, _impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakingFtraceEvent::SchedWakingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedWakingFtraceEvent)
}
SchedWakingFtraceEvent::SchedWakingFtraceEvent(const SchedWakingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedWakingFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) {}

    , decltype(_impl_.prio_) {}

    , decltype(_impl_.success_) {}

    , decltype(_impl_.target_cpu_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.comm_.Set(from._internal_comm(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.target_cpu_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakingFtraceEvent)
}

inline void SchedWakingFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) { 0 }

    , decltype(_impl_.prio_) { 0 }

    , decltype(_impl_.success_) { 0 }

    , decltype(_impl_.target_cpu_) { 0 }

  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedWakingFtraceEvent::~SchedWakingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakingFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedWakingFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedWakingFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedWakingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakingFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.pid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.target_cpu_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedWakingFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedWakingFtraceEvent.comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          _impl_.target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedWakingFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedWakingFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedWakingFtraceEvent.comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_prio(), target);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_success(), target);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_target_cpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedWakingFtraceEvent)
  return target;
}

::size_t SchedWakingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakingFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_target_cpu());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedWakingFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedWakingFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedWakingFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedWakingFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedWakingFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedWakingFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakingFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.success_ = from._impl_.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.target_cpu_ = from._impl_.target_cpu_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedWakingFtraceEvent::CopyFrom(const SchedWakingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakingFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakingFtraceEvent::InternalSwap(SchedWakingFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comm_, lhs_arena,
                                       &other->_impl_.comm_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedWakingFtraceEvent, _impl_.target_cpu_)
      + sizeof(SchedWakingFtraceEvent::_impl_.target_cpu_)
      - PROTOBUF_FIELD_OFFSET(SchedWakingFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedWakingFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[4]);
}
// ===================================================================

class SchedWakeupNewFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakeupNewFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedWakeupNewFtraceEvent, _impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedWakeupNewFtraceEvent)
}
SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedWakeupNewFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) {}

    , decltype(_impl_.prio_) {}

    , decltype(_impl_.success_) {}

    , decltype(_impl_.target_cpu_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.comm_.Set(from._internal_comm(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.target_cpu_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakeupNewFtraceEvent)
}

inline void SchedWakeupNewFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) { 0 }

    , decltype(_impl_.prio_) { 0 }

    , decltype(_impl_.success_) { 0 }

    , decltype(_impl_.target_cpu_) { 0 }

  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedWakeupNewFtraceEvent::~SchedWakeupNewFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakeupNewFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedWakeupNewFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedWakeupNewFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedWakeupNewFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.pid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.target_cpu_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedWakeupNewFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedWakeupNewFtraceEvent.comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          _impl_.target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedWakeupNewFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedWakeupNewFtraceEvent.comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_prio(), target);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_success(), target);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_target_cpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedWakeupNewFtraceEvent)
  return target;
}

::size_t SchedWakeupNewFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_target_cpu());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedWakeupNewFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedWakeupNewFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedWakeupNewFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedWakeupNewFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedWakeupNewFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedWakeupNewFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.success_ = from._impl_.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.target_cpu_ = from._impl_.target_cpu_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedWakeupNewFtraceEvent::CopyFrom(const SchedWakeupNewFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakeupNewFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakeupNewFtraceEvent::InternalSwap(SchedWakeupNewFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comm_, lhs_arena,
                                       &other->_impl_.comm_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedWakeupNewFtraceEvent, _impl_.target_cpu_)
      + sizeof(SchedWakeupNewFtraceEvent::_impl_.target_cpu_)
      - PROTOBUF_FIELD_OFFSET(SchedWakeupNewFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedWakeupNewFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[5]);
}
// ===================================================================

class SchedProcessExecFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessExecFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedProcessExecFtraceEvent, _impl_._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_old_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessExecFtraceEvent)
}
SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedProcessExecFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_) {}

    , decltype(_impl_.pid_) {}

    , decltype(_impl_.old_pid_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.filename_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.filename_.Set(from._internal_filename(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.old_pid_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.old_pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessExecFtraceEvent)
}

inline void SchedProcessExecFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_) {}

    , decltype(_impl_.pid_) { 0 }

    , decltype(_impl_.old_pid_) { 0 }

  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.filename_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessExecFtraceEvent::~SchedProcessExecFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessExecFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessExecFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
}

void SchedProcessExecFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessExecFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessExecFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.filename_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.pid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.old_pid_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.old_pid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedProcessExecFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedProcessExecFtraceEvent.filename");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 old_pid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_old_pid(&has_bits);
          _impl_.old_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedProcessExecFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessExecFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_filename();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedProcessExecFtraceEvent.filename");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_pid(), target);
  }

  // optional int32 old_pid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_old_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessExecFtraceEvent)
  return target;
}

::size_t SchedProcessExecFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessExecFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string filename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_filename());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

    // optional int32 old_pid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_old_pid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedProcessExecFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedProcessExecFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedProcessExecFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedProcessExecFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedProcessExecFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedProcessExecFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessExecFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.old_pid_ = from._impl_.old_pid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedProcessExecFtraceEvent::CopyFrom(const SchedProcessExecFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessExecFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessExecFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessExecFtraceEvent::InternalSwap(SchedProcessExecFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.filename_, lhs_arena,
                                       &other->_impl_.filename_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessExecFtraceEvent, _impl_.old_pid_)
      + sizeof(SchedProcessExecFtraceEvent::_impl_.old_pid_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessExecFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedProcessExecFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[6]);
}
// ===================================================================

class SchedProcessExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedProcessExitFtraceEvent, _impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tgid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessExitFtraceEvent)
}
SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedProcessExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) {}

    , decltype(_impl_.tgid_) {}

    , decltype(_impl_.prio_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.comm_.Set(from._internal_comm(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.prio_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessExitFtraceEvent)
}

inline void SchedProcessExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) { 0 }

    , decltype(_impl_.tgid_) { 0 }

    , decltype(_impl_.prio_) { 0 }

  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessExitFtraceEvent::~SchedProcessExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedProcessExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.pid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.prio_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedProcessExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedProcessExitFtraceEvent.comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 tgid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_tgid(&has_bits);
          _impl_.tgid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 prio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedProcessExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedProcessExitFtraceEvent.comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_pid(), target);
  }

  // optional int32 tgid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_tgid(), target);
  }

  // optional int32 prio = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessExitFtraceEvent)
  return target;
}

::size_t SchedProcessExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

    // optional int32 tgid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_tgid());
    }

    // optional int32 prio = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_prio());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedProcessExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedProcessExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedProcessExitFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedProcessExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedProcessExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedProcessExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tgid_ = from._impl_.tgid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedProcessExitFtraceEvent::CopyFrom(const SchedProcessExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessExitFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessExitFtraceEvent::InternalSwap(SchedProcessExitFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comm_, lhs_arena,
                                       &other->_impl_.comm_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessExitFtraceEvent, _impl_.prio_)
      + sizeof(SchedProcessExitFtraceEvent::_impl_.prio_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessExitFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedProcessExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[7]);
}
// ===================================================================

class SchedProcessForkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessForkFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedProcessForkFtraceEvent, _impl_._has_bits_);
  static void set_has_parent_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_child_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_child_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessForkFtraceEvent)
}
SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedProcessForkFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_comm_) {}

    , decltype(_impl_.child_comm_) {}

    , decltype(_impl_.parent_pid_) {}

    , decltype(_impl_.child_pid_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.parent_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.parent_comm_.Set(from._internal_parent_comm(), _this->GetArenaForAllocation());
  }
  _impl_.child_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.child_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.child_comm_.Set(from._internal_child_comm(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.parent_pid_, &from._impl_.parent_pid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.child_pid_) -
    reinterpret_cast<char*>(&_impl_.parent_pid_)) + sizeof(_impl_.child_pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessForkFtraceEvent)
}

inline void SchedProcessForkFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_comm_) {}

    , decltype(_impl_.child_comm_) {}

    , decltype(_impl_.parent_pid_) { 0 }

    , decltype(_impl_.child_pid_) { 0 }

  };
  _impl_.parent_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.parent_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.child_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.child_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessForkFtraceEvent::~SchedProcessForkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessForkFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessForkFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_comm_.Destroy();
  _impl_.child_comm_.Destroy();
}

void SchedProcessForkFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessForkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessForkFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.parent_comm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.child_comm_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.parent_pid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.child_pid_) -
        reinterpret_cast<char*>(&_impl_.parent_pid_)) + sizeof(_impl_.child_pid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedProcessForkFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string parent_comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedProcessForkFtraceEvent.parent_comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 parent_pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_parent_pid(&has_bits);
          _impl_.parent_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string child_comm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_child_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedProcessForkFtraceEvent.child_comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 child_pid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_child_pid(&has_bits);
          _impl_.child_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedProcessForkFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessForkFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string parent_comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_parent_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedProcessForkFtraceEvent.parent_comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 parent_pid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_parent_pid(), target);
  }

  // optional string child_comm = 3;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_child_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedProcessForkFtraceEvent.child_comm");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional int32 child_pid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_child_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessForkFtraceEvent)
  return target;
}

::size_t SchedProcessForkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessForkFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string parent_comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_parent_comm());
    }

    // optional string child_comm = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_child_comm());
    }

    // optional int32 parent_pid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_parent_pid());
    }

    // optional int32 child_pid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_child_pid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedProcessForkFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedProcessForkFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedProcessForkFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedProcessForkFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedProcessForkFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedProcessForkFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessForkFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_parent_comm(from._internal_parent_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_child_comm(from._internal_child_comm());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.parent_pid_ = from._impl_.parent_pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.child_pid_ = from._impl_.child_pid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedProcessForkFtraceEvent::CopyFrom(const SchedProcessForkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessForkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessForkFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessForkFtraceEvent::InternalSwap(SchedProcessForkFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.parent_comm_, lhs_arena,
                                       &other->_impl_.parent_comm_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.child_comm_, lhs_arena,
                                       &other->_impl_.child_comm_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessForkFtraceEvent, _impl_.child_pid_)
      + sizeof(SchedProcessForkFtraceEvent::_impl_.child_pid_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessForkFtraceEvent, _impl_.parent_pid_)>(
          reinterpret_cast<char*>(&_impl_.parent_pid_),
          reinterpret_cast<char*>(&other->_impl_.parent_pid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedProcessForkFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[8]);
}
// ===================================================================

class SchedProcessFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessFreeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedProcessFreeFtraceEvent, _impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessFreeFtraceEvent)
}
SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedProcessFreeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) {}

    , decltype(_impl_.prio_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.comm_.Set(from._internal_comm(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.prio_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessFreeFtraceEvent)
}

inline void SchedProcessFreeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) { 0 }

    , decltype(_impl_.prio_) { 0 }

  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessFreeFtraceEvent::~SchedProcessFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessFreeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedProcessFreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.pid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.prio_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedProcessFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedProcessFreeFtraceEvent.comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedProcessFreeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedProcessFreeFtraceEvent.comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessFreeFtraceEvent)
  return target;
}

::size_t SchedProcessFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_prio());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedProcessFreeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedProcessFreeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedProcessFreeFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedProcessFreeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedProcessFreeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedProcessFreeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedProcessFreeFtraceEvent::CopyFrom(const SchedProcessFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessFreeFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessFreeFtraceEvent::InternalSwap(SchedProcessFreeFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comm_, lhs_arena,
                                       &other->_impl_.comm_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessFreeFtraceEvent, _impl_.prio_)
      + sizeof(SchedProcessFreeFtraceEvent::_impl_.prio_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessFreeFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedProcessFreeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[9]);
}
// ===================================================================

class SchedProcessHangFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessHangFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedProcessHangFtraceEvent, _impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessHangFtraceEvent)
}
SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedProcessHangFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.comm_.Set(from._internal_comm(), _this->GetArenaForAllocation());
  }
  _this->_impl_.pid_ = from._impl_.pid_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessHangFtraceEvent)
}

inline void SchedProcessHangFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) { 0 }

  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessHangFtraceEvent::~SchedProcessHangFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessHangFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessHangFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedProcessHangFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessHangFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessHangFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  _impl_.pid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedProcessHangFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedProcessHangFtraceEvent.comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedProcessHangFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessHangFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedProcessHangFtraceEvent.comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessHangFtraceEvent)
  return target;
}

::size_t SchedProcessHangFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessHangFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedProcessHangFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedProcessHangFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedProcessHangFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedProcessHangFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedProcessHangFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedProcessHangFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessHangFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedProcessHangFtraceEvent::CopyFrom(const SchedProcessHangFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessHangFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessHangFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessHangFtraceEvent::InternalSwap(SchedProcessHangFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comm_, lhs_arena,
                                       &other->_impl_.comm_, rhs_arena);

  swap(_impl_.pid_, other->_impl_.pid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedProcessHangFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[10]);
}
// ===================================================================

class SchedProcessWaitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessWaitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedProcessWaitFtraceEvent, _impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessWaitFtraceEvent)
}
SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedProcessWaitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) {}

    , decltype(_impl_.prio_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.comm_.Set(from._internal_comm(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.prio_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessWaitFtraceEvent)
}

inline void SchedProcessWaitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.pid_) { 0 }

    , decltype(_impl_.prio_) { 0 }

  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessWaitFtraceEvent::~SchedProcessWaitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessWaitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessWaitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedProcessWaitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessWaitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.pid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.prio_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedProcessWaitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedProcessWaitFtraceEvent.comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedProcessWaitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedProcessWaitFtraceEvent.comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessWaitFtraceEvent)
  return target;
}

::size_t SchedProcessWaitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_prio());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedProcessWaitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedProcessWaitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedProcessWaitFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedProcessWaitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedProcessWaitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedProcessWaitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedProcessWaitFtraceEvent::CopyFrom(const SchedProcessWaitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessWaitFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessWaitFtraceEvent::InternalSwap(SchedProcessWaitFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comm_, lhs_arena,
                                       &other->_impl_.comm_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessWaitFtraceEvent, _impl_.prio_)
      + sizeof(SchedProcessWaitFtraceEvent::_impl_.prio_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessWaitFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedProcessWaitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[11]);
}
// ===================================================================

class SchedPiSetprioFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedPiSetprioFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedPiSetprioFtraceEvent, _impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newprio(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_oldprio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedPiSetprioFtraceEvent)
}
SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(const SchedPiSetprioFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SchedPiSetprioFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.newprio_) {}

    , decltype(_impl_.oldprio_) {}

    , decltype(_impl_.pid_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.comm_.Set(from._internal_comm(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.newprio_, &from._impl_.newprio_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.pid_) -
    reinterpret_cast<char*>(&_impl_.newprio_)) + sizeof(_impl_.pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedPiSetprioFtraceEvent)
}

inline void SchedPiSetprioFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_) {}

    , decltype(_impl_.newprio_) { 0 }

    , decltype(_impl_.oldprio_) { 0 }

    , decltype(_impl_.pid_) { 0 }

  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedPiSetprioFtraceEvent::~SchedPiSetprioFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedPiSetprioFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedPiSetprioFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedPiSetprioFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedPiSetprioFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.newprio_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pid_) -
        reinterpret_cast<char*>(&_impl_.newprio_)) + sizeof(_impl_.pid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedPiSetprioFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.SchedPiSetprioFtraceEvent.comm");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 newprio = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_newprio(&has_bits);
          _impl_.newprio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 oldprio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_oldprio(&has_bits);
          _impl_.oldprio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedPiSetprioFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_comm();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.SchedPiSetprioFtraceEvent.comm");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 newprio = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_newprio(), target);
  }

  // optional int32 oldprio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_oldprio(), target);
  }

  // optional int32 pid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedPiSetprioFtraceEvent)
  return target;
}

::size_t SchedPiSetprioFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_comm());
    }

    // optional int32 newprio = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_newprio());
    }

    // optional int32 oldprio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_oldprio());
    }

    // optional int32 pid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedPiSetprioFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedPiSetprioFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedPiSetprioFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedPiSetprioFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedPiSetprioFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedPiSetprioFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.newprio_ = from._impl_.newprio_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.oldprio_ = from._impl_.oldprio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedPiSetprioFtraceEvent::CopyFrom(const SchedPiSetprioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedPiSetprioFtraceEvent::IsInitialized() const {
  return true;
}

void SchedPiSetprioFtraceEvent::InternalSwap(SchedPiSetprioFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comm_, lhs_arena,
                                       &other->_impl_.comm_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedPiSetprioFtraceEvent, _impl_.pid_)
      + sizeof(SchedPiSetprioFtraceEvent::_impl_.pid_)
      - PROTOBUF_FIELD_OFFSET(SchedPiSetprioFtraceEvent, _impl_.newprio_)>(
          reinterpret_cast<char*>(&_impl_.newprio_),
          reinterpret_cast<char*>(&other->_impl_.newprio_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedPiSetprioFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[12]);
}
// ===================================================================

class SchedCpuUtilCfsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedCpuUtilCfsFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SchedCpuUtilCfsFtraceEvent, _impl_._has_bits_);
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_capacity_orig(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cpu_importance(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cpu_util(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_exit_lat(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_group_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_grp_overutilized(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_idle_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_nr_running(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_spare_cap(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_task_fits(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_wake_group_util(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_wake_util(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
}
SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(const SchedCpuUtilCfsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
}

inline void SchedCpuUtilCfsFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.capacity_) { ::uint64_t{0u} }

    , decltype(_impl_.active_) { 0 }

    , decltype(_impl_.cpu_) { 0u }

    , decltype(_impl_.capacity_orig_) { ::uint64_t{0u} }

    , decltype(_impl_.cpu_importance_) { ::uint64_t{0u} }

    , decltype(_impl_.cpu_util_) { ::uint64_t{0u} }

    , decltype(_impl_.group_capacity_) { ::uint64_t{0u} }

    , decltype(_impl_.exit_lat_) { 0u }

    , decltype(_impl_.grp_overutilized_) { 0u }

    , decltype(_impl_.idle_cpu_) { 0u }

    , decltype(_impl_.nr_running_) { 0u }

    , decltype(_impl_.spare_cap_) { ::int64_t{0} }

    , decltype(_impl_.wake_group_util_) { ::uint64_t{0u} }

    , decltype(_impl_.wake_util_) { ::uint64_t{0u} }

    , decltype(_impl_.task_fits_) { 0u }

  };
}

SchedCpuUtilCfsFtraceEvent::~SchedCpuUtilCfsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedCpuUtilCfsFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SchedCpuUtilCfsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedCpuUtilCfsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.capacity_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.exit_lat_) -
        reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.exit_lat_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.grp_overutilized_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.task_fits_) -
        reinterpret_cast<char*>(&_impl_.grp_overutilized_)) + sizeof(_impl_.task_fits_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SchedCpuUtilCfsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 capacity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_capacity(&has_bits);
          _impl_.capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 capacity_orig = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_capacity_orig(&has_bits);
          _impl_.capacity_orig_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 cpu = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_cpu(&has_bits);
          _impl_.cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 cpu_importance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_cpu_importance(&has_bits);
          _impl_.cpu_importance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 cpu_util = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_cpu_util(&has_bits);
          _impl_.cpu_util_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 exit_lat = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_exit_lat(&has_bits);
          _impl_.exit_lat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 group_capacity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_group_capacity(&has_bits);
          _impl_.group_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 grp_overutilized = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_grp_overutilized(&has_bits);
          _impl_.grp_overutilized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 idle_cpu = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_idle_cpu(&has_bits);
          _impl_.idle_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 nr_running = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_nr_running(&has_bits);
          _impl_.nr_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 spare_cap = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _Internal::set_has_spare_cap(&has_bits);
          _impl_.spare_cap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 task_fits = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _Internal::set_has_task_fits(&has_bits);
          _impl_.task_fits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 wake_group_util = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _Internal::set_has_wake_group_util(&has_bits);
          _impl_.wake_group_util_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 wake_util = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _Internal::set_has_wake_util(&has_bits);
          _impl_.wake_util_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SchedCpuUtilCfsFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 active = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_active(), target);
  }

  // optional uint64 capacity = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_capacity(), target);
  }

  // optional uint64 capacity_orig = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_capacity_orig(), target);
  }

  // optional uint32 cpu = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_cpu(), target);
  }

  // optional uint64 cpu_importance = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_cpu_importance(), target);
  }

  // optional uint64 cpu_util = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_cpu_util(), target);
  }

  // optional uint32 exit_lat = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_exit_lat(), target);
  }

  // optional uint64 group_capacity = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_group_capacity(), target);
  }

  // optional uint32 grp_overutilized = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_grp_overutilized(), target);
  }

  // optional uint32 idle_cpu = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        10, this->_internal_idle_cpu(), target);
  }

  // optional uint32 nr_running = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this->_internal_nr_running(), target);
  }

  // optional int64 spare_cap = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        12, this->_internal_spare_cap(), target);
  }

  // optional uint32 task_fits = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        13, this->_internal_task_fits(), target);
  }

  // optional uint64 wake_group_util = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        14, this->_internal_wake_group_util(), target);
  }

  // optional uint64 wake_util = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        15, this->_internal_wake_util(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  return target;
}

::size_t SchedCpuUtilCfsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 capacity = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_capacity());
    }

    // optional int32 active = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_active());
    }

    // optional uint32 cpu = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_cpu());
    }

    // optional uint64 capacity_orig = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_capacity_orig());
    }

    // optional uint64 cpu_importance = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_cpu_importance());
    }

    // optional uint64 cpu_util = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_cpu_util());
    }

    // optional uint64 group_capacity = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_group_capacity());
    }

    // optional uint32 exit_lat = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_exit_lat());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 grp_overutilized = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_grp_overutilized());
    }

    // optional uint32 idle_cpu = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_idle_cpu());
    }

    // optional uint32 nr_running = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_nr_running());
    }

    // optional int64 spare_cap = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_spare_cap());
    }

    // optional uint64 wake_group_util = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_wake_group_util());
    }

    // optional uint64 wake_util = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_wake_util());
    }

    // optional uint32 task_fits = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_task_fits());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SchedCpuUtilCfsFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SchedCpuUtilCfsFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SchedCpuUtilCfsFtraceEvent::GetClassData() const { return &_class_data_; }


void SchedCpuUtilCfsFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SchedCpuUtilCfsFtraceEvent*>(&to_msg);
  auto& from = static_cast<const SchedCpuUtilCfsFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.capacity_ = from._impl_.capacity_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cpu_ = from._impl_.cpu_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.capacity_orig_ = from._impl_.capacity_orig_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cpu_importance_ = from._impl_.cpu_importance_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.cpu_util_ = from._impl_.cpu_util_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.group_capacity_ = from._impl_.group_capacity_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.exit_lat_ = from._impl_.exit_lat_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.grp_overutilized_ = from._impl_.grp_overutilized_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.idle_cpu_ = from._impl_.idle_cpu_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.nr_running_ = from._impl_.nr_running_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.spare_cap_ = from._impl_.spare_cap_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.wake_group_util_ = from._impl_.wake_group_util_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.wake_util_ = from._impl_.wake_util_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.task_fits_ = from._impl_.task_fits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SchedCpuUtilCfsFtraceEvent::CopyFrom(const SchedCpuUtilCfsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedCpuUtilCfsFtraceEvent::IsInitialized() const {
  return true;
}

void SchedCpuUtilCfsFtraceEvent::InternalSwap(SchedCpuUtilCfsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedCpuUtilCfsFtraceEvent, _impl_.task_fits_)
      + sizeof(SchedCpuUtilCfsFtraceEvent::_impl_.task_fits_)
      - PROTOBUF_FIELD_OFFSET(SchedCpuUtilCfsFtraceEvent, _impl_.capacity_)>(
          reinterpret_cast<char*>(&_impl_.capacity_),
          reinterpret_cast<char*>(&other->_impl_.capacity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SchedCpuUtilCfsFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto[13]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedSwitchFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedSwitchFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedSwitchFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakeupFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakeupFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedWakeupFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedBlockedReasonFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedBlockedReasonFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedBlockedReasonFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedCpuHotplugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedCpuHotplugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedCpuHotplugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakingFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakingFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedWakingFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakeupNewFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakeupNewFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedWakeupNewFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessExecFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessExecFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessExecFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessForkFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessForkFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessForkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessHangFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessHangFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessHangFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessWaitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessWaitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessWaitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedPiSetprioFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedPiSetprioFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedPiSetprioFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedCpuUtilCfsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedCpuUtilCfsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedCpuUtilCfsFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
