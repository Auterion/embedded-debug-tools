// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/kvm.proto

#include "protos/perfetto/trace/ftrace/kvm.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace perfetto {
namespace protos {
template <typename>
PROTOBUF_CONSTEXPR KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ipa_)*/ ::uint64_t{0u}
} {}
struct KvmAccessFaultFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAccessFaultFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAccessFaultFtraceEventDefaultTypeInternal() {}
  union {
    KvmAccessFaultFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAccessFaultFtraceEventDefaultTypeInternal _KvmAccessFaultFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.irqchip_)*/ 0u

  , /*decltype(_impl_.pin_)*/ 0u
} {}
struct KvmAckIrqFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAckIrqFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAckIrqFtraceEventDefaultTypeInternal() {}
  union {
    KvmAckIrqFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAckIrqFtraceEventDefaultTypeInternal _KvmAckIrqFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.end_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.start_)*/ ::uint64_t{0u}
} {}
struct KvmAgeHvaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAgeHvaFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAgeHvaFtraceEventDefaultTypeInternal() {}
  union {
    KvmAgeHvaFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAgeHvaFtraceEventDefaultTypeInternal _KvmAgeHvaFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfn_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.hva_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.level_)*/ 0u

  , /*decltype(_impl_.referenced_)*/ 0u
} {}
struct KvmAgePageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAgePageFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAgePageFtraceEventDefaultTypeInternal() {}
  union {
    KvmAgePageFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAgePageFtraceEventDefaultTypeInternal _KvmAgePageFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.guest_debug_)*/ 0u
} {}
struct KvmArmClearDebugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmClearDebugFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmClearDebugFtraceEventDefaultTypeInternal() {}
  union {
    KvmArmClearDebugFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmClearDebugFtraceEventDefaultTypeInternal _KvmArmClearDebugFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.value_)*/ 0u
} {}
struct KvmArmSetDreg32FtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmSetDreg32FtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmSetDreg32FtraceEventDefaultTypeInternal() {}
  union {
    KvmArmSetDreg32FtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmSetDreg32FtraceEventDefaultTypeInternal _KvmArmSetDreg32FtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.len_)*/ 0
} {}
struct KvmArmSetRegsetFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmSetRegsetFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmSetRegsetFtraceEventDefaultTypeInternal() {}
  union {
    KvmArmSetRegsetFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmSetRegsetFtraceEventDefaultTypeInternal _KvmArmSetRegsetFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.guest_debug_)*/ 0u
} {}
struct KvmArmSetupDebugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmSetupDebugFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmSetupDebugFtraceEventDefaultTypeInternal() {}
  union {
    KvmArmSetupDebugFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmSetupDebugFtraceEventDefaultTypeInternal _KvmArmSetupDebugFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmEntryFtraceEvent::KvmEntryFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_pc_)*/ ::uint64_t{0u}
} {}
struct KvmEntryFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmEntryFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmEntryFtraceEventDefaultTypeInternal() {}
  union {
    KvmEntryFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmEntryFtraceEventDefaultTypeInternal _KvmEntryFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmExitFtraceEvent::KvmExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.esr_ec_)*/ 0u

  , /*decltype(_impl_.ret_)*/ 0

  , /*decltype(_impl_.vcpu_pc_)*/ ::uint64_t{0u}
} {}
struct KvmExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmExitFtraceEventDefaultTypeInternal() {}
  union {
    KvmExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmExitFtraceEventDefaultTypeInternal _KvmExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmFpuFtraceEvent::KvmFpuFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.load_)*/ 0u
} {}
struct KvmFpuFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmFpuFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmFpuFtraceEventDefaultTypeInternal() {}
  union {
    KvmFpuFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmFpuFtraceEventDefaultTypeInternal _KvmFpuFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.direct_ptimer_)*/ 0

  , /*decltype(_impl_.direct_vtimer_)*/ 0

  , /*decltype(_impl_.vcpu_id_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.emul_ptimer_)*/ 0
} {}
struct KvmGetTimerMapFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmGetTimerMapFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmGetTimerMapFtraceEventDefaultTypeInternal() {}
  union {
    KvmGetTimerMapFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmGetTimerMapFtraceEventDefaultTypeInternal _KvmGetTimerMapFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hsr_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.hxfar_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ipa_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.vcpu_pc_)*/ ::uint64_t{0u}
} {}
struct KvmGuestFaultFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmGuestFaultFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmGuestFaultFtraceEventDefaultTypeInternal() {}
  union {
    KvmGuestFaultFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmGuestFaultFtraceEventDefaultTypeInternal _KvmGuestFaultFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hsr_)*/ ::uint64_t{0u}
} {}
struct KvmHandleSysRegFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmHandleSysRegFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmHandleSysRegFtraceEventDefaultTypeInternal() {}
  union {
    KvmHandleSysRegFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmHandleSysRegFtraceEventDefaultTypeInternal _KvmHandleSysRegFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.imm_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.r0_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.vcpu_pc_)*/ ::uint64_t{0u}
} {}
struct KvmHvcArm64FtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmHvcArm64FtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmHvcArm64FtraceEventDefaultTypeInternal() {}
  union {
    KvmHvcArm64FtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmHvcArm64FtraceEventDefaultTypeInternal _KvmHvcArm64FtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.irq_num_)*/ 0

  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.type_)*/ 0u

  , /*decltype(_impl_.vcpu_idx_)*/ 0
} {}
struct KvmIrqLineFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmIrqLineFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmIrqLineFtraceEventDefaultTypeInternal() {}
  union {
    KvmIrqLineFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmIrqLineFtraceEventDefaultTypeInternal _KvmIrqLineFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmMmioFtraceEvent::KvmMmioFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gpa_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.type_)*/ 0u

  , /*decltype(_impl_.val_)*/ ::uint64_t{0u}
} {}
struct KvmMmioFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmMmioFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmMmioFtraceEventDefaultTypeInternal() {}
  union {
    KvmMmioFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmMmioFtraceEventDefaultTypeInternal _KvmMmioFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cpsr_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.instr_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.vcpu_pc_)*/ ::uint64_t{0u}
} {}
struct KvmMmioEmulateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmMmioEmulateFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmMmioEmulateFtraceEventDefaultTypeInternal() {}
  union {
    KvmMmioEmulateFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmMmioEmulateFtraceEventDefaultTypeInternal _KvmMmioEmulateFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.guest_debug_)*/ 0u
} {}
struct KvmSetGuestDebugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetGuestDebugFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetGuestDebugFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetGuestDebugFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetGuestDebugFtraceEventDefaultTypeInternal _KvmSetGuestDebugFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gsi_)*/ 0u

  , /*decltype(_impl_.irq_source_id_)*/ 0

  , /*decltype(_impl_.level_)*/ 0
} {}
struct KvmSetIrqFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetIrqFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetIrqFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetIrqFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetIrqFtraceEventDefaultTypeInternal _KvmSetIrqFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hva_)*/ ::uint64_t{0u}
} {}
struct KvmSetSpteHvaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetSpteHvaFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetSpteHvaFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetSpteHvaFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetSpteHvaFtraceEventDefaultTypeInternal _KvmSetSpteHvaFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_pc_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.cache_)*/ 0u
} {}
struct KvmSetWayFlushFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetWayFlushFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetWayFlushFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetWayFlushFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetWayFlushFtraceEventDefaultTypeInternal _KvmSetWayFlushFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.crm_)*/ 0u

  , /*decltype(_impl_.crn_)*/ 0u

  , /*decltype(_impl_.op0_)*/ 0u

  , /*decltype(_impl_.op1_)*/ 0u

  , /*decltype(_impl_.op2_)*/ 0u

  , /*decltype(_impl_.is_write_)*/ 0u

  , /*decltype(_impl_.vcpu_pc_)*/ ::uint64_t{0u}
} {}
struct KvmSysAccessFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSysAccessFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSysAccessFtraceEventDefaultTypeInternal() {}
  union {
    KvmSysAccessFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSysAccessFtraceEventDefaultTypeInternal _KvmSysAccessFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hva_)*/ ::uint64_t{0u}
} {}
struct KvmTestAgeHvaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTestAgeHvaFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTestAgeHvaFtraceEventDefaultTypeInternal() {}
  union {
    KvmTestAgeHvaFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTestAgeHvaFtraceEventDefaultTypeInternal _KvmTestAgeHvaFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.should_fire_)*/ 0u

  , /*decltype(_impl_.timer_idx_)*/ 0
} {}
struct KvmTimerEmulateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerEmulateFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerEmulateFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerEmulateFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerEmulateFtraceEventDefaultTypeInternal _KvmTimerEmulateFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timer_idx_)*/ 0
} {}
struct KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerHrtimerExpireFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal _KvmTimerHrtimerExpireFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.cval_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.timer_idx_)*/ 0
} {}
struct KvmTimerRestoreStateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerRestoreStateFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerRestoreStateFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerRestoreStateFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerRestoreStateFtraceEventDefaultTypeInternal _KvmTimerRestoreStateFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.cval_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.timer_idx_)*/ 0
} {}
struct KvmTimerSaveStateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerSaveStateFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerSaveStateFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerSaveStateFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerSaveStateFtraceEventDefaultTypeInternal _KvmTimerSaveStateFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.irq_)*/ 0u

  , /*decltype(_impl_.level_)*/ 0

  , /*decltype(_impl_.vcpu_id_)*/ ::uint64_t{0u}
} {}
struct KvmTimerUpdateIrqFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerUpdateIrqFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerUpdateIrqFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerUpdateIrqFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerUpdateIrqFtraceEventDefaultTypeInternal _KvmTimerUpdateIrqFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_pc_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.now_)*/ 0u

  , /*decltype(_impl_.was_)*/ 0u
} {}
struct KvmToggleCacheFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmToggleCacheFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmToggleCacheFtraceEventDefaultTypeInternal() {}
  union {
    KvmToggleCacheFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmToggleCacheFtraceEventDefaultTypeInternal _KvmToggleCacheFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.end_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.start_)*/ ::uint64_t{0u}
} {}
struct KvmUnmapHvaRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmUnmapHvaRangeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmUnmapHvaRangeFtraceEventDefaultTypeInternal() {}
  union {
    KvmUnmapHvaRangeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmUnmapHvaRangeFtraceEventDefaultTypeInternal _KvmUnmapHvaRangeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reason_)*/ 0u
} {}
struct KvmUserspaceExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmUserspaceExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmUserspaceExitFtraceEventDefaultTypeInternal() {}
  union {
    KvmUserspaceExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmUserspaceExitFtraceEventDefaultTypeInternal _KvmUserspaceExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ns_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.valid_)*/ 0u

  , /*decltype(_impl_.waited_)*/ 0u
} {}
struct KvmVcpuWakeupFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmVcpuWakeupFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmVcpuWakeupFtraceEventDefaultTypeInternal() {}
  union {
    KvmVcpuWakeupFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmVcpuWakeupFtraceEventDefaultTypeInternal _KvmVcpuWakeupFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_pc_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.is_wfe_)*/ 0u
} {}
struct KvmWfxArm64FtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmWfxArm64FtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmWfxArm64FtraceEventDefaultTypeInternal() {}
  union {
    KvmWfxArm64FtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmWfxArm64FtraceEventDefaultTypeInternal _KvmWfxArm64FtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TrapRegFtraceEvent::TrapRegFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fn_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.is_write_)*/ 0u

  , /*decltype(_impl_.reg_)*/ 0

  , /*decltype(_impl_.write_value_)*/ ::uint64_t{0u}
} {}
struct TrapRegFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrapRegFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrapRegFtraceEventDefaultTypeInternal() {}
  union {
    TrapRegFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrapRegFtraceEventDefaultTypeInternal _TrapRegFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.irq_)*/ 0u

  , /*decltype(_impl_.level_)*/ 0u

  , /*decltype(_impl_.vcpu_id_)*/ ::uint64_t{0u}
} {}
struct VgicUpdateIrqPendingFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VgicUpdateIrqPendingFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VgicUpdateIrqPendingFtraceEventDefaultTypeInternal() {}
  union {
    VgicUpdateIrqPendingFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VgicUpdateIrqPendingFtraceEventDefaultTypeInternal _VgicUpdateIrqPendingFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
static ::_pb::Metadata file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[36];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto = nullptr;
const ::uint32_t TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAccessFaultFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAccessFaultFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAccessFaultFtraceEvent, _impl_.ipa_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAckIrqFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAckIrqFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAckIrqFtraceEvent, _impl_.irqchip_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAckIrqFtraceEvent, _impl_.pin_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgeHvaFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgeHvaFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgeHvaFtraceEvent, _impl_.end_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgeHvaFtraceEvent, _impl_.start_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgePageFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgePageFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgePageFtraceEvent, _impl_.gfn_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgePageFtraceEvent, _impl_.hva_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgePageFtraceEvent, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmAgePageFtraceEvent, _impl_.referenced_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmClearDebugFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmClearDebugFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmClearDebugFtraceEvent, _impl_.guest_debug_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetDreg32FtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetDreg32FtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetDreg32FtraceEvent, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetDreg32FtraceEvent, _impl_.value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetRegsetFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetRegsetFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetRegsetFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetRegsetFtraceEvent, _impl_.name_),
    1,
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetupDebugFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetupDebugFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetupDebugFtraceEvent, _impl_.guest_debug_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmArmSetupDebugFtraceEvent, _impl_.vcpu_),
    1,
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmEntryFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmEntryFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmEntryFtraceEvent, _impl_.vcpu_pc_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmExitFtraceEvent, _impl_.esr_ec_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmExitFtraceEvent, _impl_.ret_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmExitFtraceEvent, _impl_.vcpu_pc_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmFpuFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmFpuFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmFpuFtraceEvent, _impl_.load_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGetTimerMapFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGetTimerMapFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGetTimerMapFtraceEvent, _impl_.direct_ptimer_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGetTimerMapFtraceEvent, _impl_.direct_vtimer_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGetTimerMapFtraceEvent, _impl_.emul_ptimer_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGetTimerMapFtraceEvent, _impl_.vcpu_id_),
    0,
    1,
    3,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGuestFaultFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGuestFaultFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGuestFaultFtraceEvent, _impl_.hsr_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGuestFaultFtraceEvent, _impl_.hxfar_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGuestFaultFtraceEvent, _impl_.ipa_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmGuestFaultFtraceEvent, _impl_.vcpu_pc_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmHandleSysRegFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmHandleSysRegFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmHandleSysRegFtraceEvent, _impl_.hsr_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmHvcArm64FtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmHvcArm64FtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmHvcArm64FtraceEvent, _impl_.imm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmHvcArm64FtraceEvent, _impl_.r0_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmHvcArm64FtraceEvent, _impl_.vcpu_pc_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmIrqLineFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmIrqLineFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmIrqLineFtraceEvent, _impl_.irq_num_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmIrqLineFtraceEvent, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmIrqLineFtraceEvent, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmIrqLineFtraceEvent, _impl_.vcpu_idx_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioFtraceEvent, _impl_.gpa_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioFtraceEvent, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioFtraceEvent, _impl_.val_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioEmulateFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioEmulateFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioEmulateFtraceEvent, _impl_.cpsr_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioEmulateFtraceEvent, _impl_.instr_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmMmioEmulateFtraceEvent, _impl_.vcpu_pc_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetGuestDebugFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetGuestDebugFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetGuestDebugFtraceEvent, _impl_.guest_debug_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetGuestDebugFtraceEvent, _impl_.vcpu_),
    1,
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetIrqFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetIrqFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetIrqFtraceEvent, _impl_.gsi_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetIrqFtraceEvent, _impl_.irq_source_id_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetIrqFtraceEvent, _impl_.level_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetSpteHvaFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetSpteHvaFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetSpteHvaFtraceEvent, _impl_.hva_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetWayFlushFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetWayFlushFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetWayFlushFtraceEvent, _impl_.cache_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSetWayFlushFtraceEvent, _impl_.vcpu_pc_),
    1,
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _impl_.crm_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _impl_.crn_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _impl_.op0_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _impl_.op1_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _impl_.op2_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _impl_.is_write_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmSysAccessFtraceEvent, _impl_.vcpu_pc_),
    1,
    2,
    3,
    4,
    5,
    6,
    0,
    7,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTestAgeHvaFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTestAgeHvaFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTestAgeHvaFtraceEvent, _impl_.hva_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerEmulateFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerEmulateFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerEmulateFtraceEvent, _impl_.should_fire_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerEmulateFtraceEvent, _impl_.timer_idx_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent, _impl_.timer_idx_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerRestoreStateFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerRestoreStateFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerRestoreStateFtraceEvent, _impl_.ctl_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerRestoreStateFtraceEvent, _impl_.cval_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerRestoreStateFtraceEvent, _impl_.timer_idx_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerSaveStateFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerSaveStateFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerSaveStateFtraceEvent, _impl_.ctl_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerSaveStateFtraceEvent, _impl_.cval_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerSaveStateFtraceEvent, _impl_.timer_idx_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerUpdateIrqFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerUpdateIrqFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerUpdateIrqFtraceEvent, _impl_.irq_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerUpdateIrqFtraceEvent, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmTimerUpdateIrqFtraceEvent, _impl_.vcpu_id_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmToggleCacheFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmToggleCacheFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmToggleCacheFtraceEvent, _impl_.now_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmToggleCacheFtraceEvent, _impl_.vcpu_pc_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmToggleCacheFtraceEvent, _impl_.was_),
    1,
    0,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmUnmapHvaRangeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmUnmapHvaRangeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmUnmapHvaRangeFtraceEvent, _impl_.end_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmUnmapHvaRangeFtraceEvent, _impl_.start_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmUserspaceExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmUserspaceExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmUserspaceExitFtraceEvent, _impl_.reason_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmVcpuWakeupFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmVcpuWakeupFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmVcpuWakeupFtraceEvent, _impl_.ns_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmVcpuWakeupFtraceEvent, _impl_.valid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmVcpuWakeupFtraceEvent, _impl_.waited_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmWfxArm64FtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmWfxArm64FtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmWfxArm64FtraceEvent, _impl_.is_wfe_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KvmWfxArm64FtraceEvent, _impl_.vcpu_pc_),
    1,
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::TrapRegFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::TrapRegFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::TrapRegFtraceEvent, _impl_.fn_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::TrapRegFtraceEvent, _impl_.is_write_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::TrapRegFtraceEvent, _impl_.reg_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::TrapRegFtraceEvent, _impl_.write_value_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::VgicUpdateIrqPendingFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::VgicUpdateIrqPendingFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::VgicUpdateIrqPendingFtraceEvent, _impl_.irq_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::VgicUpdateIrqPendingFtraceEvent, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::VgicUpdateIrqPendingFtraceEvent, _impl_.vcpu_id_),
    0,
    1,
    2,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 9, -1, sizeof(::perfetto::protos::KvmAccessFaultFtraceEvent)},
        { 10, 20, -1, sizeof(::perfetto::protos::KvmAckIrqFtraceEvent)},
        { 22, 32, -1, sizeof(::perfetto::protos::KvmAgeHvaFtraceEvent)},
        { 34, 46, -1, sizeof(::perfetto::protos::KvmAgePageFtraceEvent)},
        { 50, 59, -1, sizeof(::perfetto::protos::KvmArmClearDebugFtraceEvent)},
        { 60, 70, -1, sizeof(::perfetto::protos::KvmArmSetDreg32FtraceEvent)},
        { 72, 82, -1, sizeof(::perfetto::protos::KvmArmSetRegsetFtraceEvent)},
        { 84, 94, -1, sizeof(::perfetto::protos::KvmArmSetupDebugFtraceEvent)},
        { 96, 105, -1, sizeof(::perfetto::protos::KvmEntryFtraceEvent)},
        { 106, 117, -1, sizeof(::perfetto::protos::KvmExitFtraceEvent)},
        { 120, 129, -1, sizeof(::perfetto::protos::KvmFpuFtraceEvent)},
        { 130, 142, -1, sizeof(::perfetto::protos::KvmGetTimerMapFtraceEvent)},
        { 146, 158, -1, sizeof(::perfetto::protos::KvmGuestFaultFtraceEvent)},
        { 162, 171, -1, sizeof(::perfetto::protos::KvmHandleSysRegFtraceEvent)},
        { 172, 183, -1, sizeof(::perfetto::protos::KvmHvcArm64FtraceEvent)},
        { 186, 198, -1, sizeof(::perfetto::protos::KvmIrqLineFtraceEvent)},
        { 202, 214, -1, sizeof(::perfetto::protos::KvmMmioFtraceEvent)},
        { 218, 229, -1, sizeof(::perfetto::protos::KvmMmioEmulateFtraceEvent)},
        { 232, 242, -1, sizeof(::perfetto::protos::KvmSetGuestDebugFtraceEvent)},
        { 244, 255, -1, sizeof(::perfetto::protos::KvmSetIrqFtraceEvent)},
        { 258, 267, -1, sizeof(::perfetto::protos::KvmSetSpteHvaFtraceEvent)},
        { 268, 278, -1, sizeof(::perfetto::protos::KvmSetWayFlushFtraceEvent)},
        { 280, 296, -1, sizeof(::perfetto::protos::KvmSysAccessFtraceEvent)},
        { 304, 313, -1, sizeof(::perfetto::protos::KvmTestAgeHvaFtraceEvent)},
        { 314, 324, -1, sizeof(::perfetto::protos::KvmTimerEmulateFtraceEvent)},
        { 326, 335, -1, sizeof(::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent)},
        { 336, 347, -1, sizeof(::perfetto::protos::KvmTimerRestoreStateFtraceEvent)},
        { 350, 361, -1, sizeof(::perfetto::protos::KvmTimerSaveStateFtraceEvent)},
        { 364, 375, -1, sizeof(::perfetto::protos::KvmTimerUpdateIrqFtraceEvent)},
        { 378, 389, -1, sizeof(::perfetto::protos::KvmToggleCacheFtraceEvent)},
        { 392, 402, -1, sizeof(::perfetto::protos::KvmUnmapHvaRangeFtraceEvent)},
        { 404, 413, -1, sizeof(::perfetto::protos::KvmUserspaceExitFtraceEvent)},
        { 414, 425, -1, sizeof(::perfetto::protos::KvmVcpuWakeupFtraceEvent)},
        { 428, 438, -1, sizeof(::perfetto::protos::KvmWfxArm64FtraceEvent)},
        { 440, 452, -1, sizeof(::perfetto::protos::TrapRegFtraceEvent)},
        { 456, 467, -1, sizeof(::perfetto::protos::VgicUpdateIrqPendingFtraceEvent)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::perfetto::protos::_KvmAccessFaultFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmAckIrqFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmAgeHvaFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmAgePageFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmArmClearDebugFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmArmSetDreg32FtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmArmSetRegsetFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmArmSetupDebugFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmEntryFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmFpuFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmGetTimerMapFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmGuestFaultFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmHandleSysRegFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmHvcArm64FtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmIrqLineFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmMmioFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmMmioEmulateFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmSetGuestDebugFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmSetIrqFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmSetSpteHvaFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmSetWayFlushFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmSysAccessFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmTestAgeHvaFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmTimerEmulateFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmTimerHrtimerExpireFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmTimerRestoreStateFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmTimerSaveStateFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmTimerUpdateIrqFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmToggleCacheFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmUnmapHvaRangeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmUserspaceExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmVcpuWakeupFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KvmWfxArm64FtraceEvent_default_instance_._instance,
    &::perfetto::protos::_TrapRegFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_VgicUpdateIrqPendingFtraceEvent_default_instance_._instance,
};
const char descriptor_table_protodef_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n&protos/perfetto/trace/ftrace/kvm.proto"
    "\022\017perfetto.protos\"(\n\031KvmAccessFaultFtrac"
    "eEvent\022\013\n\003ipa\030\001 \001(\004\"4\n\024KvmAckIrqFtraceEv"
    "ent\022\017\n\007irqchip\030\001 \001(\r\022\013\n\003pin\030\002 \001(\r\"2\n\024Kvm"
    "AgeHvaFtraceEvent\022\013\n\003end\030\001 \001(\004\022\r\n\005start\030"
    "\002 \001(\004\"T\n\025KvmAgePageFtraceEvent\022\013\n\003gfn\030\001 "
    "\001(\004\022\013\n\003hva\030\002 \001(\004\022\r\n\005level\030\003 \001(\r\022\022\n\nrefer"
    "enced\030\004 \001(\r\"2\n\033KvmArmClearDebugFtraceEve"
    "nt\022\023\n\013guest_debug\030\001 \001(\r\"9\n\032KvmArmSetDreg"
    "32FtraceEvent\022\014\n\004name\030\001 \001(\t\022\r\n\005value\030\002 \001"
    "(\r\"7\n\032KvmArmSetRegsetFtraceEvent\022\013\n\003len\030"
    "\001 \001(\005\022\014\n\004name\030\002 \001(\t\"@\n\033KvmArmSetupDebugF"
    "traceEvent\022\023\n\013guest_debug\030\001 \001(\r\022\014\n\004vcpu\030"
    "\002 \001(\004\"&\n\023KvmEntryFtraceEvent\022\017\n\007vcpu_pc\030"
    "\001 \001(\004\"B\n\022KvmExitFtraceEvent\022\016\n\006esr_ec\030\001 "
    "\001(\r\022\013\n\003ret\030\002 \001(\005\022\017\n\007vcpu_pc\030\003 \001(\004\"!\n\021Kvm"
    "FpuFtraceEvent\022\014\n\004load\030\001 \001(\r\"o\n\031KvmGetTi"
    "merMapFtraceEvent\022\025\n\rdirect_ptimer\030\001 \001(\005"
    "\022\025\n\rdirect_vtimer\030\002 \001(\005\022\023\n\013emul_ptimer\030\003"
    " \001(\005\022\017\n\007vcpu_id\030\004 \001(\004\"T\n\030KvmGuestFaultFt"
    "raceEvent\022\013\n\003hsr\030\001 \001(\004\022\r\n\005hxfar\030\002 \001(\004\022\013\n"
    "\003ipa\030\003 \001(\004\022\017\n\007vcpu_pc\030\004 \001(\004\")\n\032KvmHandle"
    "SysRegFtraceEvent\022\013\n\003hsr\030\001 \001(\004\"B\n\026KvmHvc"
    "Arm64FtraceEvent\022\013\n\003imm\030\001 \001(\004\022\n\n\002r0\030\002 \001("
    "\004\022\017\n\007vcpu_pc\030\003 \001(\004\"W\n\025KvmIrqLineFtraceEv"
    "ent\022\017\n\007irq_num\030\001 \001(\005\022\r\n\005level\030\002 \001(\005\022\014\n\004t"
    "ype\030\003 \001(\r\022\020\n\010vcpu_idx\030\004 \001(\005\"I\n\022KvmMmioFt"
    "raceEvent\022\013\n\003gpa\030\001 \001(\004\022\013\n\003len\030\002 \001(\r\022\014\n\004t"
    "ype\030\003 \001(\r\022\013\n\003val\030\004 \001(\004\"I\n\031KvmMmioEmulate"
    "FtraceEvent\022\014\n\004cpsr\030\001 \001(\004\022\r\n\005instr\030\002 \001(\004"
    "\022\017\n\007vcpu_pc\030\003 \001(\004\"@\n\033KvmSetGuestDebugFtr"
    "aceEvent\022\023\n\013guest_debug\030\001 \001(\r\022\014\n\004vcpu\030\002 "
    "\001(\004\"I\n\024KvmSetIrqFtraceEvent\022\013\n\003gsi\030\001 \001(\r"
    "\022\025\n\rirq_source_id\030\002 \001(\005\022\r\n\005level\030\003 \001(\005\"\'"
    "\n\030KvmSetSpteHvaFtraceEvent\022\013\n\003hva\030\001 \001(\004\""
    ";\n\031KvmSetWayFlushFtraceEvent\022\r\n\005cache\030\001 "
    "\001(\r\022\017\n\007vcpu_pc\030\002 \001(\004\"\213\001\n\027KvmSysAccessFtr"
    "aceEvent\022\013\n\003CRm\030\001 \001(\r\022\013\n\003CRn\030\002 \001(\r\022\013\n\003Op"
    "0\030\003 \001(\r\022\013\n\003Op1\030\004 \001(\r\022\013\n\003Op2\030\005 \001(\r\022\020\n\010is_"
    "write\030\006 \001(\r\022\014\n\004name\030\007 \001(\t\022\017\n\007vcpu_pc\030\010 \001"
    "(\004\"\'\n\030KvmTestAgeHvaFtraceEvent\022\013\n\003hva\030\001 "
    "\001(\004\"D\n\032KvmTimerEmulateFtraceEvent\022\023\n\013sho"
    "uld_fire\030\001 \001(\r\022\021\n\ttimer_idx\030\002 \001(\005\"5\n Kvm"
    "TimerHrtimerExpireFtraceEvent\022\021\n\ttimer_i"
    "dx\030\001 \001(\005\"O\n\037KvmTimerRestoreStateFtraceEv"
    "ent\022\013\n\003ctl\030\001 \001(\004\022\014\n\004cval\030\002 \001(\004\022\021\n\ttimer_"
    "idx\030\003 \001(\005\"L\n\034KvmTimerSaveStateFtraceEven"
    "t\022\013\n\003ctl\030\001 \001(\004\022\014\n\004cval\030\002 \001(\004\022\021\n\ttimer_id"
    "x\030\003 \001(\005\"K\n\034KvmTimerUpdateIrqFtraceEvent\022"
    "\013\n\003irq\030\001 \001(\r\022\r\n\005level\030\002 \001(\005\022\017\n\007vcpu_id\030\003"
    " \001(\004\"F\n\031KvmToggleCacheFtraceEvent\022\013\n\003now"
    "\030\001 \001(\r\022\017\n\007vcpu_pc\030\002 \001(\004\022\013\n\003was\030\003 \001(\r\"9\n\033"
    "KvmUnmapHvaRangeFtraceEvent\022\013\n\003end\030\001 \001(\004"
    "\022\r\n\005start\030\002 \001(\004\"-\n\033KvmUserspaceExitFtrac"
    "eEvent\022\016\n\006reason\030\001 \001(\r\"E\n\030KvmVcpuWakeupF"
    "traceEvent\022\n\n\002ns\030\001 \001(\004\022\r\n\005valid\030\002 \001(\r\022\016\n"
    "\006waited\030\003 \001(\r\"9\n\026KvmWfxArm64FtraceEvent\022"
    "\016\n\006is_wfe\030\001 \001(\r\022\017\n\007vcpu_pc\030\002 \001(\004\"T\n\022Trap"
    "RegFtraceEvent\022\n\n\002fn\030\001 \001(\t\022\020\n\010is_write\030\002"
    " \001(\r\022\013\n\003reg\030\003 \001(\005\022\023\n\013write_value\030\004 \001(\004\"N"
    "\n\037VgicUpdateIrqPendingFtraceEvent\022\013\n\003irq"
    "\030\001 \001(\r\022\r\n\005level\030\002 \001(\r\022\017\n\007vcpu_id\030\003 \001(\004"
};
static ::absl::once_flag descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto = {
    false,
    false,
    2478,
    descriptor_table_protodef_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto,
    "protos/perfetto/trace/ftrace/kvm.proto",
    &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
    nullptr,
    0,
    36,
    schemas,
    file_default_instances,
    TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto::offsets,
    file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto,
    file_level_enum_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto,
    file_level_service_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter() {
  return &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto(&descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto);
namespace perfetto {
namespace protos {
// ===================================================================

class KvmAccessFaultFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAccessFaultFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmAccessFaultFtraceEvent, _impl_._has_bits_);
  static void set_has_ipa(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAccessFaultFtraceEvent)
}
KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(const KvmAccessFaultFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAccessFaultFtraceEvent)
}

inline void KvmAccessFaultFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipa_) { ::uint64_t{0u} }

  };
}

KvmAccessFaultFtraceEvent::~KvmAccessFaultFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAccessFaultFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAccessFaultFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAccessFaultFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmAccessFaultFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ipa_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmAccessFaultFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ipa = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_ipa(&has_bits);
          _impl_.ipa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmAccessFaultFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ipa = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_ipa(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAccessFaultFtraceEvent)
  return target;
}

::size_t KvmAccessFaultFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 ipa = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_ipa());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmAccessFaultFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmAccessFaultFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmAccessFaultFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmAccessFaultFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmAccessFaultFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmAccessFaultFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_ipa(from._internal_ipa());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmAccessFaultFtraceEvent::CopyFrom(const KvmAccessFaultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAccessFaultFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAccessFaultFtraceEvent::InternalSwap(KvmAccessFaultFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.ipa_, other->_impl_.ipa_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmAccessFaultFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[0]);
}
// ===================================================================

class KvmAckIrqFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAckIrqFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmAckIrqFtraceEvent, _impl_._has_bits_);
  static void set_has_irqchip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAckIrqFtraceEvent)
}
KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(const KvmAckIrqFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAckIrqFtraceEvent)
}

inline void KvmAckIrqFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irqchip_) { 0u }

    , decltype(_impl_.pin_) { 0u }

  };
}

KvmAckIrqFtraceEvent::~KvmAckIrqFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAckIrqFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAckIrqFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAckIrqFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmAckIrqFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAckIrqFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.irqchip_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pin_) -
        reinterpret_cast<char*>(&_impl_.irqchip_)) + sizeof(_impl_.pin_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmAckIrqFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 irqchip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_irqchip(&has_bits);
          _impl_.irqchip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pin(&has_bits);
          _impl_.pin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmAckIrqFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAckIrqFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 irqchip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_irqchip(), target);
  }

  // optional uint32 pin = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_pin(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAckIrqFtraceEvent)
  return target;
}

::size_t KvmAckIrqFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAckIrqFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 irqchip = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_irqchip());
    }

    // optional uint32 pin = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pin());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmAckIrqFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmAckIrqFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmAckIrqFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmAckIrqFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmAckIrqFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmAckIrqFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAckIrqFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.irqchip_ = from._impl_.irqchip_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pin_ = from._impl_.pin_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmAckIrqFtraceEvent::CopyFrom(const KvmAckIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAckIrqFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAckIrqFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAckIrqFtraceEvent::InternalSwap(KvmAckIrqFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmAckIrqFtraceEvent, _impl_.pin_)
      + sizeof(KvmAckIrqFtraceEvent::_impl_.pin_)
      - PROTOBUF_FIELD_OFFSET(KvmAckIrqFtraceEvent, _impl_.irqchip_)>(
          reinterpret_cast<char*>(&_impl_.irqchip_),
          reinterpret_cast<char*>(&other->_impl_.irqchip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmAckIrqFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[1]);
}
// ===================================================================

class KvmAgeHvaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAgeHvaFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmAgeHvaFtraceEvent, _impl_._has_bits_);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAgeHvaFtraceEvent)
}
KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(const KvmAgeHvaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAgeHvaFtraceEvent)
}

inline void KvmAgeHvaFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.end_) { ::uint64_t{0u} }

    , decltype(_impl_.start_) { ::uint64_t{0u} }

  };
}

KvmAgeHvaFtraceEvent::~KvmAgeHvaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAgeHvaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAgeHvaFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAgeHvaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmAgeHvaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.end_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.start_) -
        reinterpret_cast<char*>(&_impl_.end_)) + sizeof(_impl_.start_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmAgeHvaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 end = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmAgeHvaFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 end = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_end(), target);
  }

  // optional uint64 start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAgeHvaFtraceEvent)
  return target;
}

::size_t KvmAgeHvaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 end = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_end());
    }

    // optional uint64 start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_start());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmAgeHvaFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmAgeHvaFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmAgeHvaFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmAgeHvaFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmAgeHvaFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmAgeHvaFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmAgeHvaFtraceEvent::CopyFrom(const KvmAgeHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAgeHvaFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAgeHvaFtraceEvent::InternalSwap(KvmAgeHvaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmAgeHvaFtraceEvent, _impl_.start_)
      + sizeof(KvmAgeHvaFtraceEvent::_impl_.start_)
      - PROTOBUF_FIELD_OFFSET(KvmAgeHvaFtraceEvent, _impl_.end_)>(
          reinterpret_cast<char*>(&_impl_.end_),
          reinterpret_cast<char*>(&other->_impl_.end_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmAgeHvaFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[2]);
}
// ===================================================================

class KvmAgePageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAgePageFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmAgePageFtraceEvent, _impl_._has_bits_);
  static void set_has_gfn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hva(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_referenced(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAgePageFtraceEvent)
}
KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(const KvmAgePageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAgePageFtraceEvent)
}

inline void KvmAgePageFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfn_) { ::uint64_t{0u} }

    , decltype(_impl_.hva_) { ::uint64_t{0u} }

    , decltype(_impl_.level_) { 0u }

    , decltype(_impl_.referenced_) { 0u }

  };
}

KvmAgePageFtraceEvent::~KvmAgePageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAgePageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAgePageFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAgePageFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmAgePageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAgePageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.gfn_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.referenced_) -
        reinterpret_cast<char*>(&_impl_.gfn_)) + sizeof(_impl_.referenced_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmAgePageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 gfn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gfn(&has_bits);
          _impl_.gfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 hva = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_hva(&has_bits);
          _impl_.hva_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 referenced = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_referenced(&has_bits);
          _impl_.referenced_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmAgePageFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAgePageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 gfn = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_gfn(), target);
  }

  // optional uint64 hva = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_hva(), target);
  }

  // optional uint32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_level(), target);
  }

  // optional uint32 referenced = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_referenced(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAgePageFtraceEvent)
  return target;
}

::size_t KvmAgePageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAgePageFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 gfn = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_gfn());
    }

    // optional uint64 hva = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_hva());
    }

    // optional uint32 level = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_level());
    }

    // optional uint32 referenced = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_referenced());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmAgePageFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmAgePageFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmAgePageFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmAgePageFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmAgePageFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmAgePageFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAgePageFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfn_ = from._impl_.gfn_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hva_ = from._impl_.hva_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.referenced_ = from._impl_.referenced_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmAgePageFtraceEvent::CopyFrom(const KvmAgePageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAgePageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAgePageFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAgePageFtraceEvent::InternalSwap(KvmAgePageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmAgePageFtraceEvent, _impl_.referenced_)
      + sizeof(KvmAgePageFtraceEvent::_impl_.referenced_)
      - PROTOBUF_FIELD_OFFSET(KvmAgePageFtraceEvent, _impl_.gfn_)>(
          reinterpret_cast<char*>(&_impl_.gfn_),
          reinterpret_cast<char*>(&other->_impl_.gfn_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmAgePageFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[3]);
}
// ===================================================================

class KvmArmClearDebugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmClearDebugFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmArmClearDebugFtraceEvent, _impl_._has_bits_);
  static void set_has_guest_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmClearDebugFtraceEvent)
}
KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(const KvmArmClearDebugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmClearDebugFtraceEvent)
}

inline void KvmArmClearDebugFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guest_debug_) { 0u }

  };
}

KvmArmClearDebugFtraceEvent::~KvmArmClearDebugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmClearDebugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmClearDebugFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmArmClearDebugFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmArmClearDebugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.guest_debug_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmArmClearDebugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 guest_debug = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_debug(&has_bits);
          _impl_.guest_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmArmClearDebugFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 guest_debug = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_guest_debug(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmClearDebugFtraceEvent)
  return target;
}

::size_t KvmArmClearDebugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 guest_debug = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_guest_debug());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmArmClearDebugFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmArmClearDebugFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmArmClearDebugFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmArmClearDebugFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmArmClearDebugFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmArmClearDebugFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_guest_debug(from._internal_guest_debug());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmArmClearDebugFtraceEvent::CopyFrom(const KvmArmClearDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmClearDebugFtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmClearDebugFtraceEvent::InternalSwap(KvmArmClearDebugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.guest_debug_, other->_impl_.guest_debug_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmArmClearDebugFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[4]);
}
// ===================================================================

class KvmArmSetDreg32FtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmSetDreg32FtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmArmSetDreg32FtraceEvent, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmSetDreg32FtraceEvent)
}
KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(const KvmArmSetDreg32FtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KvmArmSetDreg32FtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.value_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmSetDreg32FtraceEvent)
}

inline void KvmArmSetDreg32FtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.value_) { 0u }

  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KvmArmSetDreg32FtraceEvent::~KvmArmSetDreg32FtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmSetDreg32FtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void KvmArmSetDreg32FtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmArmSetDreg32FtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.value_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmArmSetDreg32FtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.KvmArmSetDreg32FtraceEvent.name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmArmSetDreg32FtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.KvmArmSetDreg32FtraceEvent.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional uint32 value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  return target;
}

::size_t KvmArmSetDreg32FtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
    }

    // optional uint32 value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmArmSetDreg32FtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmArmSetDreg32FtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmArmSetDreg32FtraceEvent::GetClassData() const { return &_class_data_; }


void KvmArmSetDreg32FtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmArmSetDreg32FtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmArmSetDreg32FtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmArmSetDreg32FtraceEvent::CopyFrom(const KvmArmSetDreg32FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmSetDreg32FtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmSetDreg32FtraceEvent::InternalSwap(KvmArmSetDreg32FtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);

  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmArmSetDreg32FtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[5]);
}
// ===================================================================

class KvmArmSetRegsetFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmSetRegsetFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmArmSetRegsetFtraceEvent, _impl_._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmSetRegsetFtraceEvent)
}
KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(const KvmArmSetRegsetFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KvmArmSetRegsetFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.len_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _this->_impl_.len_ = from._impl_.len_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmSetRegsetFtraceEvent)
}

inline void KvmArmSetRegsetFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.len_) { 0 }

  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KvmArmSetRegsetFtraceEvent::~KvmArmSetRegsetFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmSetRegsetFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void KvmArmSetRegsetFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmArmSetRegsetFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.len_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmArmSetRegsetFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.KvmArmSetRegsetFtraceEvent.name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmArmSetRegsetFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 len = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_len(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.KvmArmSetRegsetFtraceEvent.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  return target;
}

::size_t KvmArmSetRegsetFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
    }

    // optional int32 len = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmArmSetRegsetFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmArmSetRegsetFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmArmSetRegsetFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmArmSetRegsetFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmArmSetRegsetFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmArmSetRegsetFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmArmSetRegsetFtraceEvent::CopyFrom(const KvmArmSetRegsetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmSetRegsetFtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmSetRegsetFtraceEvent::InternalSwap(KvmArmSetRegsetFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);

  swap(_impl_.len_, other->_impl_.len_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmArmSetRegsetFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[6]);
}
// ===================================================================

class KvmArmSetupDebugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmSetupDebugFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmArmSetupDebugFtraceEvent, _impl_._has_bits_);
  static void set_has_guest_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmSetupDebugFtraceEvent)
}
KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(const KvmArmSetupDebugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmSetupDebugFtraceEvent)
}

inline void KvmArmSetupDebugFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_) { ::uint64_t{0u} }

    , decltype(_impl_.guest_debug_) { 0u }

  };
}

KvmArmSetupDebugFtraceEvent::~KvmArmSetupDebugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmSetupDebugFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmArmSetupDebugFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmArmSetupDebugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vcpu_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.guest_debug_) -
        reinterpret_cast<char*>(&_impl_.vcpu_)) + sizeof(_impl_.guest_debug_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmArmSetupDebugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 guest_debug = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_debug(&has_bits);
          _impl_.guest_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu(&has_bits);
          _impl_.vcpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmArmSetupDebugFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 guest_debug = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_guest_debug(), target);
  }

  // optional uint64 vcpu = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_vcpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  return target;
}

::size_t KvmArmSetupDebugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu());
    }

    // optional uint32 guest_debug = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_guest_debug());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmArmSetupDebugFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmArmSetupDebugFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmArmSetupDebugFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmArmSetupDebugFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmArmSetupDebugFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmArmSetupDebugFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_ = from._impl_.vcpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.guest_debug_ = from._impl_.guest_debug_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmArmSetupDebugFtraceEvent::CopyFrom(const KvmArmSetupDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmSetupDebugFtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmSetupDebugFtraceEvent::InternalSwap(KvmArmSetupDebugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmArmSetupDebugFtraceEvent, _impl_.guest_debug_)
      + sizeof(KvmArmSetupDebugFtraceEvent::_impl_.guest_debug_)
      - PROTOBUF_FIELD_OFFSET(KvmArmSetupDebugFtraceEvent, _impl_.vcpu_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmArmSetupDebugFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[7]);
}
// ===================================================================

class KvmEntryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmEntryFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmEntryFtraceEvent, _impl_._has_bits_);
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmEntryFtraceEvent::KvmEntryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmEntryFtraceEvent)
}
KvmEntryFtraceEvent::KvmEntryFtraceEvent(const KvmEntryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmEntryFtraceEvent)
}

inline void KvmEntryFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_) { ::uint64_t{0u} }

  };
}

KvmEntryFtraceEvent::~KvmEntryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmEntryFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmEntryFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmEntryFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmEntryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmEntryFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vcpu_pc_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmEntryFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 vcpu_pc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmEntryFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmEntryFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 vcpu_pc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmEntryFtraceEvent)
  return target;
}

::size_t KvmEntryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmEntryFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 vcpu_pc = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_vcpu_pc());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmEntryFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmEntryFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmEntryFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmEntryFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmEntryFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmEntryFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmEntryFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_vcpu_pc(from._internal_vcpu_pc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmEntryFtraceEvent::CopyFrom(const KvmEntryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmEntryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmEntryFtraceEvent::IsInitialized() const {
  return true;
}

void KvmEntryFtraceEvent::InternalSwap(KvmEntryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.vcpu_pc_, other->_impl_.vcpu_pc_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmEntryFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[8]);
}
// ===================================================================

class KvmExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmExitFtraceEvent, _impl_._has_bits_);
  static void set_has_esr_ec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmExitFtraceEvent::KvmExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmExitFtraceEvent)
}
KvmExitFtraceEvent::KvmExitFtraceEvent(const KvmExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmExitFtraceEvent)
}

inline void KvmExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.esr_ec_) { 0u }

    , decltype(_impl_.ret_) { 0 }

    , decltype(_impl_.vcpu_pc_) { ::uint64_t{0u} }

  };
}

KvmExitFtraceEvent::~KvmExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.esr_ec_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.esr_ec_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 esr_ec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_esr_ec(&has_bits);
          _impl_.esr_ec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_pc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 esr_ec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_esr_ec(), target);
  }

  // optional int32 ret = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_ret(), target);
  }

  // optional uint64 vcpu_pc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmExitFtraceEvent)
  return target;
}

::size_t KvmExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 esr_ec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_esr_ec());
    }

    // optional int32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

    // optional uint64 vcpu_pc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_pc());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmExitFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.esr_ec_ = from._impl_.esr_ec_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmExitFtraceEvent::CopyFrom(const KvmExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmExitFtraceEvent::IsInitialized() const {
  return true;
}

void KvmExitFtraceEvent::InternalSwap(KvmExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmExitFtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmExitFtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmExitFtraceEvent, _impl_.esr_ec_)>(
          reinterpret_cast<char*>(&_impl_.esr_ec_),
          reinterpret_cast<char*>(&other->_impl_.esr_ec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[9]);
}
// ===================================================================

class KvmFpuFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmFpuFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmFpuFtraceEvent, _impl_._has_bits_);
  static void set_has_load(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmFpuFtraceEvent::KvmFpuFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmFpuFtraceEvent)
}
KvmFpuFtraceEvent::KvmFpuFtraceEvent(const KvmFpuFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmFpuFtraceEvent)
}

inline void KvmFpuFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.load_) { 0u }

  };
}

KvmFpuFtraceEvent::~KvmFpuFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmFpuFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmFpuFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmFpuFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmFpuFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmFpuFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.load_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmFpuFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 load = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_load(&has_bits);
          _impl_.load_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmFpuFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmFpuFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 load = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_load(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmFpuFtraceEvent)
  return target;
}

::size_t KvmFpuFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmFpuFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 load = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_load());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmFpuFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmFpuFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmFpuFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmFpuFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmFpuFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmFpuFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmFpuFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_load(from._internal_load());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmFpuFtraceEvent::CopyFrom(const KvmFpuFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmFpuFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmFpuFtraceEvent::IsInitialized() const {
  return true;
}

void KvmFpuFtraceEvent::InternalSwap(KvmFpuFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.load_, other->_impl_.load_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmFpuFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[10]);
}
// ===================================================================

class KvmGetTimerMapFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmGetTimerMapFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmGetTimerMapFtraceEvent, _impl_._has_bits_);
  static void set_has_direct_ptimer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direct_vtimer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_emul_ptimer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vcpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmGetTimerMapFtraceEvent)
}
KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(const KvmGetTimerMapFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmGetTimerMapFtraceEvent)
}

inline void KvmGetTimerMapFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.direct_ptimer_) { 0 }

    , decltype(_impl_.direct_vtimer_) { 0 }

    , decltype(_impl_.vcpu_id_) { ::uint64_t{0u} }

    , decltype(_impl_.emul_ptimer_) { 0 }

  };
}

KvmGetTimerMapFtraceEvent::~KvmGetTimerMapFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmGetTimerMapFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmGetTimerMapFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmGetTimerMapFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmGetTimerMapFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.direct_ptimer_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.emul_ptimer_) -
        reinterpret_cast<char*>(&_impl_.direct_ptimer_)) + sizeof(_impl_.emul_ptimer_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmGetTimerMapFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 direct_ptimer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_direct_ptimer(&has_bits);
          _impl_.direct_ptimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 direct_vtimer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_direct_vtimer(&has_bits);
          _impl_.direct_vtimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 emul_ptimer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_emul_ptimer(&has_bits);
          _impl_.emul_ptimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_vcpu_id(&has_bits);
          _impl_.vcpu_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmGetTimerMapFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 direct_ptimer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_direct_ptimer(), target);
  }

  // optional int32 direct_vtimer = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_direct_vtimer(), target);
  }

  // optional int32 emul_ptimer = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_emul_ptimer(), target);
  }

  // optional uint64 vcpu_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_vcpu_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmGetTimerMapFtraceEvent)
  return target;
}

::size_t KvmGetTimerMapFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 direct_ptimer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_direct_ptimer());
    }

    // optional int32 direct_vtimer = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_direct_vtimer());
    }

    // optional uint64 vcpu_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_id());
    }

    // optional int32 emul_ptimer = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_emul_ptimer());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmGetTimerMapFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmGetTimerMapFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmGetTimerMapFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmGetTimerMapFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmGetTimerMapFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmGetTimerMapFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.direct_ptimer_ = from._impl_.direct_ptimer_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.direct_vtimer_ = from._impl_.direct_vtimer_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_id_ = from._impl_.vcpu_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.emul_ptimer_ = from._impl_.emul_ptimer_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmGetTimerMapFtraceEvent::CopyFrom(const KvmGetTimerMapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmGetTimerMapFtraceEvent::IsInitialized() const {
  return true;
}

void KvmGetTimerMapFtraceEvent::InternalSwap(KvmGetTimerMapFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmGetTimerMapFtraceEvent, _impl_.emul_ptimer_)
      + sizeof(KvmGetTimerMapFtraceEvent::_impl_.emul_ptimer_)
      - PROTOBUF_FIELD_OFFSET(KvmGetTimerMapFtraceEvent, _impl_.direct_ptimer_)>(
          reinterpret_cast<char*>(&_impl_.direct_ptimer_),
          reinterpret_cast<char*>(&other->_impl_.direct_ptimer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmGetTimerMapFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[11]);
}
// ===================================================================

class KvmGuestFaultFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmGuestFaultFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmGuestFaultFtraceEvent, _impl_._has_bits_);
  static void set_has_hsr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hxfar(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ipa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmGuestFaultFtraceEvent)
}
KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(const KvmGuestFaultFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmGuestFaultFtraceEvent)
}

inline void KvmGuestFaultFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hsr_) { ::uint64_t{0u} }

    , decltype(_impl_.hxfar_) { ::uint64_t{0u} }

    , decltype(_impl_.ipa_) { ::uint64_t{0u} }

    , decltype(_impl_.vcpu_pc_) { ::uint64_t{0u} }

  };
}

KvmGuestFaultFtraceEvent::~KvmGuestFaultFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmGuestFaultFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmGuestFaultFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmGuestFaultFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmGuestFaultFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.hsr_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.hsr_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmGuestFaultFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hsr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_hsr(&has_bits);
          _impl_.hsr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 hxfar = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_hxfar(&has_bits);
          _impl_.hxfar_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ipa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_ipa(&has_bits);
          _impl_.ipa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_pc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmGuestFaultFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 hsr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_hsr(), target);
  }

  // optional uint64 hxfar = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_hxfar(), target);
  }

  // optional uint64 ipa = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_ipa(), target);
  }

  // optional uint64 vcpu_pc = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmGuestFaultFtraceEvent)
  return target;
}

::size_t KvmGuestFaultFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 hsr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_hsr());
    }

    // optional uint64 hxfar = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_hxfar());
    }

    // optional uint64 ipa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ipa());
    }

    // optional uint64 vcpu_pc = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_pc());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmGuestFaultFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmGuestFaultFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmGuestFaultFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmGuestFaultFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmGuestFaultFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmGuestFaultFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hsr_ = from._impl_.hsr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hxfar_ = from._impl_.hxfar_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ipa_ = from._impl_.ipa_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmGuestFaultFtraceEvent::CopyFrom(const KvmGuestFaultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmGuestFaultFtraceEvent::IsInitialized() const {
  return true;
}

void KvmGuestFaultFtraceEvent::InternalSwap(KvmGuestFaultFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmGuestFaultFtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmGuestFaultFtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmGuestFaultFtraceEvent, _impl_.hsr_)>(
          reinterpret_cast<char*>(&_impl_.hsr_),
          reinterpret_cast<char*>(&other->_impl_.hsr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmGuestFaultFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[12]);
}
// ===================================================================

class KvmHandleSysRegFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmHandleSysRegFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmHandleSysRegFtraceEvent, _impl_._has_bits_);
  static void set_has_hsr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmHandleSysRegFtraceEvent)
}
KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(const KvmHandleSysRegFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmHandleSysRegFtraceEvent)
}

inline void KvmHandleSysRegFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hsr_) { ::uint64_t{0u} }

  };
}

KvmHandleSysRegFtraceEvent::~KvmHandleSysRegFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmHandleSysRegFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmHandleSysRegFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmHandleSysRegFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmHandleSysRegFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hsr_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmHandleSysRegFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hsr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_hsr(&has_bits);
          _impl_.hsr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmHandleSysRegFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 hsr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_hsr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmHandleSysRegFtraceEvent)
  return target;
}

::size_t KvmHandleSysRegFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 hsr = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_hsr());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmHandleSysRegFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmHandleSysRegFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmHandleSysRegFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmHandleSysRegFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmHandleSysRegFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmHandleSysRegFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_hsr(from._internal_hsr());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmHandleSysRegFtraceEvent::CopyFrom(const KvmHandleSysRegFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmHandleSysRegFtraceEvent::IsInitialized() const {
  return true;
}

void KvmHandleSysRegFtraceEvent::InternalSwap(KvmHandleSysRegFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.hsr_, other->_impl_.hsr_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmHandleSysRegFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[13]);
}
// ===================================================================

class KvmHvcArm64FtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmHvcArm64FtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmHvcArm64FtraceEvent, _impl_._has_bits_);
  static void set_has_imm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_r0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmHvcArm64FtraceEvent)
}
KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(const KvmHvcArm64FtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmHvcArm64FtraceEvent)
}

inline void KvmHvcArm64FtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.imm_) { ::uint64_t{0u} }

    , decltype(_impl_.r0_) { ::uint64_t{0u} }

    , decltype(_impl_.vcpu_pc_) { ::uint64_t{0u} }

  };
}

KvmHvcArm64FtraceEvent::~KvmHvcArm64FtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmHvcArm64FtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmHvcArm64FtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmHvcArm64FtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmHvcArm64FtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.imm_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.imm_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmHvcArm64FtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 imm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_imm(&has_bits);
          _impl_.imm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 r0 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_r0(&has_bits);
          _impl_.r0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_pc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmHvcArm64FtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 imm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_imm(), target);
  }

  // optional uint64 r0 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_r0(), target);
  }

  // optional uint64 vcpu_pc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmHvcArm64FtraceEvent)
  return target;
}

::size_t KvmHvcArm64FtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 imm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_imm());
    }

    // optional uint64 r0 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_r0());
    }

    // optional uint64 vcpu_pc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_pc());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmHvcArm64FtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmHvcArm64FtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmHvcArm64FtraceEvent::GetClassData() const { return &_class_data_; }


void KvmHvcArm64FtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmHvcArm64FtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmHvcArm64FtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.imm_ = from._impl_.imm_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.r0_ = from._impl_.r0_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmHvcArm64FtraceEvent::CopyFrom(const KvmHvcArm64FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmHvcArm64FtraceEvent::IsInitialized() const {
  return true;
}

void KvmHvcArm64FtraceEvent::InternalSwap(KvmHvcArm64FtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmHvcArm64FtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmHvcArm64FtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmHvcArm64FtraceEvent, _impl_.imm_)>(
          reinterpret_cast<char*>(&_impl_.imm_),
          reinterpret_cast<char*>(&other->_impl_.imm_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmHvcArm64FtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[14]);
}
// ===================================================================

class KvmIrqLineFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmIrqLineFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmIrqLineFtraceEvent, _impl_._has_bits_);
  static void set_has_irq_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vcpu_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmIrqLineFtraceEvent)
}
KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(const KvmIrqLineFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmIrqLineFtraceEvent)
}

inline void KvmIrqLineFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irq_num_) { 0 }

    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.type_) { 0u }

    , decltype(_impl_.vcpu_idx_) { 0 }

  };
}

KvmIrqLineFtraceEvent::~KvmIrqLineFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmIrqLineFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmIrqLineFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmIrqLineFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmIrqLineFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmIrqLineFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.irq_num_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_idx_) -
        reinterpret_cast<char*>(&_impl_.irq_num_)) + sizeof(_impl_.vcpu_idx_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmIrqLineFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 irq_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_irq_num(&has_bits);
          _impl_.irq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 vcpu_idx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_vcpu_idx(&has_bits);
          _impl_.vcpu_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmIrqLineFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmIrqLineFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 irq_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_irq_num(), target);
  }

  // optional int32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_level(), target);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_type(), target);
  }

  // optional int32 vcpu_idx = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_vcpu_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmIrqLineFtraceEvent)
  return target;
}

::size_t KvmIrqLineFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmIrqLineFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 irq_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_irq_num());
    }

    // optional int32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_level());
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_type());
    }

    // optional int32 vcpu_idx = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_vcpu_idx());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmIrqLineFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmIrqLineFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmIrqLineFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmIrqLineFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmIrqLineFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmIrqLineFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmIrqLineFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.irq_num_ = from._impl_.irq_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.vcpu_idx_ = from._impl_.vcpu_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmIrqLineFtraceEvent::CopyFrom(const KvmIrqLineFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmIrqLineFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmIrqLineFtraceEvent::IsInitialized() const {
  return true;
}

void KvmIrqLineFtraceEvent::InternalSwap(KvmIrqLineFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmIrqLineFtraceEvent, _impl_.vcpu_idx_)
      + sizeof(KvmIrqLineFtraceEvent::_impl_.vcpu_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmIrqLineFtraceEvent, _impl_.irq_num_)>(
          reinterpret_cast<char*>(&_impl_.irq_num_),
          reinterpret_cast<char*>(&other->_impl_.irq_num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmIrqLineFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[15]);
}
// ===================================================================

class KvmMmioFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmMmioFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmMmioFtraceEvent, _impl_._has_bits_);
  static void set_has_gpa(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_val(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmMmioFtraceEvent::KvmMmioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmMmioFtraceEvent)
}
KvmMmioFtraceEvent::KvmMmioFtraceEvent(const KvmMmioFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmMmioFtraceEvent)
}

inline void KvmMmioFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gpa_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.type_) { 0u }

    , decltype(_impl_.val_) { ::uint64_t{0u} }

  };
}

KvmMmioFtraceEvent::~KvmMmioFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmMmioFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmMmioFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmMmioFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmMmioFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmMmioFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.gpa_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.val_) -
        reinterpret_cast<char*>(&_impl_.gpa_)) + sizeof(_impl_.val_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmMmioFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 gpa = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gpa(&has_bits);
          _impl_.gpa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 val = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_val(&has_bits);
          _impl_.val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmMmioFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmMmioFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 gpa = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_gpa(), target);
  }

  // optional uint32 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_len(), target);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_type(), target);
  }

  // optional uint64 val = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmMmioFtraceEvent)
  return target;
}

::size_t KvmMmioFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmMmioFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 gpa = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_gpa());
    }

    // optional uint32 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_type());
    }

    // optional uint64 val = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_val());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmMmioFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmMmioFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmMmioFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmMmioFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmMmioFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmMmioFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmMmioFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gpa_ = from._impl_.gpa_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.val_ = from._impl_.val_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmMmioFtraceEvent::CopyFrom(const KvmMmioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmMmioFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmMmioFtraceEvent::IsInitialized() const {
  return true;
}

void KvmMmioFtraceEvent::InternalSwap(KvmMmioFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmMmioFtraceEvent, _impl_.val_)
      + sizeof(KvmMmioFtraceEvent::_impl_.val_)
      - PROTOBUF_FIELD_OFFSET(KvmMmioFtraceEvent, _impl_.gpa_)>(
          reinterpret_cast<char*>(&_impl_.gpa_),
          reinterpret_cast<char*>(&other->_impl_.gpa_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmMmioFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[16]);
}
// ===================================================================

class KvmMmioEmulateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmMmioEmulateFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmMmioEmulateFtraceEvent, _impl_._has_bits_);
  static void set_has_cpsr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_instr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmMmioEmulateFtraceEvent)
}
KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(const KvmMmioEmulateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmMmioEmulateFtraceEvent)
}

inline void KvmMmioEmulateFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cpsr_) { ::uint64_t{0u} }

    , decltype(_impl_.instr_) { ::uint64_t{0u} }

    , decltype(_impl_.vcpu_pc_) { ::uint64_t{0u} }

  };
}

KvmMmioEmulateFtraceEvent::~KvmMmioEmulateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmMmioEmulateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmMmioEmulateFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmMmioEmulateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmMmioEmulateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.cpsr_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.cpsr_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmMmioEmulateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 cpsr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_cpsr(&has_bits);
          _impl_.cpsr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 instr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_instr(&has_bits);
          _impl_.instr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_pc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmMmioEmulateFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 cpsr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_cpsr(), target);
  }

  // optional uint64 instr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_instr(), target);
  }

  // optional uint64 vcpu_pc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmMmioEmulateFtraceEvent)
  return target;
}

::size_t KvmMmioEmulateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 cpsr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_cpsr());
    }

    // optional uint64 instr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_instr());
    }

    // optional uint64 vcpu_pc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_pc());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmMmioEmulateFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmMmioEmulateFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmMmioEmulateFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmMmioEmulateFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmMmioEmulateFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmMmioEmulateFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.cpsr_ = from._impl_.cpsr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.instr_ = from._impl_.instr_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmMmioEmulateFtraceEvent::CopyFrom(const KvmMmioEmulateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmMmioEmulateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmMmioEmulateFtraceEvent::InternalSwap(KvmMmioEmulateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmMmioEmulateFtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmMmioEmulateFtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmMmioEmulateFtraceEvent, _impl_.cpsr_)>(
          reinterpret_cast<char*>(&_impl_.cpsr_),
          reinterpret_cast<char*>(&other->_impl_.cpsr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmMmioEmulateFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[17]);
}
// ===================================================================

class KvmSetGuestDebugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetGuestDebugFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmSetGuestDebugFtraceEvent, _impl_._has_bits_);
  static void set_has_guest_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetGuestDebugFtraceEvent)
}
KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(const KvmSetGuestDebugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetGuestDebugFtraceEvent)
}

inline void KvmSetGuestDebugFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_) { ::uint64_t{0u} }

    , decltype(_impl_.guest_debug_) { 0u }

  };
}

KvmSetGuestDebugFtraceEvent::~KvmSetGuestDebugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetGuestDebugFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetGuestDebugFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSetGuestDebugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vcpu_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.guest_debug_) -
        reinterpret_cast<char*>(&_impl_.vcpu_)) + sizeof(_impl_.guest_debug_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmSetGuestDebugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 guest_debug = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_debug(&has_bits);
          _impl_.guest_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu(&has_bits);
          _impl_.vcpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmSetGuestDebugFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 guest_debug = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_guest_debug(), target);
  }

  // optional uint64 vcpu = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_vcpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  return target;
}

::size_t KvmSetGuestDebugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu());
    }

    // optional uint32 guest_debug = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_guest_debug());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmSetGuestDebugFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmSetGuestDebugFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmSetGuestDebugFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmSetGuestDebugFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmSetGuestDebugFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmSetGuestDebugFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_ = from._impl_.vcpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.guest_debug_ = from._impl_.guest_debug_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmSetGuestDebugFtraceEvent::CopyFrom(const KvmSetGuestDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetGuestDebugFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetGuestDebugFtraceEvent::InternalSwap(KvmSetGuestDebugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSetGuestDebugFtraceEvent, _impl_.guest_debug_)
      + sizeof(KvmSetGuestDebugFtraceEvent::_impl_.guest_debug_)
      - PROTOBUF_FIELD_OFFSET(KvmSetGuestDebugFtraceEvent, _impl_.vcpu_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmSetGuestDebugFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[18]);
}
// ===================================================================

class KvmSetIrqFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetIrqFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmSetIrqFtraceEvent, _impl_._has_bits_);
  static void set_has_gsi(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_irq_source_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetIrqFtraceEvent)
}
KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(const KvmSetIrqFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetIrqFtraceEvent)
}

inline void KvmSetIrqFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gsi_) { 0u }

    , decltype(_impl_.irq_source_id_) { 0 }

    , decltype(_impl_.level_) { 0 }

  };
}

KvmSetIrqFtraceEvent::~KvmSetIrqFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetIrqFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetIrqFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetIrqFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSetIrqFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetIrqFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.gsi_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.level_) -
        reinterpret_cast<char*>(&_impl_.gsi_)) + sizeof(_impl_.level_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmSetIrqFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gsi = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gsi(&has_bits);
          _impl_.gsi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 irq_source_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_irq_source_id(&has_bits);
          _impl_.irq_source_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmSetIrqFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetIrqFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gsi = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_gsi(), target);
  }

  // optional int32 irq_source_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_irq_source_id(), target);
  }

  // optional int32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetIrqFtraceEvent)
  return target;
}

::size_t KvmSetIrqFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetIrqFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 gsi = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gsi());
    }

    // optional int32 irq_source_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_irq_source_id());
    }

    // optional int32 level = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_level());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmSetIrqFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmSetIrqFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmSetIrqFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmSetIrqFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmSetIrqFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmSetIrqFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetIrqFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gsi_ = from._impl_.gsi_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.irq_source_id_ = from._impl_.irq_source_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmSetIrqFtraceEvent::CopyFrom(const KvmSetIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetIrqFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetIrqFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetIrqFtraceEvent::InternalSwap(KvmSetIrqFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSetIrqFtraceEvent, _impl_.level_)
      + sizeof(KvmSetIrqFtraceEvent::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(KvmSetIrqFtraceEvent, _impl_.gsi_)>(
          reinterpret_cast<char*>(&_impl_.gsi_),
          reinterpret_cast<char*>(&other->_impl_.gsi_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmSetIrqFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[19]);
}
// ===================================================================

class KvmSetSpteHvaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetSpteHvaFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmSetSpteHvaFtraceEvent, _impl_._has_bits_);
  static void set_has_hva(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetSpteHvaFtraceEvent)
}
KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(const KvmSetSpteHvaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetSpteHvaFtraceEvent)
}

inline void KvmSetSpteHvaFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hva_) { ::uint64_t{0u} }

  };
}

KvmSetSpteHvaFtraceEvent::~KvmSetSpteHvaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetSpteHvaFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetSpteHvaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSetSpteHvaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hva_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmSetSpteHvaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hva = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_hva(&has_bits);
          _impl_.hva_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmSetSpteHvaFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 hva = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_hva(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  return target;
}

::size_t KvmSetSpteHvaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 hva = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_hva());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmSetSpteHvaFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmSetSpteHvaFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmSetSpteHvaFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmSetSpteHvaFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmSetSpteHvaFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmSetSpteHvaFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_hva(from._internal_hva());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmSetSpteHvaFtraceEvent::CopyFrom(const KvmSetSpteHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetSpteHvaFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetSpteHvaFtraceEvent::InternalSwap(KvmSetSpteHvaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.hva_, other->_impl_.hva_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmSetSpteHvaFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[20]);
}
// ===================================================================

class KvmSetWayFlushFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetWayFlushFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmSetWayFlushFtraceEvent, _impl_._has_bits_);
  static void set_has_cache(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetWayFlushFtraceEvent)
}
KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(const KvmSetWayFlushFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetWayFlushFtraceEvent)
}

inline void KvmSetWayFlushFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_) { ::uint64_t{0u} }

    , decltype(_impl_.cache_) { 0u }

  };
}

KvmSetWayFlushFtraceEvent::~KvmSetWayFlushFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetWayFlushFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetWayFlushFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetWayFlushFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSetWayFlushFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vcpu_pc_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.cache_) -
        reinterpret_cast<char*>(&_impl_.vcpu_pc_)) + sizeof(_impl_.cache_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmSetWayFlushFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 cache = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_cache(&has_bits);
          _impl_.cache_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_pc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmSetWayFlushFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 cache = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_cache(), target);
  }

  // optional uint64 vcpu_pc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetWayFlushFtraceEvent)
  return target;
}

::size_t KvmSetWayFlushFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu_pc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_pc());
    }

    // optional uint32 cache = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_cache());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmSetWayFlushFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmSetWayFlushFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmSetWayFlushFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmSetWayFlushFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmSetWayFlushFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmSetWayFlushFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cache_ = from._impl_.cache_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmSetWayFlushFtraceEvent::CopyFrom(const KvmSetWayFlushFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetWayFlushFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetWayFlushFtraceEvent::InternalSwap(KvmSetWayFlushFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSetWayFlushFtraceEvent, _impl_.cache_)
      + sizeof(KvmSetWayFlushFtraceEvent::_impl_.cache_)
      - PROTOBUF_FIELD_OFFSET(KvmSetWayFlushFtraceEvent, _impl_.vcpu_pc_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_pc_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_pc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmSetWayFlushFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[21]);
}
// ===================================================================

class KvmSysAccessFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSysAccessFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmSysAccessFtraceEvent, _impl_._has_bits_);
  static void set_has_crm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_crn(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_op0(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_op1(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_op2(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_write(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSysAccessFtraceEvent)
}
KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(const KvmSysAccessFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KvmSysAccessFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.crm_) {}

    , decltype(_impl_.crn_) {}

    , decltype(_impl_.op0_) {}

    , decltype(_impl_.op1_) {}

    , decltype(_impl_.op2_) {}

    , decltype(_impl_.is_write_) {}

    , decltype(_impl_.vcpu_pc_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.crm_, &from._impl_.crm_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
    reinterpret_cast<char*>(&_impl_.crm_)) + sizeof(_impl_.vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSysAccessFtraceEvent)
}

inline void KvmSysAccessFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.crm_) { 0u }

    , decltype(_impl_.crn_) { 0u }

    , decltype(_impl_.op0_) { 0u }

    , decltype(_impl_.op1_) { 0u }

    , decltype(_impl_.op2_) { 0u }

    , decltype(_impl_.is_write_) { 0u }

    , decltype(_impl_.vcpu_pc_) { ::uint64_t{0u} }

  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KvmSysAccessFtraceEvent::~KvmSysAccessFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSysAccessFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSysAccessFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void KvmSysAccessFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSysAccessFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSysAccessFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.crm_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.crm_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmSysAccessFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 CRm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_crm(&has_bits);
          _impl_.crm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 CRn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_crn(&has_bits);
          _impl_.crn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 Op0 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_op0(&has_bits);
          _impl_.op0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 Op1 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_op1(&has_bits);
          _impl_.op1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 Op2 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_op2(&has_bits);
          _impl_.op2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 is_write = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_is_write(&has_bits);
          _impl_.is_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.KvmSysAccessFtraceEvent.name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_pc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmSysAccessFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSysAccessFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 CRm = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_crm(), target);
  }

  // optional uint32 CRn = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_crn(), target);
  }

  // optional uint32 Op0 = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_op0(), target);
  }

  // optional uint32 Op1 = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_op1(), target);
  }

  // optional uint32 Op2 = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_op2(), target);
  }

  // optional uint32 is_write = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_is_write(), target);
  }

  // optional string name = 7;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.KvmSysAccessFtraceEvent.name");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional uint64 vcpu_pc = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSysAccessFtraceEvent)
  return target;
}

::size_t KvmSysAccessFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSysAccessFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
    }

    // optional uint32 CRm = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_crm());
    }

    // optional uint32 CRn = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_crn());
    }

    // optional uint32 Op0 = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_op0());
    }

    // optional uint32 Op1 = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_op1());
    }

    // optional uint32 Op2 = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_op2());
    }

    // optional uint32 is_write = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_is_write());
    }

    // optional uint64 vcpu_pc = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_pc());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmSysAccessFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmSysAccessFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmSysAccessFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmSysAccessFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmSysAccessFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmSysAccessFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSysAccessFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.crm_ = from._impl_.crm_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.crn_ = from._impl_.crn_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.op0_ = from._impl_.op0_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.op1_ = from._impl_.op1_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.op2_ = from._impl_.op2_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_write_ = from._impl_.is_write_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmSysAccessFtraceEvent::CopyFrom(const KvmSysAccessFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSysAccessFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSysAccessFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSysAccessFtraceEvent::InternalSwap(KvmSysAccessFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSysAccessFtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmSysAccessFtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmSysAccessFtraceEvent, _impl_.crm_)>(
          reinterpret_cast<char*>(&_impl_.crm_),
          reinterpret_cast<char*>(&other->_impl_.crm_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmSysAccessFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[22]);
}
// ===================================================================

class KvmTestAgeHvaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTestAgeHvaFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmTestAgeHvaFtraceEvent, _impl_._has_bits_);
  static void set_has_hva(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTestAgeHvaFtraceEvent)
}
KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(const KvmTestAgeHvaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTestAgeHvaFtraceEvent)
}

inline void KvmTestAgeHvaFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hva_) { ::uint64_t{0u} }

  };
}

KvmTestAgeHvaFtraceEvent::~KvmTestAgeHvaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTestAgeHvaFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTestAgeHvaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTestAgeHvaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hva_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmTestAgeHvaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hva = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_hva(&has_bits);
          _impl_.hva_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmTestAgeHvaFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 hva = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_hva(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  return target;
}

::size_t KvmTestAgeHvaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 hva = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_hva());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmTestAgeHvaFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmTestAgeHvaFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmTestAgeHvaFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmTestAgeHvaFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmTestAgeHvaFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmTestAgeHvaFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_hva(from._internal_hva());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmTestAgeHvaFtraceEvent::CopyFrom(const KvmTestAgeHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTestAgeHvaFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTestAgeHvaFtraceEvent::InternalSwap(KvmTestAgeHvaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.hva_, other->_impl_.hva_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmTestAgeHvaFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[23]);
}
// ===================================================================

class KvmTimerEmulateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerEmulateFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmTimerEmulateFtraceEvent, _impl_._has_bits_);
  static void set_has_should_fire(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerEmulateFtraceEvent)
}
KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(const KvmTimerEmulateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerEmulateFtraceEvent)
}

inline void KvmTimerEmulateFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.should_fire_) { 0u }

    , decltype(_impl_.timer_idx_) { 0 }

  };
}

KvmTimerEmulateFtraceEvent::~KvmTimerEmulateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerEmulateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerEmulateFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerEmulateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerEmulateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.should_fire_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.timer_idx_) -
        reinterpret_cast<char*>(&_impl_.should_fire_)) + sizeof(_impl_.timer_idx_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmTimerEmulateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 should_fire = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_should_fire(&has_bits);
          _impl_.should_fire_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 timer_idx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_timer_idx(&has_bits);
          _impl_.timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmTimerEmulateFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 should_fire = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_should_fire(), target);
  }

  // optional int32 timer_idx = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerEmulateFtraceEvent)
  return target;
}

::size_t KvmTimerEmulateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 should_fire = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_should_fire());
    }

    // optional int32 timer_idx = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_timer_idx());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmTimerEmulateFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmTimerEmulateFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmTimerEmulateFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmTimerEmulateFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmTimerEmulateFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmTimerEmulateFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.should_fire_ = from._impl_.should_fire_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timer_idx_ = from._impl_.timer_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmTimerEmulateFtraceEvent::CopyFrom(const KvmTimerEmulateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerEmulateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerEmulateFtraceEvent::InternalSwap(KvmTimerEmulateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerEmulateFtraceEvent, _impl_.timer_idx_)
      + sizeof(KvmTimerEmulateFtraceEvent::_impl_.timer_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerEmulateFtraceEvent, _impl_.should_fire_)>(
          reinterpret_cast<char*>(&_impl_.should_fire_),
          reinterpret_cast<char*>(&other->_impl_.should_fire_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmTimerEmulateFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[24]);
}
// ===================================================================

class KvmTimerHrtimerExpireFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerHrtimerExpireFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmTimerHrtimerExpireFtraceEvent, _impl_._has_bits_);
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
}
KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(const KvmTimerHrtimerExpireFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
}

inline void KvmTimerHrtimerExpireFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timer_idx_) { 0 }

  };
}

KvmTimerHrtimerExpireFtraceEvent::~KvmTimerHrtimerExpireFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerHrtimerExpireFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerHrtimerExpireFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerHrtimerExpireFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.timer_idx_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmTimerHrtimerExpireFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 timer_idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_timer_idx(&has_bits);
          _impl_.timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmTimerHrtimerExpireFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 timer_idx = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  return target;
}

::size_t KvmTimerHrtimerExpireFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 timer_idx = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_timer_idx());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmTimerHrtimerExpireFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmTimerHrtimerExpireFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmTimerHrtimerExpireFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmTimerHrtimerExpireFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmTimerHrtimerExpireFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmTimerHrtimerExpireFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_timer_idx(from._internal_timer_idx());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmTimerHrtimerExpireFtraceEvent::CopyFrom(const KvmTimerHrtimerExpireFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerHrtimerExpireFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerHrtimerExpireFtraceEvent::InternalSwap(KvmTimerHrtimerExpireFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.timer_idx_, other->_impl_.timer_idx_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmTimerHrtimerExpireFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[25]);
}
// ===================================================================

class KvmTimerRestoreStateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerRestoreStateFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmTimerRestoreStateFtraceEvent, _impl_._has_bits_);
  static void set_has_ctl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
}
KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(const KvmTimerRestoreStateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
}

inline void KvmTimerRestoreStateFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_) { ::uint64_t{0u} }

    , decltype(_impl_.cval_) { ::uint64_t{0u} }

    , decltype(_impl_.timer_idx_) { 0 }

  };
}

KvmTimerRestoreStateFtraceEvent::~KvmTimerRestoreStateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerRestoreStateFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerRestoreStateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerRestoreStateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.ctl_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.timer_idx_) -
        reinterpret_cast<char*>(&_impl_.ctl_)) + sizeof(_impl_.timer_idx_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmTimerRestoreStateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ctl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl(&has_bits);
          _impl_.ctl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 cval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_cval(&has_bits);
          _impl_.cval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 timer_idx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_timer_idx(&has_bits);
          _impl_.timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmTimerRestoreStateFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ctl = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_ctl(), target);
  }

  // optional uint64 cval = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_cval(), target);
  }

  // optional int32 timer_idx = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  return target;
}

::size_t KvmTimerRestoreStateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ctl = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ctl());
    }

    // optional uint64 cval = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_cval());
    }

    // optional int32 timer_idx = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_timer_idx());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmTimerRestoreStateFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmTimerRestoreStateFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmTimerRestoreStateFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmTimerRestoreStateFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmTimerRestoreStateFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmTimerRestoreStateFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctl_ = from._impl_.ctl_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cval_ = from._impl_.cval_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timer_idx_ = from._impl_.timer_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmTimerRestoreStateFtraceEvent::CopyFrom(const KvmTimerRestoreStateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerRestoreStateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerRestoreStateFtraceEvent::InternalSwap(KvmTimerRestoreStateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerRestoreStateFtraceEvent, _impl_.timer_idx_)
      + sizeof(KvmTimerRestoreStateFtraceEvent::_impl_.timer_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerRestoreStateFtraceEvent, _impl_.ctl_)>(
          reinterpret_cast<char*>(&_impl_.ctl_),
          reinterpret_cast<char*>(&other->_impl_.ctl_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmTimerRestoreStateFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[26]);
}
// ===================================================================

class KvmTimerSaveStateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerSaveStateFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmTimerSaveStateFtraceEvent, _impl_._has_bits_);
  static void set_has_ctl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerSaveStateFtraceEvent)
}
KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(const KvmTimerSaveStateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerSaveStateFtraceEvent)
}

inline void KvmTimerSaveStateFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_) { ::uint64_t{0u} }

    , decltype(_impl_.cval_) { ::uint64_t{0u} }

    , decltype(_impl_.timer_idx_) { 0 }

  };
}

KvmTimerSaveStateFtraceEvent::~KvmTimerSaveStateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerSaveStateFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerSaveStateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerSaveStateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.ctl_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.timer_idx_) -
        reinterpret_cast<char*>(&_impl_.ctl_)) + sizeof(_impl_.timer_idx_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmTimerSaveStateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ctl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl(&has_bits);
          _impl_.ctl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 cval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_cval(&has_bits);
          _impl_.cval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 timer_idx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_timer_idx(&has_bits);
          _impl_.timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmTimerSaveStateFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ctl = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_ctl(), target);
  }

  // optional uint64 cval = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_cval(), target);
  }

  // optional int32 timer_idx = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  return target;
}

::size_t KvmTimerSaveStateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ctl = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ctl());
    }

    // optional uint64 cval = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_cval());
    }

    // optional int32 timer_idx = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_timer_idx());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmTimerSaveStateFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmTimerSaveStateFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmTimerSaveStateFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmTimerSaveStateFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmTimerSaveStateFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmTimerSaveStateFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctl_ = from._impl_.ctl_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cval_ = from._impl_.cval_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timer_idx_ = from._impl_.timer_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmTimerSaveStateFtraceEvent::CopyFrom(const KvmTimerSaveStateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerSaveStateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerSaveStateFtraceEvent::InternalSwap(KvmTimerSaveStateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerSaveStateFtraceEvent, _impl_.timer_idx_)
      + sizeof(KvmTimerSaveStateFtraceEvent::_impl_.timer_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerSaveStateFtraceEvent, _impl_.ctl_)>(
          reinterpret_cast<char*>(&_impl_.ctl_),
          reinterpret_cast<char*>(&other->_impl_.ctl_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmTimerSaveStateFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[27]);
}
// ===================================================================

class KvmTimerUpdateIrqFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerUpdateIrqFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmTimerUpdateIrqFtraceEvent, _impl_._has_bits_);
  static void set_has_irq(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
}
KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(const KvmTimerUpdateIrqFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
}

inline void KvmTimerUpdateIrqFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irq_) { 0u }

    , decltype(_impl_.level_) { 0 }

    , decltype(_impl_.vcpu_id_) { ::uint64_t{0u} }

  };
}

KvmTimerUpdateIrqFtraceEvent::~KvmTimerUpdateIrqFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerUpdateIrqFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerUpdateIrqFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerUpdateIrqFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.irq_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_id_) -
        reinterpret_cast<char*>(&_impl_.irq_)) + sizeof(_impl_.vcpu_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmTimerUpdateIrqFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 irq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_irq(&has_bits);
          _impl_.irq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_id(&has_bits);
          _impl_.vcpu_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmTimerUpdateIrqFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 irq = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_irq(), target);
  }

  // optional int32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_level(), target);
  }

  // optional uint64 vcpu_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_vcpu_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  return target;
}

::size_t KvmTimerUpdateIrqFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 irq = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_irq());
    }

    // optional int32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_level());
    }

    // optional uint64 vcpu_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmTimerUpdateIrqFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmTimerUpdateIrqFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmTimerUpdateIrqFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmTimerUpdateIrqFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmTimerUpdateIrqFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmTimerUpdateIrqFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.irq_ = from._impl_.irq_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_id_ = from._impl_.vcpu_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmTimerUpdateIrqFtraceEvent::CopyFrom(const KvmTimerUpdateIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerUpdateIrqFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerUpdateIrqFtraceEvent::InternalSwap(KvmTimerUpdateIrqFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerUpdateIrqFtraceEvent, _impl_.vcpu_id_)
      + sizeof(KvmTimerUpdateIrqFtraceEvent::_impl_.vcpu_id_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerUpdateIrqFtraceEvent, _impl_.irq_)>(
          reinterpret_cast<char*>(&_impl_.irq_),
          reinterpret_cast<char*>(&other->_impl_.irq_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmTimerUpdateIrqFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[28]);
}
// ===================================================================

class KvmToggleCacheFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmToggleCacheFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmToggleCacheFtraceEvent, _impl_._has_bits_);
  static void set_has_now(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_was(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmToggleCacheFtraceEvent)
}
KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(const KvmToggleCacheFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmToggleCacheFtraceEvent)
}

inline void KvmToggleCacheFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_) { ::uint64_t{0u} }

    , decltype(_impl_.now_) { 0u }

    , decltype(_impl_.was_) { 0u }

  };
}

KvmToggleCacheFtraceEvent::~KvmToggleCacheFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmToggleCacheFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmToggleCacheFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmToggleCacheFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmToggleCacheFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.vcpu_pc_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.was_) -
        reinterpret_cast<char*>(&_impl_.vcpu_pc_)) + sizeof(_impl_.was_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmToggleCacheFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 now = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_now(&has_bits);
          _impl_.now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_pc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 was = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_was(&has_bits);
          _impl_.was_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmToggleCacheFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 now = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_now(), target);
  }

  // optional uint64 vcpu_pc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_vcpu_pc(), target);
  }

  // optional uint32 was = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_was(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmToggleCacheFtraceEvent)
  return target;
}

::size_t KvmToggleCacheFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 vcpu_pc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_pc());
    }

    // optional uint32 now = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_now());
    }

    // optional uint32 was = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_was());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmToggleCacheFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmToggleCacheFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmToggleCacheFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmToggleCacheFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmToggleCacheFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmToggleCacheFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.now_ = from._impl_.now_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.was_ = from._impl_.was_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmToggleCacheFtraceEvent::CopyFrom(const KvmToggleCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmToggleCacheFtraceEvent::IsInitialized() const {
  return true;
}

void KvmToggleCacheFtraceEvent::InternalSwap(KvmToggleCacheFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmToggleCacheFtraceEvent, _impl_.was_)
      + sizeof(KvmToggleCacheFtraceEvent::_impl_.was_)
      - PROTOBUF_FIELD_OFFSET(KvmToggleCacheFtraceEvent, _impl_.vcpu_pc_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_pc_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_pc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmToggleCacheFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[29]);
}
// ===================================================================

class KvmUnmapHvaRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmUnmapHvaRangeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmUnmapHvaRangeFtraceEvent, _impl_._has_bits_);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
}
KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(const KvmUnmapHvaRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
}

inline void KvmUnmapHvaRangeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.end_) { ::uint64_t{0u} }

    , decltype(_impl_.start_) { ::uint64_t{0u} }

  };
}

KvmUnmapHvaRangeFtraceEvent::~KvmUnmapHvaRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmUnmapHvaRangeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmUnmapHvaRangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmUnmapHvaRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.end_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.start_) -
        reinterpret_cast<char*>(&_impl_.end_)) + sizeof(_impl_.start_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmUnmapHvaRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 end = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmUnmapHvaRangeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 end = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_end(), target);
  }

  // optional uint64 start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  return target;
}

::size_t KvmUnmapHvaRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 end = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_end());
    }

    // optional uint64 start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_start());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmUnmapHvaRangeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmUnmapHvaRangeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmUnmapHvaRangeFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmUnmapHvaRangeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmUnmapHvaRangeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmUnmapHvaRangeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmUnmapHvaRangeFtraceEvent::CopyFrom(const KvmUnmapHvaRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmUnmapHvaRangeFtraceEvent::IsInitialized() const {
  return true;
}

void KvmUnmapHvaRangeFtraceEvent::InternalSwap(KvmUnmapHvaRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmUnmapHvaRangeFtraceEvent, _impl_.start_)
      + sizeof(KvmUnmapHvaRangeFtraceEvent::_impl_.start_)
      - PROTOBUF_FIELD_OFFSET(KvmUnmapHvaRangeFtraceEvent, _impl_.end_)>(
          reinterpret_cast<char*>(&_impl_.end_),
          reinterpret_cast<char*>(&other->_impl_.end_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmUnmapHvaRangeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[30]);
}
// ===================================================================

class KvmUserspaceExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmUserspaceExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmUserspaceExitFtraceEvent, _impl_._has_bits_);
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmUserspaceExitFtraceEvent)
}
KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(const KvmUserspaceExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmUserspaceExitFtraceEvent)
}

inline void KvmUserspaceExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_) { 0u }

  };
}

KvmUserspaceExitFtraceEvent::~KvmUserspaceExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmUserspaceExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmUserspaceExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmUserspaceExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmUserspaceExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reason_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmUserspaceExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_reason(&has_bits);
          _impl_.reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmUserspaceExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 reason = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmUserspaceExitFtraceEvent)
  return target;
}

::size_t KvmUserspaceExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 reason = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_reason());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmUserspaceExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmUserspaceExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmUserspaceExitFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmUserspaceExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmUserspaceExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmUserspaceExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_reason(from._internal_reason());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmUserspaceExitFtraceEvent::CopyFrom(const KvmUserspaceExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmUserspaceExitFtraceEvent::IsInitialized() const {
  return true;
}

void KvmUserspaceExitFtraceEvent::InternalSwap(KvmUserspaceExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.reason_, other->_impl_.reason_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmUserspaceExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[31]);
}
// ===================================================================

class KvmVcpuWakeupFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmVcpuWakeupFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmVcpuWakeupFtraceEvent, _impl_._has_bits_);
  static void set_has_ns(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_waited(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmVcpuWakeupFtraceEvent)
}
KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(const KvmVcpuWakeupFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmVcpuWakeupFtraceEvent)
}

inline void KvmVcpuWakeupFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ns_) { ::uint64_t{0u} }

    , decltype(_impl_.valid_) { 0u }

    , decltype(_impl_.waited_) { 0u }

  };
}

KvmVcpuWakeupFtraceEvent::~KvmVcpuWakeupFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmVcpuWakeupFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmVcpuWakeupFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmVcpuWakeupFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.ns_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.waited_) -
        reinterpret_cast<char*>(&_impl_.ns_)) + sizeof(_impl_.waited_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmVcpuWakeupFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ns = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_ns(&has_bits);
          _impl_.ns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 valid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_valid(&has_bits);
          _impl_.valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 waited = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_waited(&has_bits);
          _impl_.waited_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmVcpuWakeupFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ns = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_ns(), target);
  }

  // optional uint32 valid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_valid(), target);
  }

  // optional uint32 waited = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_waited(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  return target;
}

::size_t KvmVcpuWakeupFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ns = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ns());
    }

    // optional uint32 valid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_valid());
    }

    // optional uint32 waited = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_waited());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmVcpuWakeupFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmVcpuWakeupFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmVcpuWakeupFtraceEvent::GetClassData() const { return &_class_data_; }


void KvmVcpuWakeupFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmVcpuWakeupFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmVcpuWakeupFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ns_ = from._impl_.ns_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.valid_ = from._impl_.valid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.waited_ = from._impl_.waited_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmVcpuWakeupFtraceEvent::CopyFrom(const KvmVcpuWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmVcpuWakeupFtraceEvent::IsInitialized() const {
  return true;
}

void KvmVcpuWakeupFtraceEvent::InternalSwap(KvmVcpuWakeupFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmVcpuWakeupFtraceEvent, _impl_.waited_)
      + sizeof(KvmVcpuWakeupFtraceEvent::_impl_.waited_)
      - PROTOBUF_FIELD_OFFSET(KvmVcpuWakeupFtraceEvent, _impl_.ns_)>(
          reinterpret_cast<char*>(&_impl_.ns_),
          reinterpret_cast<char*>(&other->_impl_.ns_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmVcpuWakeupFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[32]);
}
// ===================================================================

class KvmWfxArm64FtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmWfxArm64FtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KvmWfxArm64FtraceEvent, _impl_._has_bits_);
  static void set_has_is_wfe(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmWfxArm64FtraceEvent)
}
KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(const KvmWfxArm64FtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmWfxArm64FtraceEvent)
}

inline void KvmWfxArm64FtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_) { ::uint64_t{0u} }

    , decltype(_impl_.is_wfe_) { 0u }

  };
}

KvmWfxArm64FtraceEvent::~KvmWfxArm64FtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmWfxArm64FtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmWfxArm64FtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmWfxArm64FtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmWfxArm64FtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vcpu_pc_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_wfe_) -
        reinterpret_cast<char*>(&_impl_.vcpu_pc_)) + sizeof(_impl_.is_wfe_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvmWfxArm64FtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 is_wfe = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_is_wfe(&has_bits);
          _impl_.is_wfe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_pc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KvmWfxArm64FtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 is_wfe = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_is_wfe(), target);
  }

  // optional uint64 vcpu_pc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmWfxArm64FtraceEvent)
  return target;
}

::size_t KvmWfxArm64FtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu_pc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_pc());
    }

    // optional uint32 is_wfe = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_is_wfe());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvmWfxArm64FtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KvmWfxArm64FtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvmWfxArm64FtraceEvent::GetClassData() const { return &_class_data_; }


void KvmWfxArm64FtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KvmWfxArm64FtraceEvent*>(&to_msg);
  auto& from = static_cast<const KvmWfxArm64FtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_wfe_ = from._impl_.is_wfe_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvmWfxArm64FtraceEvent::CopyFrom(const KvmWfxArm64FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmWfxArm64FtraceEvent::IsInitialized() const {
  return true;
}

void KvmWfxArm64FtraceEvent::InternalSwap(KvmWfxArm64FtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmWfxArm64FtraceEvent, _impl_.is_wfe_)
      + sizeof(KvmWfxArm64FtraceEvent::_impl_.is_wfe_)
      - PROTOBUF_FIELD_OFFSET(KvmWfxArm64FtraceEvent, _impl_.vcpu_pc_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_pc_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_pc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvmWfxArm64FtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[33]);
}
// ===================================================================

class TrapRegFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<TrapRegFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TrapRegFtraceEvent, _impl_._has_bits_);
  static void set_has_fn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_write(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reg(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_write_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TrapRegFtraceEvent::TrapRegFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.TrapRegFtraceEvent)
}
TrapRegFtraceEvent::TrapRegFtraceEvent(const TrapRegFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrapRegFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fn_) {}

    , decltype(_impl_.is_write_) {}

    , decltype(_impl_.reg_) {}

    , decltype(_impl_.write_value_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fn_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.fn_.Set(from._internal_fn(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_write_, &from._impl_.is_write_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.write_value_) -
    reinterpret_cast<char*>(&_impl_.is_write_)) + sizeof(_impl_.write_value_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TrapRegFtraceEvent)
}

inline void TrapRegFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fn_) {}

    , decltype(_impl_.is_write_) { 0u }

    , decltype(_impl_.reg_) { 0 }

    , decltype(_impl_.write_value_) { ::uint64_t{0u} }

  };
  _impl_.fn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.fn_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TrapRegFtraceEvent::~TrapRegFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TrapRegFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrapRegFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fn_.Destroy();
}

void TrapRegFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrapRegFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TrapRegFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.fn_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.is_write_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.write_value_) -
        reinterpret_cast<char*>(&_impl_.is_write_)) + sizeof(_impl_.write_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrapRegFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string fn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_fn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.TrapRegFtraceEvent.fn");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 is_write = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_is_write(&has_bits);
          _impl_.is_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 reg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_reg(&has_bits);
          _impl_.reg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 write_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_write_value(&has_bits);
          _impl_.write_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TrapRegFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.TrapRegFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string fn = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_fn();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.TrapRegFtraceEvent.fn");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional uint32 is_write = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_is_write(), target);
  }

  // optional int32 reg = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_reg(), target);
  }

  // optional uint64 write_value = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_write_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.TrapRegFtraceEvent)
  return target;
}

::size_t TrapRegFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TrapRegFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string fn = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_fn());
    }

    // optional uint32 is_write = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_is_write());
    }

    // optional int32 reg = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_reg());
    }

    // optional uint64 write_value = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_write_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrapRegFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrapRegFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrapRegFtraceEvent::GetClassData() const { return &_class_data_; }


void TrapRegFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrapRegFtraceEvent*>(&to_msg);
  auto& from = static_cast<const TrapRegFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TrapRegFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_fn(from._internal_fn());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_write_ = from._impl_.is_write_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.reg_ = from._impl_.reg_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.write_value_ = from._impl_.write_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrapRegFtraceEvent::CopyFrom(const TrapRegFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TrapRegFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrapRegFtraceEvent::IsInitialized() const {
  return true;
}

void TrapRegFtraceEvent::InternalSwap(TrapRegFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fn_, lhs_arena,
                                       &other->_impl_.fn_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrapRegFtraceEvent, _impl_.write_value_)
      + sizeof(TrapRegFtraceEvent::_impl_.write_value_)
      - PROTOBUF_FIELD_OFFSET(TrapRegFtraceEvent, _impl_.is_write_)>(
          reinterpret_cast<char*>(&_impl_.is_write_),
          reinterpret_cast<char*>(&other->_impl_.is_write_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrapRegFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[34]);
}
// ===================================================================

class VgicUpdateIrqPendingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<VgicUpdateIrqPendingFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(VgicUpdateIrqPendingFtraceEvent, _impl_._has_bits_);
  static void set_has_irq(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
}
VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(const VgicUpdateIrqPendingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
}

inline void VgicUpdateIrqPendingFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irq_) { 0u }

    , decltype(_impl_.level_) { 0u }

    , decltype(_impl_.vcpu_id_) { ::uint64_t{0u} }

  };
}

VgicUpdateIrqPendingFtraceEvent::~VgicUpdateIrqPendingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VgicUpdateIrqPendingFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void VgicUpdateIrqPendingFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VgicUpdateIrqPendingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.irq_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_id_) -
        reinterpret_cast<char*>(&_impl_.irq_)) + sizeof(_impl_.vcpu_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VgicUpdateIrqPendingFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 irq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_irq(&has_bits);
          _impl_.irq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 vcpu_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_id(&has_bits);
          _impl_.vcpu_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VgicUpdateIrqPendingFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 irq = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_irq(), target);
  }

  // optional uint32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_level(), target);
  }

  // optional uint64 vcpu_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_vcpu_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  return target;
}

::size_t VgicUpdateIrqPendingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 irq = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_irq());
    }

    // optional uint32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_level());
    }

    // optional uint64 vcpu_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_vcpu_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VgicUpdateIrqPendingFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VgicUpdateIrqPendingFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VgicUpdateIrqPendingFtraceEvent::GetClassData() const { return &_class_data_; }


void VgicUpdateIrqPendingFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VgicUpdateIrqPendingFtraceEvent*>(&to_msg);
  auto& from = static_cast<const VgicUpdateIrqPendingFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.irq_ = from._impl_.irq_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_id_ = from._impl_.vcpu_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VgicUpdateIrqPendingFtraceEvent::CopyFrom(const VgicUpdateIrqPendingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VgicUpdateIrqPendingFtraceEvent::IsInitialized() const {
  return true;
}

void VgicUpdateIrqPendingFtraceEvent::InternalSwap(VgicUpdateIrqPendingFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VgicUpdateIrqPendingFtraceEvent, _impl_.vcpu_id_)
      + sizeof(VgicUpdateIrqPendingFtraceEvent::_impl_.vcpu_id_)
      - PROTOBUF_FIELD_OFFSET(VgicUpdateIrqPendingFtraceEvent, _impl_.irq_)>(
          reinterpret_cast<char*>(&_impl_.irq_),
          reinterpret_cast<char*>(&other->_impl_.irq_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VgicUpdateIrqPendingFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkvm_2eproto[35]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAccessFaultFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAccessFaultFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAccessFaultFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAckIrqFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAckIrqFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAckIrqFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAgeHvaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAgeHvaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAgeHvaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAgePageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAgePageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAgePageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmClearDebugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmClearDebugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmClearDebugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmSetDreg32FtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmSetDreg32FtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmSetDreg32FtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmSetRegsetFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmSetRegsetFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmSetRegsetFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmSetupDebugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmSetupDebugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmSetupDebugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmEntryFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmEntryFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmEntryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmFpuFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmFpuFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmFpuFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmGetTimerMapFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmGetTimerMapFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmGetTimerMapFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmGuestFaultFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmGuestFaultFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmGuestFaultFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmHandleSysRegFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmHandleSysRegFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmHandleSysRegFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmHvcArm64FtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmHvcArm64FtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmHvcArm64FtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmIrqLineFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmIrqLineFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmIrqLineFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmMmioFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmMmioFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmMmioFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmMmioEmulateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmMmioEmulateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmMmioEmulateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetGuestDebugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetGuestDebugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetGuestDebugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetIrqFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetIrqFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetIrqFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetSpteHvaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetSpteHvaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetSpteHvaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetWayFlushFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetWayFlushFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetWayFlushFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSysAccessFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSysAccessFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSysAccessFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTestAgeHvaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTestAgeHvaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTestAgeHvaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerEmulateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerEmulateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerEmulateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerRestoreStateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerRestoreStateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerRestoreStateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerSaveStateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerSaveStateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerSaveStateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerUpdateIrqFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerUpdateIrqFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerUpdateIrqFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmToggleCacheFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmToggleCacheFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmToggleCacheFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmUnmapHvaRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmUnmapHvaRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmUnmapHvaRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmUserspaceExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmUserspaceExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmUserspaceExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmVcpuWakeupFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmVcpuWakeupFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmVcpuWakeupFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmWfxArm64FtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmWfxArm64FtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmWfxArm64FtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::TrapRegFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::TrapRegFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::TrapRegFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::VgicUpdateIrqPendingFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::VgicUpdateIrqPendingFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::VgicUpdateIrqPendingFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
