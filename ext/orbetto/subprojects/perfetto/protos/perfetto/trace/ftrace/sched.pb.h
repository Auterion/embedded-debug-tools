// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/sched.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
namespace perfetto {
namespace protos {
class SchedBlockedReasonFtraceEvent;
struct SchedBlockedReasonFtraceEventDefaultTypeInternal;
extern SchedBlockedReasonFtraceEventDefaultTypeInternal _SchedBlockedReasonFtraceEvent_default_instance_;
class SchedCpuHotplugFtraceEvent;
struct SchedCpuHotplugFtraceEventDefaultTypeInternal;
extern SchedCpuHotplugFtraceEventDefaultTypeInternal _SchedCpuHotplugFtraceEvent_default_instance_;
class SchedCpuUtilCfsFtraceEvent;
struct SchedCpuUtilCfsFtraceEventDefaultTypeInternal;
extern SchedCpuUtilCfsFtraceEventDefaultTypeInternal _SchedCpuUtilCfsFtraceEvent_default_instance_;
class SchedPiSetprioFtraceEvent;
struct SchedPiSetprioFtraceEventDefaultTypeInternal;
extern SchedPiSetprioFtraceEventDefaultTypeInternal _SchedPiSetprioFtraceEvent_default_instance_;
class SchedProcessExecFtraceEvent;
struct SchedProcessExecFtraceEventDefaultTypeInternal;
extern SchedProcessExecFtraceEventDefaultTypeInternal _SchedProcessExecFtraceEvent_default_instance_;
class SchedProcessExitFtraceEvent;
struct SchedProcessExitFtraceEventDefaultTypeInternal;
extern SchedProcessExitFtraceEventDefaultTypeInternal _SchedProcessExitFtraceEvent_default_instance_;
class SchedProcessForkFtraceEvent;
struct SchedProcessForkFtraceEventDefaultTypeInternal;
extern SchedProcessForkFtraceEventDefaultTypeInternal _SchedProcessForkFtraceEvent_default_instance_;
class SchedProcessFreeFtraceEvent;
struct SchedProcessFreeFtraceEventDefaultTypeInternal;
extern SchedProcessFreeFtraceEventDefaultTypeInternal _SchedProcessFreeFtraceEvent_default_instance_;
class SchedProcessHangFtraceEvent;
struct SchedProcessHangFtraceEventDefaultTypeInternal;
extern SchedProcessHangFtraceEventDefaultTypeInternal _SchedProcessHangFtraceEvent_default_instance_;
class SchedProcessWaitFtraceEvent;
struct SchedProcessWaitFtraceEventDefaultTypeInternal;
extern SchedProcessWaitFtraceEventDefaultTypeInternal _SchedProcessWaitFtraceEvent_default_instance_;
class SchedSwitchFtraceEvent;
struct SchedSwitchFtraceEventDefaultTypeInternal;
extern SchedSwitchFtraceEventDefaultTypeInternal _SchedSwitchFtraceEvent_default_instance_;
class SchedWakeupFtraceEvent;
struct SchedWakeupFtraceEventDefaultTypeInternal;
extern SchedWakeupFtraceEventDefaultTypeInternal _SchedWakeupFtraceEvent_default_instance_;
class SchedWakeupNewFtraceEvent;
struct SchedWakeupNewFtraceEventDefaultTypeInternal;
extern SchedWakeupNewFtraceEventDefaultTypeInternal _SchedWakeupNewFtraceEvent_default_instance_;
class SchedWakingFtraceEvent;
struct SchedWakingFtraceEventDefaultTypeInternal;
extern SchedWakingFtraceEventDefaultTypeInternal _SchedWakingFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template <>
::perfetto::protos::SchedBlockedReasonFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedBlockedReasonFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedCpuHotplugFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedCpuHotplugFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedCpuUtilCfsFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedCpuUtilCfsFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedPiSetprioFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedPiSetprioFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedProcessExecFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessExecFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedProcessExitFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessExitFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedProcessForkFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessForkFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedProcessFreeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessFreeFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedProcessHangFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessHangFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedProcessWaitFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessWaitFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedSwitchFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedSwitchFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedWakeupFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedWakeupFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedWakeupNewFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedWakeupNewFtraceEvent>(Arena*);
template <>
::perfetto::protos::SchedWakingFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedWakingFtraceEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace perfetto {
namespace protos {

// ===================================================================


// -------------------------------------------------------------------

class SchedSwitchFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedSwitchFtraceEvent) */ {
 public:
  inline SchedSwitchFtraceEvent() : SchedSwitchFtraceEvent(nullptr) {}
  ~SchedSwitchFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedSwitchFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent& from);
  SchedSwitchFtraceEvent(SchedSwitchFtraceEvent&& from) noexcept
    : SchedSwitchFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedSwitchFtraceEvent& operator=(const SchedSwitchFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedSwitchFtraceEvent& operator=(SchedSwitchFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedSwitchFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedSwitchFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedSwitchFtraceEvent*>(
               &_SchedSwitchFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SchedSwitchFtraceEvent& a, SchedSwitchFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedSwitchFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedSwitchFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedSwitchFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedSwitchFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedSwitchFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedSwitchFtraceEvent& from) {
    SchedSwitchFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedSwitchFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedSwitchFtraceEvent";
  }
  protected:
  explicit SchedSwitchFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrevCommFieldNumber = 1,
    kNextCommFieldNumber = 5,
    kPrevPidFieldNumber = 2,
    kPrevPrioFieldNumber = 3,
    kPrevStateFieldNumber = 4,
    kNextPidFieldNumber = 6,
    kNextPrioFieldNumber = 7,
  };
  // optional string prev_comm = 1;
  bool has_prev_comm() const;
  void clear_prev_comm() ;
  const std::string& prev_comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prev_comm(Arg_&& arg, Args_... args);
  std::string* mutable_prev_comm();
  PROTOBUF_NODISCARD std::string* release_prev_comm();
  void set_allocated_prev_comm(std::string* ptr);

  private:
  const std::string& _internal_prev_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prev_comm(
      const std::string& value);
  std::string* _internal_mutable_prev_comm();

  public:
  // optional string next_comm = 5;
  bool has_next_comm() const;
  void clear_next_comm() ;
  const std::string& next_comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_comm(Arg_&& arg, Args_... args);
  std::string* mutable_next_comm();
  PROTOBUF_NODISCARD std::string* release_next_comm();
  void set_allocated_next_comm(std::string* ptr);

  private:
  const std::string& _internal_next_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_comm(
      const std::string& value);
  std::string* _internal_mutable_next_comm();

  public:
  // optional int32 prev_pid = 2;
  bool has_prev_pid() const;
  void clear_prev_pid() ;
  ::int32_t prev_pid() const;
  void set_prev_pid(::int32_t value);

  private:
  ::int32_t _internal_prev_pid() const;
  void _internal_set_prev_pid(::int32_t value);

  public:
  // optional int32 prev_prio = 3;
  bool has_prev_prio() const;
  void clear_prev_prio() ;
  ::int32_t prev_prio() const;
  void set_prev_prio(::int32_t value);

  private:
  ::int32_t _internal_prev_prio() const;
  void _internal_set_prev_prio(::int32_t value);

  public:
  // optional int64 prev_state = 4;
  bool has_prev_state() const;
  void clear_prev_state() ;
  ::int64_t prev_state() const;
  void set_prev_state(::int64_t value);

  private:
  ::int64_t _internal_prev_state() const;
  void _internal_set_prev_state(::int64_t value);

  public:
  // optional int32 next_pid = 6;
  bool has_next_pid() const;
  void clear_next_pid() ;
  ::int32_t next_pid() const;
  void set_next_pid(::int32_t value);

  private:
  ::int32_t _internal_next_pid() const;
  void _internal_set_next_pid(::int32_t value);

  public:
  // optional int32 next_prio = 7;
  bool has_next_prio() const;
  void clear_next_prio() ;
  ::int32_t next_prio() const;
  void set_next_prio(::int32_t value);

  private:
  ::int32_t _internal_next_prio() const;
  void _internal_set_next_prio(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedSwitchFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prev_comm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_comm_;
    ::int32_t prev_pid_;
    ::int32_t prev_prio_;
    ::int64_t prev_state_;
    ::int32_t next_pid_;
    ::int32_t next_prio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedWakeupFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedWakeupFtraceEvent) */ {
 public:
  inline SchedWakeupFtraceEvent() : SchedWakeupFtraceEvent(nullptr) {}
  ~SchedWakeupFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent& from);
  SchedWakeupFtraceEvent(SchedWakeupFtraceEvent&& from) noexcept
    : SchedWakeupFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedWakeupFtraceEvent& operator=(const SchedWakeupFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedWakeupFtraceEvent& operator=(SchedWakeupFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedWakeupFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedWakeupFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedWakeupFtraceEvent*>(
               &_SchedWakeupFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SchedWakeupFtraceEvent& a, SchedWakeupFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedWakeupFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedWakeupFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedWakeupFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedWakeupFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedWakeupFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedWakeupFtraceEvent& from) {
    SchedWakeupFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedWakeupFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedWakeupFtraceEvent";
  }
  protected:
  explicit SchedWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio() ;
  ::int32_t prio() const;
  void set_prio(::int32_t value);

  private:
  ::int32_t _internal_prio() const;
  void _internal_set_prio(::int32_t value);

  public:
  // optional int32 success = 4;
  bool has_success() const;
  void clear_success() ;
  ::int32_t success() const;
  void set_success(::int32_t value);

  private:
  ::int32_t _internal_success() const;
  void _internal_set_success(::int32_t value);

  public:
  // optional int32 target_cpu = 5;
  bool has_target_cpu() const;
  void clear_target_cpu() ;
  ::int32_t target_cpu() const;
  void set_target_cpu(::int32_t value);

  private:
  ::int32_t _internal_target_cpu() const;
  void _internal_set_target_cpu(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedWakeupFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::int32_t pid_;
    ::int32_t prio_;
    ::int32_t success_;
    ::int32_t target_cpu_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedBlockedReasonFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedBlockedReasonFtraceEvent) */ {
 public:
  inline SchedBlockedReasonFtraceEvent() : SchedBlockedReasonFtraceEvent(nullptr) {}
  ~SchedBlockedReasonFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedBlockedReasonFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent& from);
  SchedBlockedReasonFtraceEvent(SchedBlockedReasonFtraceEvent&& from) noexcept
    : SchedBlockedReasonFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedBlockedReasonFtraceEvent& operator=(const SchedBlockedReasonFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedBlockedReasonFtraceEvent& operator=(SchedBlockedReasonFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedBlockedReasonFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedBlockedReasonFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedBlockedReasonFtraceEvent*>(
               &_SchedBlockedReasonFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SchedBlockedReasonFtraceEvent& a, SchedBlockedReasonFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedBlockedReasonFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedBlockedReasonFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedBlockedReasonFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedBlockedReasonFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedBlockedReasonFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedBlockedReasonFtraceEvent& from) {
    SchedBlockedReasonFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedBlockedReasonFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedBlockedReasonFtraceEvent";
  }
  protected:
  explicit SchedBlockedReasonFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallerFieldNumber = 2,
    kPidFieldNumber = 1,
    kIoWaitFieldNumber = 3,
  };
  // optional uint64 caller = 2;
  bool has_caller() const;
  void clear_caller() ;
  ::uint64_t caller() const;
  void set_caller(::uint64_t value);

  private:
  ::uint64_t _internal_caller() const;
  void _internal_set_caller(::uint64_t value);

  public:
  // optional int32 pid = 1;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // optional uint32 io_wait = 3;
  bool has_io_wait() const;
  void clear_io_wait() ;
  ::uint32_t io_wait() const;
  void set_io_wait(::uint32_t value);

  private:
  ::uint32_t _internal_io_wait() const;
  void _internal_set_io_wait(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedBlockedReasonFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t caller_;
    ::int32_t pid_;
    ::uint32_t io_wait_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedCpuHotplugFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedCpuHotplugFtraceEvent) */ {
 public:
  inline SchedCpuHotplugFtraceEvent() : SchedCpuHotplugFtraceEvent(nullptr) {}
  ~SchedCpuHotplugFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedCpuHotplugFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent& from);
  SchedCpuHotplugFtraceEvent(SchedCpuHotplugFtraceEvent&& from) noexcept
    : SchedCpuHotplugFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedCpuHotplugFtraceEvent& operator=(const SchedCpuHotplugFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedCpuHotplugFtraceEvent& operator=(SchedCpuHotplugFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedCpuHotplugFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedCpuHotplugFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedCpuHotplugFtraceEvent*>(
               &_SchedCpuHotplugFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SchedCpuHotplugFtraceEvent& a, SchedCpuHotplugFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedCpuHotplugFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedCpuHotplugFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedCpuHotplugFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedCpuHotplugFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedCpuHotplugFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedCpuHotplugFtraceEvent& from) {
    SchedCpuHotplugFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedCpuHotplugFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedCpuHotplugFtraceEvent";
  }
  protected:
  explicit SchedCpuHotplugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedCpuFieldNumber = 1,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional int32 affected_cpu = 1;
  bool has_affected_cpu() const;
  void clear_affected_cpu() ;
  ::int32_t affected_cpu() const;
  void set_affected_cpu(::int32_t value);

  private:
  ::int32_t _internal_affected_cpu() const;
  void _internal_set_affected_cpu(::int32_t value);

  public:
  // optional int32 error = 2;
  bool has_error() const;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // optional int32 status = 3;
  bool has_status() const;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedCpuHotplugFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t affected_cpu_;
    ::int32_t error_;
    ::int32_t status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedWakingFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedWakingFtraceEvent) */ {
 public:
  inline SchedWakingFtraceEvent() : SchedWakingFtraceEvent(nullptr) {}
  ~SchedWakingFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedWakingFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedWakingFtraceEvent(const SchedWakingFtraceEvent& from);
  SchedWakingFtraceEvent(SchedWakingFtraceEvent&& from) noexcept
    : SchedWakingFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedWakingFtraceEvent& operator=(const SchedWakingFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedWakingFtraceEvent& operator=(SchedWakingFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedWakingFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedWakingFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedWakingFtraceEvent*>(
               &_SchedWakingFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SchedWakingFtraceEvent& a, SchedWakingFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedWakingFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedWakingFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedWakingFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedWakingFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedWakingFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedWakingFtraceEvent& from) {
    SchedWakingFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedWakingFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedWakingFtraceEvent";
  }
  protected:
  explicit SchedWakingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio() ;
  ::int32_t prio() const;
  void set_prio(::int32_t value);

  private:
  ::int32_t _internal_prio() const;
  void _internal_set_prio(::int32_t value);

  public:
  // optional int32 success = 4;
  bool has_success() const;
  void clear_success() ;
  ::int32_t success() const;
  void set_success(::int32_t value);

  private:
  ::int32_t _internal_success() const;
  void _internal_set_success(::int32_t value);

  public:
  // optional int32 target_cpu = 5;
  bool has_target_cpu() const;
  void clear_target_cpu() ;
  ::int32_t target_cpu() const;
  void set_target_cpu(::int32_t value);

  private:
  ::int32_t _internal_target_cpu() const;
  void _internal_set_target_cpu(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedWakingFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::int32_t pid_;
    ::int32_t prio_;
    ::int32_t success_;
    ::int32_t target_cpu_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedWakeupNewFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedWakeupNewFtraceEvent) */ {
 public:
  inline SchedWakeupNewFtraceEvent() : SchedWakeupNewFtraceEvent(nullptr) {}
  ~SchedWakeupNewFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedWakeupNewFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent& from);
  SchedWakeupNewFtraceEvent(SchedWakeupNewFtraceEvent&& from) noexcept
    : SchedWakeupNewFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedWakeupNewFtraceEvent& operator=(const SchedWakeupNewFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedWakeupNewFtraceEvent& operator=(SchedWakeupNewFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedWakeupNewFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedWakeupNewFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedWakeupNewFtraceEvent*>(
               &_SchedWakeupNewFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SchedWakeupNewFtraceEvent& a, SchedWakeupNewFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedWakeupNewFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedWakeupNewFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedWakeupNewFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedWakeupNewFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedWakeupNewFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedWakeupNewFtraceEvent& from) {
    SchedWakeupNewFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedWakeupNewFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedWakeupNewFtraceEvent";
  }
  protected:
  explicit SchedWakeupNewFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio() ;
  ::int32_t prio() const;
  void set_prio(::int32_t value);

  private:
  ::int32_t _internal_prio() const;
  void _internal_set_prio(::int32_t value);

  public:
  // optional int32 success = 4;
  bool has_success() const;
  void clear_success() ;
  ::int32_t success() const;
  void set_success(::int32_t value);

  private:
  ::int32_t _internal_success() const;
  void _internal_set_success(::int32_t value);

  public:
  // optional int32 target_cpu = 5;
  bool has_target_cpu() const;
  void clear_target_cpu() ;
  ::int32_t target_cpu() const;
  void set_target_cpu(::int32_t value);

  private:
  ::int32_t _internal_target_cpu() const;
  void _internal_set_target_cpu(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedWakeupNewFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::int32_t pid_;
    ::int32_t prio_;
    ::int32_t success_;
    ::int32_t target_cpu_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedProcessExecFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessExecFtraceEvent) */ {
 public:
  inline SchedProcessExecFtraceEvent() : SchedProcessExecFtraceEvent(nullptr) {}
  ~SchedProcessExecFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedProcessExecFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent& from);
  SchedProcessExecFtraceEvent(SchedProcessExecFtraceEvent&& from) noexcept
    : SchedProcessExecFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessExecFtraceEvent& operator=(const SchedProcessExecFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessExecFtraceEvent& operator=(SchedProcessExecFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedProcessExecFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessExecFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessExecFtraceEvent*>(
               &_SchedProcessExecFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SchedProcessExecFtraceEvent& a, SchedProcessExecFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessExecFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessExecFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessExecFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessExecFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedProcessExecFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedProcessExecFtraceEvent& from) {
    SchedProcessExecFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedProcessExecFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedProcessExecFtraceEvent";
  }
  protected:
  explicit SchedProcessExecFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kPidFieldNumber = 2,
    kOldPidFieldNumber = 3,
  };
  // optional string filename = 1;
  bool has_filename() const;
  void clear_filename() ;
  const std::string& filename() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filename(Arg_&& arg, Args_... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* ptr);

  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(
      const std::string& value);
  std::string* _internal_mutable_filename();

  public:
  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // optional int32 old_pid = 3;
  bool has_old_pid() const;
  void clear_old_pid() ;
  ::int32_t old_pid() const;
  void set_old_pid(::int32_t value);

  private:
  ::int32_t _internal_old_pid() const;
  void _internal_set_old_pid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessExecFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::int32_t pid_;
    ::int32_t old_pid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedProcessExitFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessExitFtraceEvent) */ {
 public:
  inline SchedProcessExitFtraceEvent() : SchedProcessExitFtraceEvent(nullptr) {}
  ~SchedProcessExitFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedProcessExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent& from);
  SchedProcessExitFtraceEvent(SchedProcessExitFtraceEvent&& from) noexcept
    : SchedProcessExitFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessExitFtraceEvent& operator=(const SchedProcessExitFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessExitFtraceEvent& operator=(SchedProcessExitFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedProcessExitFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessExitFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessExitFtraceEvent*>(
               &_SchedProcessExitFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SchedProcessExitFtraceEvent& a, SchedProcessExitFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessExitFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessExitFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessExitFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessExitFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedProcessExitFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedProcessExitFtraceEvent& from) {
    SchedProcessExitFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedProcessExitFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedProcessExitFtraceEvent";
  }
  protected:
  explicit SchedProcessExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kTgidFieldNumber = 3,
    kPrioFieldNumber = 4,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // optional int32 tgid = 3;
  bool has_tgid() const;
  void clear_tgid() ;
  ::int32_t tgid() const;
  void set_tgid(::int32_t value);

  private:
  ::int32_t _internal_tgid() const;
  void _internal_set_tgid(::int32_t value);

  public:
  // optional int32 prio = 4;
  bool has_prio() const;
  void clear_prio() ;
  ::int32_t prio() const;
  void set_prio(::int32_t value);

  private:
  ::int32_t _internal_prio() const;
  void _internal_set_prio(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessExitFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::int32_t pid_;
    ::int32_t tgid_;
    ::int32_t prio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedProcessForkFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessForkFtraceEvent) */ {
 public:
  inline SchedProcessForkFtraceEvent() : SchedProcessForkFtraceEvent(nullptr) {}
  ~SchedProcessForkFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedProcessForkFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent& from);
  SchedProcessForkFtraceEvent(SchedProcessForkFtraceEvent&& from) noexcept
    : SchedProcessForkFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessForkFtraceEvent& operator=(const SchedProcessForkFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessForkFtraceEvent& operator=(SchedProcessForkFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedProcessForkFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessForkFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessForkFtraceEvent*>(
               &_SchedProcessForkFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SchedProcessForkFtraceEvent& a, SchedProcessForkFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessForkFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessForkFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessForkFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessForkFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedProcessForkFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedProcessForkFtraceEvent& from) {
    SchedProcessForkFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedProcessForkFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedProcessForkFtraceEvent";
  }
  protected:
  explicit SchedProcessForkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentCommFieldNumber = 1,
    kChildCommFieldNumber = 3,
    kParentPidFieldNumber = 2,
    kChildPidFieldNumber = 4,
  };
  // optional string parent_comm = 1;
  bool has_parent_comm() const;
  void clear_parent_comm() ;
  const std::string& parent_comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_comm(Arg_&& arg, Args_... args);
  std::string* mutable_parent_comm();
  PROTOBUF_NODISCARD std::string* release_parent_comm();
  void set_allocated_parent_comm(std::string* ptr);

  private:
  const std::string& _internal_parent_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_comm(
      const std::string& value);
  std::string* _internal_mutable_parent_comm();

  public:
  // optional string child_comm = 3;
  bool has_child_comm() const;
  void clear_child_comm() ;
  const std::string& child_comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_child_comm(Arg_&& arg, Args_... args);
  std::string* mutable_child_comm();
  PROTOBUF_NODISCARD std::string* release_child_comm();
  void set_allocated_child_comm(std::string* ptr);

  private:
  const std::string& _internal_child_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_child_comm(
      const std::string& value);
  std::string* _internal_mutable_child_comm();

  public:
  // optional int32 parent_pid = 2;
  bool has_parent_pid() const;
  void clear_parent_pid() ;
  ::int32_t parent_pid() const;
  void set_parent_pid(::int32_t value);

  private:
  ::int32_t _internal_parent_pid() const;
  void _internal_set_parent_pid(::int32_t value);

  public:
  // optional int32 child_pid = 4;
  bool has_child_pid() const;
  void clear_child_pid() ;
  ::int32_t child_pid() const;
  void set_child_pid(::int32_t value);

  private:
  ::int32_t _internal_child_pid() const;
  void _internal_set_child_pid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessForkFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_comm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_comm_;
    ::int32_t parent_pid_;
    ::int32_t child_pid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedProcessFreeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessFreeFtraceEvent) */ {
 public:
  inline SchedProcessFreeFtraceEvent() : SchedProcessFreeFtraceEvent(nullptr) {}
  ~SchedProcessFreeFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedProcessFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent& from);
  SchedProcessFreeFtraceEvent(SchedProcessFreeFtraceEvent&& from) noexcept
    : SchedProcessFreeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessFreeFtraceEvent& operator=(const SchedProcessFreeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessFreeFtraceEvent& operator=(SchedProcessFreeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedProcessFreeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessFreeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessFreeFtraceEvent*>(
               &_SchedProcessFreeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SchedProcessFreeFtraceEvent& a, SchedProcessFreeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessFreeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessFreeFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessFreeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessFreeFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedProcessFreeFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedProcessFreeFtraceEvent& from) {
    SchedProcessFreeFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedProcessFreeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedProcessFreeFtraceEvent";
  }
  protected:
  explicit SchedProcessFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio() ;
  ::int32_t prio() const;
  void set_prio(::int32_t value);

  private:
  ::int32_t _internal_prio() const;
  void _internal_set_prio(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessFreeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::int32_t pid_;
    ::int32_t prio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedProcessHangFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessHangFtraceEvent) */ {
 public:
  inline SchedProcessHangFtraceEvent() : SchedProcessHangFtraceEvent(nullptr) {}
  ~SchedProcessHangFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedProcessHangFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent& from);
  SchedProcessHangFtraceEvent(SchedProcessHangFtraceEvent&& from) noexcept
    : SchedProcessHangFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessHangFtraceEvent& operator=(const SchedProcessHangFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessHangFtraceEvent& operator=(SchedProcessHangFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedProcessHangFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessHangFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessHangFtraceEvent*>(
               &_SchedProcessHangFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SchedProcessHangFtraceEvent& a, SchedProcessHangFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessHangFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessHangFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessHangFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessHangFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedProcessHangFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedProcessHangFtraceEvent& from) {
    SchedProcessHangFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedProcessHangFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedProcessHangFtraceEvent";
  }
  protected:
  explicit SchedProcessHangFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessHangFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::int32_t pid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedProcessWaitFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessWaitFtraceEvent) */ {
 public:
  inline SchedProcessWaitFtraceEvent() : SchedProcessWaitFtraceEvent(nullptr) {}
  ~SchedProcessWaitFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedProcessWaitFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent& from);
  SchedProcessWaitFtraceEvent(SchedProcessWaitFtraceEvent&& from) noexcept
    : SchedProcessWaitFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessWaitFtraceEvent& operator=(const SchedProcessWaitFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessWaitFtraceEvent& operator=(SchedProcessWaitFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedProcessWaitFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessWaitFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessWaitFtraceEvent*>(
               &_SchedProcessWaitFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SchedProcessWaitFtraceEvent& a, SchedProcessWaitFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedProcessWaitFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessWaitFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessWaitFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessWaitFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedProcessWaitFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedProcessWaitFtraceEvent& from) {
    SchedProcessWaitFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedProcessWaitFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedProcessWaitFtraceEvent";
  }
  protected:
  explicit SchedProcessWaitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional int32 pid = 2;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // optional int32 prio = 3;
  bool has_prio() const;
  void clear_prio() ;
  ::int32_t prio() const;
  void set_prio(::int32_t value);

  private:
  ::int32_t _internal_prio() const;
  void _internal_set_prio(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessWaitFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::int32_t pid_;
    ::int32_t prio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedPiSetprioFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedPiSetprioFtraceEvent) */ {
 public:
  inline SchedPiSetprioFtraceEvent() : SchedPiSetprioFtraceEvent(nullptr) {}
  ~SchedPiSetprioFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedPiSetprioFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedPiSetprioFtraceEvent(const SchedPiSetprioFtraceEvent& from);
  SchedPiSetprioFtraceEvent(SchedPiSetprioFtraceEvent&& from) noexcept
    : SchedPiSetprioFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedPiSetprioFtraceEvent& operator=(const SchedPiSetprioFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedPiSetprioFtraceEvent& operator=(SchedPiSetprioFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedPiSetprioFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedPiSetprioFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedPiSetprioFtraceEvent*>(
               &_SchedPiSetprioFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SchedPiSetprioFtraceEvent& a, SchedPiSetprioFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedPiSetprioFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedPiSetprioFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedPiSetprioFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedPiSetprioFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedPiSetprioFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedPiSetprioFtraceEvent& from) {
    SchedPiSetprioFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedPiSetprioFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedPiSetprioFtraceEvent";
  }
  protected:
  explicit SchedPiSetprioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kNewprioFieldNumber = 2,
    kOldprioFieldNumber = 3,
    kPidFieldNumber = 4,
  };
  // optional string comm = 1;
  bool has_comm() const;
  void clear_comm() ;
  const std::string& comm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comm(Arg_&& arg, Args_... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* ptr);

  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(
      const std::string& value);
  std::string* _internal_mutable_comm();

  public:
  // optional int32 newprio = 2;
  bool has_newprio() const;
  void clear_newprio() ;
  ::int32_t newprio() const;
  void set_newprio(::int32_t value);

  private:
  ::int32_t _internal_newprio() const;
  void _internal_set_newprio(::int32_t value);

  public:
  // optional int32 oldprio = 3;
  bool has_oldprio() const;
  void clear_oldprio() ;
  ::int32_t oldprio() const;
  void set_oldprio(::int32_t value);

  private:
  ::int32_t _internal_oldprio() const;
  void _internal_set_oldprio(::int32_t value);

  public:
  // optional int32 pid = 4;
  bool has_pid() const;
  void clear_pid() ;
  ::int32_t pid() const;
  void set_pid(::int32_t value);

  private:
  ::int32_t _internal_pid() const;
  void _internal_set_pid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedPiSetprioFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    ::int32_t newprio_;
    ::int32_t oldprio_;
    ::int32_t pid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};// -------------------------------------------------------------------

class SchedCpuUtilCfsFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedCpuUtilCfsFtraceEvent) */ {
 public:
  inline SchedCpuUtilCfsFtraceEvent() : SchedCpuUtilCfsFtraceEvent(nullptr) {}
  ~SchedCpuUtilCfsFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SchedCpuUtilCfsFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedCpuUtilCfsFtraceEvent(const SchedCpuUtilCfsFtraceEvent& from);
  SchedCpuUtilCfsFtraceEvent(SchedCpuUtilCfsFtraceEvent&& from) noexcept
    : SchedCpuUtilCfsFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedCpuUtilCfsFtraceEvent& operator=(const SchedCpuUtilCfsFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedCpuUtilCfsFtraceEvent& operator=(SchedCpuUtilCfsFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedCpuUtilCfsFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedCpuUtilCfsFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedCpuUtilCfsFtraceEvent*>(
               &_SchedCpuUtilCfsFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SchedCpuUtilCfsFtraceEvent& a, SchedCpuUtilCfsFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedCpuUtilCfsFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedCpuUtilCfsFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedCpuUtilCfsFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedCpuUtilCfsFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedCpuUtilCfsFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedCpuUtilCfsFtraceEvent& from) {
    SchedCpuUtilCfsFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedCpuUtilCfsFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.SchedCpuUtilCfsFtraceEvent";
  }
  protected:
  explicit SchedCpuUtilCfsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityFieldNumber = 2,
    kActiveFieldNumber = 1,
    kCpuFieldNumber = 4,
    kCapacityOrigFieldNumber = 3,
    kCpuImportanceFieldNumber = 5,
    kCpuUtilFieldNumber = 6,
    kGroupCapacityFieldNumber = 8,
    kExitLatFieldNumber = 7,
    kGrpOverutilizedFieldNumber = 9,
    kIdleCpuFieldNumber = 10,
    kNrRunningFieldNumber = 11,
    kSpareCapFieldNumber = 12,
    kWakeGroupUtilFieldNumber = 14,
    kWakeUtilFieldNumber = 15,
    kTaskFitsFieldNumber = 13,
  };
  // optional uint64 capacity = 2;
  bool has_capacity() const;
  void clear_capacity() ;
  ::uint64_t capacity() const;
  void set_capacity(::uint64_t value);

  private:
  ::uint64_t _internal_capacity() const;
  void _internal_set_capacity(::uint64_t value);

  public:
  // optional int32 active = 1;
  bool has_active() const;
  void clear_active() ;
  ::int32_t active() const;
  void set_active(::int32_t value);

  private:
  ::int32_t _internal_active() const;
  void _internal_set_active(::int32_t value);

  public:
  // optional uint32 cpu = 4;
  bool has_cpu() const;
  void clear_cpu() ;
  ::uint32_t cpu() const;
  void set_cpu(::uint32_t value);

  private:
  ::uint32_t _internal_cpu() const;
  void _internal_set_cpu(::uint32_t value);

  public:
  // optional uint64 capacity_orig = 3;
  bool has_capacity_orig() const;
  void clear_capacity_orig() ;
  ::uint64_t capacity_orig() const;
  void set_capacity_orig(::uint64_t value);

  private:
  ::uint64_t _internal_capacity_orig() const;
  void _internal_set_capacity_orig(::uint64_t value);

  public:
  // optional uint64 cpu_importance = 5;
  bool has_cpu_importance() const;
  void clear_cpu_importance() ;
  ::uint64_t cpu_importance() const;
  void set_cpu_importance(::uint64_t value);

  private:
  ::uint64_t _internal_cpu_importance() const;
  void _internal_set_cpu_importance(::uint64_t value);

  public:
  // optional uint64 cpu_util = 6;
  bool has_cpu_util() const;
  void clear_cpu_util() ;
  ::uint64_t cpu_util() const;
  void set_cpu_util(::uint64_t value);

  private:
  ::uint64_t _internal_cpu_util() const;
  void _internal_set_cpu_util(::uint64_t value);

  public:
  // optional uint64 group_capacity = 8;
  bool has_group_capacity() const;
  void clear_group_capacity() ;
  ::uint64_t group_capacity() const;
  void set_group_capacity(::uint64_t value);

  private:
  ::uint64_t _internal_group_capacity() const;
  void _internal_set_group_capacity(::uint64_t value);

  public:
  // optional uint32 exit_lat = 7;
  bool has_exit_lat() const;
  void clear_exit_lat() ;
  ::uint32_t exit_lat() const;
  void set_exit_lat(::uint32_t value);

  private:
  ::uint32_t _internal_exit_lat() const;
  void _internal_set_exit_lat(::uint32_t value);

  public:
  // optional uint32 grp_overutilized = 9;
  bool has_grp_overutilized() const;
  void clear_grp_overutilized() ;
  ::uint32_t grp_overutilized() const;
  void set_grp_overutilized(::uint32_t value);

  private:
  ::uint32_t _internal_grp_overutilized() const;
  void _internal_set_grp_overutilized(::uint32_t value);

  public:
  // optional uint32 idle_cpu = 10;
  bool has_idle_cpu() const;
  void clear_idle_cpu() ;
  ::uint32_t idle_cpu() const;
  void set_idle_cpu(::uint32_t value);

  private:
  ::uint32_t _internal_idle_cpu() const;
  void _internal_set_idle_cpu(::uint32_t value);

  public:
  // optional uint32 nr_running = 11;
  bool has_nr_running() const;
  void clear_nr_running() ;
  ::uint32_t nr_running() const;
  void set_nr_running(::uint32_t value);

  private:
  ::uint32_t _internal_nr_running() const;
  void _internal_set_nr_running(::uint32_t value);

  public:
  // optional int64 spare_cap = 12;
  bool has_spare_cap() const;
  void clear_spare_cap() ;
  ::int64_t spare_cap() const;
  void set_spare_cap(::int64_t value);

  private:
  ::int64_t _internal_spare_cap() const;
  void _internal_set_spare_cap(::int64_t value);

  public:
  // optional uint64 wake_group_util = 14;
  bool has_wake_group_util() const;
  void clear_wake_group_util() ;
  ::uint64_t wake_group_util() const;
  void set_wake_group_util(::uint64_t value);

  private:
  ::uint64_t _internal_wake_group_util() const;
  void _internal_set_wake_group_util(::uint64_t value);

  public:
  // optional uint64 wake_util = 15;
  bool has_wake_util() const;
  void clear_wake_util() ;
  ::uint64_t wake_util() const;
  void set_wake_util(::uint64_t value);

  private:
  ::uint64_t _internal_wake_util() const;
  void _internal_set_wake_util(::uint64_t value);

  public:
  // optional uint32 task_fits = 13;
  bool has_task_fits() const;
  void clear_task_fits() ;
  ::uint32_t task_fits() const;
  void set_task_fits(::uint32_t value);

  private:
  ::uint32_t _internal_task_fits() const;
  void _internal_set_task_fits(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t capacity_;
    ::int32_t active_;
    ::uint32_t cpu_;
    ::uint64_t capacity_orig_;
    ::uint64_t cpu_importance_;
    ::uint64_t cpu_util_;
    ::uint64_t group_capacity_;
    ::uint32_t exit_lat_;
    ::uint32_t grp_overutilized_;
    ::uint32_t idle_cpu_;
    ::uint32_t nr_running_;
    ::int64_t spare_cap_;
    ::uint64_t wake_group_util_;
    ::uint64_t wake_util_;
    ::uint32_t task_fits_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SchedSwitchFtraceEvent

// optional string prev_comm = 1;
inline bool SchedSwitchFtraceEvent::has_prev_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedSwitchFtraceEvent::clear_prev_comm() {
  _impl_.prev_comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedSwitchFtraceEvent::prev_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
  return _internal_prev_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedSwitchFtraceEvent::set_prev_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prev_comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
}
inline std::string* SchedSwitchFtraceEvent::mutable_prev_comm() {
  std::string* _s = _internal_mutable_prev_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
  return _s;
}
inline const std::string& SchedSwitchFtraceEvent::_internal_prev_comm() const {
  return _impl_.prev_comm_.Get();
}
inline void SchedSwitchFtraceEvent::_internal_set_prev_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.prev_comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedSwitchFtraceEvent::_internal_mutable_prev_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.prev_comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedSwitchFtraceEvent::release_prev_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.prev_comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prev_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedSwitchFtraceEvent::set_allocated_prev_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prev_comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prev_comm_.IsDefault()) {
          _impl_.prev_comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
}

// optional int32 prev_pid = 2;
inline bool SchedSwitchFtraceEvent::has_prev_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedSwitchFtraceEvent::clear_prev_pid() {
  _impl_.prev_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedSwitchFtraceEvent::prev_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_pid)
  return _internal_prev_pid();
}
inline void SchedSwitchFtraceEvent::set_prev_pid(::int32_t value) {
  _internal_set_prev_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_pid)
}
inline ::int32_t SchedSwitchFtraceEvent::_internal_prev_pid() const {
  return _impl_.prev_pid_;
}
inline void SchedSwitchFtraceEvent::_internal_set_prev_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prev_pid_ = value;
}

// optional int32 prev_prio = 3;
inline bool SchedSwitchFtraceEvent::has_prev_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchedSwitchFtraceEvent::clear_prev_prio() {
  _impl_.prev_prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SchedSwitchFtraceEvent::prev_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_prio)
  return _internal_prev_prio();
}
inline void SchedSwitchFtraceEvent::set_prev_prio(::int32_t value) {
  _internal_set_prev_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_prio)
}
inline ::int32_t SchedSwitchFtraceEvent::_internal_prev_prio() const {
  return _impl_.prev_prio_;
}
inline void SchedSwitchFtraceEvent::_internal_set_prev_prio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prev_prio_ = value;
}

// optional int64 prev_state = 4;
inline bool SchedSwitchFtraceEvent::has_prev_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchedSwitchFtraceEvent::clear_prev_state() {
  _impl_.prev_state_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SchedSwitchFtraceEvent::prev_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_state)
  return _internal_prev_state();
}
inline void SchedSwitchFtraceEvent::set_prev_state(::int64_t value) {
  _internal_set_prev_state(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_state)
}
inline ::int64_t SchedSwitchFtraceEvent::_internal_prev_state() const {
  return _impl_.prev_state_;
}
inline void SchedSwitchFtraceEvent::_internal_set_prev_state(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.prev_state_ = value;
}

// optional string next_comm = 5;
inline bool SchedSwitchFtraceEvent::has_next_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedSwitchFtraceEvent::clear_next_comm() {
  _impl_.next_comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchedSwitchFtraceEvent::next_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
  return _internal_next_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedSwitchFtraceEvent::set_next_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.next_comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
}
inline std::string* SchedSwitchFtraceEvent::mutable_next_comm() {
  std::string* _s = _internal_mutable_next_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
  return _s;
}
inline const std::string& SchedSwitchFtraceEvent::_internal_next_comm() const {
  return _impl_.next_comm_.Get();
}
inline void SchedSwitchFtraceEvent::_internal_set_next_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.next_comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedSwitchFtraceEvent::_internal_mutable_next_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.next_comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedSwitchFtraceEvent::release_next_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.next_comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.next_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedSwitchFtraceEvent::set_allocated_next_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.next_comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_comm_.IsDefault()) {
          _impl_.next_comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
}

// optional int32 next_pid = 6;
inline bool SchedSwitchFtraceEvent::has_next_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SchedSwitchFtraceEvent::clear_next_pid() {
  _impl_.next_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t SchedSwitchFtraceEvent::next_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.next_pid)
  return _internal_next_pid();
}
inline void SchedSwitchFtraceEvent::set_next_pid(::int32_t value) {
  _internal_set_next_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.next_pid)
}
inline ::int32_t SchedSwitchFtraceEvent::_internal_next_pid() const {
  return _impl_.next_pid_;
}
inline void SchedSwitchFtraceEvent::_internal_set_next_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.next_pid_ = value;
}

// optional int32 next_prio = 7;
inline bool SchedSwitchFtraceEvent::has_next_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SchedSwitchFtraceEvent::clear_next_prio() {
  _impl_.next_prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t SchedSwitchFtraceEvent::next_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.next_prio)
  return _internal_next_prio();
}
inline void SchedSwitchFtraceEvent::set_next_prio(::int32_t value) {
  _internal_set_next_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.next_prio)
}
inline ::int32_t SchedSwitchFtraceEvent::_internal_next_prio() const {
  return _impl_.next_prio_;
}
inline void SchedSwitchFtraceEvent::_internal_set_next_prio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.next_prio_ = value;
}

// -------------------------------------------------------------------

// SchedWakeupFtraceEvent

// optional string comm = 1;
inline bool SchedWakeupFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedWakeupFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedWakeupFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedWakeupFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.comm)
}
inline std::string* SchedWakeupFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedWakeupFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedWakeupFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedWakeupFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedWakeupFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedWakeupFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedWakeupFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedWakeupFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedWakeupFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedWakeupFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedWakeupFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedWakeupFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedWakeupFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.pid)
}
inline ::int32_t SchedWakeupFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedWakeupFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}

// optional int32 prio = 3;
inline bool SchedWakeupFtraceEvent::has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedWakeupFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedWakeupFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedWakeupFtraceEvent::set_prio(::int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.prio)
}
inline ::int32_t SchedWakeupFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline void SchedWakeupFtraceEvent::_internal_set_prio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}

// optional int32 success = 4;
inline bool SchedWakeupFtraceEvent::has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchedWakeupFtraceEvent::clear_success() {
  _impl_.success_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SchedWakeupFtraceEvent::success() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.success)
  return _internal_success();
}
inline void SchedWakeupFtraceEvent::set_success(::int32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.success)
}
inline ::int32_t SchedWakeupFtraceEvent::_internal_success() const {
  return _impl_.success_;
}
inline void SchedWakeupFtraceEvent::_internal_set_success(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.success_ = value;
}

// optional int32 target_cpu = 5;
inline bool SchedWakeupFtraceEvent::has_target_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchedWakeupFtraceEvent::clear_target_cpu() {
  _impl_.target_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SchedWakeupFtraceEvent::target_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.target_cpu)
  return _internal_target_cpu();
}
inline void SchedWakeupFtraceEvent::set_target_cpu(::int32_t value) {
  _internal_set_target_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.target_cpu)
}
inline ::int32_t SchedWakeupFtraceEvent::_internal_target_cpu() const {
  return _impl_.target_cpu_;
}
inline void SchedWakeupFtraceEvent::_internal_set_target_cpu(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.target_cpu_ = value;
}

// -------------------------------------------------------------------

// SchedBlockedReasonFtraceEvent

// optional int32 pid = 1;
inline bool SchedBlockedReasonFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedBlockedReasonFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedBlockedReasonFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedBlockedReasonFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedBlockedReasonFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedBlockedReasonFtraceEvent.pid)
}
inline ::int32_t SchedBlockedReasonFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedBlockedReasonFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}

// optional uint64 caller = 2;
inline bool SchedBlockedReasonFtraceEvent::has_caller() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedBlockedReasonFtraceEvent::clear_caller() {
  _impl_.caller_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t SchedBlockedReasonFtraceEvent::caller() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedBlockedReasonFtraceEvent.caller)
  return _internal_caller();
}
inline void SchedBlockedReasonFtraceEvent::set_caller(::uint64_t value) {
  _internal_set_caller(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedBlockedReasonFtraceEvent.caller)
}
inline ::uint64_t SchedBlockedReasonFtraceEvent::_internal_caller() const {
  return _impl_.caller_;
}
inline void SchedBlockedReasonFtraceEvent::_internal_set_caller(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.caller_ = value;
}

// optional uint32 io_wait = 3;
inline bool SchedBlockedReasonFtraceEvent::has_io_wait() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedBlockedReasonFtraceEvent::clear_io_wait() {
  _impl_.io_wait_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t SchedBlockedReasonFtraceEvent::io_wait() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedBlockedReasonFtraceEvent.io_wait)
  return _internal_io_wait();
}
inline void SchedBlockedReasonFtraceEvent::set_io_wait(::uint32_t value) {
  _internal_set_io_wait(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedBlockedReasonFtraceEvent.io_wait)
}
inline ::uint32_t SchedBlockedReasonFtraceEvent::_internal_io_wait() const {
  return _impl_.io_wait_;
}
inline void SchedBlockedReasonFtraceEvent::_internal_set_io_wait(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.io_wait_ = value;
}

// -------------------------------------------------------------------

// SchedCpuHotplugFtraceEvent

// optional int32 affected_cpu = 1;
inline bool SchedCpuHotplugFtraceEvent::has_affected_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedCpuHotplugFtraceEvent::clear_affected_cpu() {
  _impl_.affected_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SchedCpuHotplugFtraceEvent::affected_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuHotplugFtraceEvent.affected_cpu)
  return _internal_affected_cpu();
}
inline void SchedCpuHotplugFtraceEvent::set_affected_cpu(::int32_t value) {
  _internal_set_affected_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuHotplugFtraceEvent.affected_cpu)
}
inline ::int32_t SchedCpuHotplugFtraceEvent::_internal_affected_cpu() const {
  return _impl_.affected_cpu_;
}
inline void SchedCpuHotplugFtraceEvent::_internal_set_affected_cpu(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.affected_cpu_ = value;
}

// optional int32 error = 2;
inline bool SchedCpuHotplugFtraceEvent::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedCpuHotplugFtraceEvent::clear_error() {
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedCpuHotplugFtraceEvent::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuHotplugFtraceEvent.error)
  return _internal_error();
}
inline void SchedCpuHotplugFtraceEvent::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuHotplugFtraceEvent.error)
}
inline ::int32_t SchedCpuHotplugFtraceEvent::_internal_error() const {
  return _impl_.error_;
}
inline void SchedCpuHotplugFtraceEvent::_internal_set_error(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_ = value;
}

// optional int32 status = 3;
inline bool SchedCpuHotplugFtraceEvent::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedCpuHotplugFtraceEvent::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedCpuHotplugFtraceEvent::status() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuHotplugFtraceEvent.status)
  return _internal_status();
}
inline void SchedCpuHotplugFtraceEvent::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuHotplugFtraceEvent.status)
}
inline ::int32_t SchedCpuHotplugFtraceEvent::_internal_status() const {
  return _impl_.status_;
}
inline void SchedCpuHotplugFtraceEvent::_internal_set_status(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// SchedWakingFtraceEvent

// optional string comm = 1;
inline bool SchedWakingFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedWakingFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedWakingFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedWakingFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.comm)
}
inline std::string* SchedWakingFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedWakingFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedWakingFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedWakingFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedWakingFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedWakingFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedWakingFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedWakingFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedWakingFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedWakingFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedWakingFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedWakingFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedWakingFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.pid)
}
inline ::int32_t SchedWakingFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedWakingFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}

// optional int32 prio = 3;
inline bool SchedWakingFtraceEvent::has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedWakingFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedWakingFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedWakingFtraceEvent::set_prio(::int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.prio)
}
inline ::int32_t SchedWakingFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline void SchedWakingFtraceEvent::_internal_set_prio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}

// optional int32 success = 4;
inline bool SchedWakingFtraceEvent::has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchedWakingFtraceEvent::clear_success() {
  _impl_.success_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SchedWakingFtraceEvent::success() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.success)
  return _internal_success();
}
inline void SchedWakingFtraceEvent::set_success(::int32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.success)
}
inline ::int32_t SchedWakingFtraceEvent::_internal_success() const {
  return _impl_.success_;
}
inline void SchedWakingFtraceEvent::_internal_set_success(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.success_ = value;
}

// optional int32 target_cpu = 5;
inline bool SchedWakingFtraceEvent::has_target_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchedWakingFtraceEvent::clear_target_cpu() {
  _impl_.target_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SchedWakingFtraceEvent::target_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.target_cpu)
  return _internal_target_cpu();
}
inline void SchedWakingFtraceEvent::set_target_cpu(::int32_t value) {
  _internal_set_target_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.target_cpu)
}
inline ::int32_t SchedWakingFtraceEvent::_internal_target_cpu() const {
  return _impl_.target_cpu_;
}
inline void SchedWakingFtraceEvent::_internal_set_target_cpu(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.target_cpu_ = value;
}

// -------------------------------------------------------------------

// SchedWakeupNewFtraceEvent

// optional string comm = 1;
inline bool SchedWakeupNewFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedWakeupNewFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedWakeupNewFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedWakeupNewFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
}
inline std::string* SchedWakeupNewFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedWakeupNewFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedWakeupNewFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedWakeupNewFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedWakeupNewFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedWakeupNewFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedWakeupNewFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedWakeupNewFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedWakeupNewFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedWakeupNewFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.pid)
}
inline ::int32_t SchedWakeupNewFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedWakeupNewFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}

// optional int32 prio = 3;
inline bool SchedWakeupNewFtraceEvent::has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedWakeupNewFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedWakeupNewFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedWakeupNewFtraceEvent::set_prio(::int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.prio)
}
inline ::int32_t SchedWakeupNewFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline void SchedWakeupNewFtraceEvent::_internal_set_prio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}

// optional int32 success = 4;
inline bool SchedWakeupNewFtraceEvent::has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchedWakeupNewFtraceEvent::clear_success() {
  _impl_.success_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SchedWakeupNewFtraceEvent::success() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.success)
  return _internal_success();
}
inline void SchedWakeupNewFtraceEvent::set_success(::int32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.success)
}
inline ::int32_t SchedWakeupNewFtraceEvent::_internal_success() const {
  return _impl_.success_;
}
inline void SchedWakeupNewFtraceEvent::_internal_set_success(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.success_ = value;
}

// optional int32 target_cpu = 5;
inline bool SchedWakeupNewFtraceEvent::has_target_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchedWakeupNewFtraceEvent::clear_target_cpu() {
  _impl_.target_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SchedWakeupNewFtraceEvent::target_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.target_cpu)
  return _internal_target_cpu();
}
inline void SchedWakeupNewFtraceEvent::set_target_cpu(::int32_t value) {
  _internal_set_target_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.target_cpu)
}
inline ::int32_t SchedWakeupNewFtraceEvent::_internal_target_cpu() const {
  return _impl_.target_cpu_;
}
inline void SchedWakeupNewFtraceEvent::_internal_set_target_cpu(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.target_cpu_ = value;
}

// -------------------------------------------------------------------

// SchedProcessExecFtraceEvent

// optional string filename = 1;
inline bool SchedProcessExecFtraceEvent::has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedProcessExecFtraceEvent::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessExecFtraceEvent::filename() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExecFtraceEvent.filename)
  return _internal_filename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedProcessExecFtraceEvent::set_filename(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExecFtraceEvent.filename)
}
inline std::string* SchedProcessExecFtraceEvent::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessExecFtraceEvent.filename)
  return _s;
}
inline const std::string& SchedProcessExecFtraceEvent::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void SchedProcessExecFtraceEvent::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessExecFtraceEvent::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedProcessExecFtraceEvent::release_filename() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessExecFtraceEvent.filename)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filename_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedProcessExecFtraceEvent::set_allocated_filename(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filename_.IsDefault()) {
          _impl_.filename_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessExecFtraceEvent.filename)
}

// optional int32 pid = 2;
inline bool SchedProcessExecFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedProcessExecFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedProcessExecFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExecFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessExecFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExecFtraceEvent.pid)
}
inline ::int32_t SchedProcessExecFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedProcessExecFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}

// optional int32 old_pid = 3;
inline bool SchedProcessExecFtraceEvent::has_old_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedProcessExecFtraceEvent::clear_old_pid() {
  _impl_.old_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedProcessExecFtraceEvent::old_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExecFtraceEvent.old_pid)
  return _internal_old_pid();
}
inline void SchedProcessExecFtraceEvent::set_old_pid(::int32_t value) {
  _internal_set_old_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExecFtraceEvent.old_pid)
}
inline ::int32_t SchedProcessExecFtraceEvent::_internal_old_pid() const {
  return _impl_.old_pid_;
}
inline void SchedProcessExecFtraceEvent::_internal_set_old_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.old_pid_ = value;
}

// -------------------------------------------------------------------

// SchedProcessExitFtraceEvent

// optional string comm = 1;
inline bool SchedProcessExitFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedProcessExitFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessExitFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedProcessExitFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.comm)
}
inline std::string* SchedProcessExitFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessExitFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedProcessExitFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedProcessExitFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessExitFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedProcessExitFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessExitFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedProcessExitFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessExitFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessExitFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedProcessExitFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedProcessExitFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessExitFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.pid)
}
inline ::int32_t SchedProcessExitFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedProcessExitFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}

// optional int32 tgid = 3;
inline bool SchedProcessExitFtraceEvent::has_tgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedProcessExitFtraceEvent::clear_tgid() {
  _impl_.tgid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedProcessExitFtraceEvent::tgid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.tgid)
  return _internal_tgid();
}
inline void SchedProcessExitFtraceEvent::set_tgid(::int32_t value) {
  _internal_set_tgid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.tgid)
}
inline ::int32_t SchedProcessExitFtraceEvent::_internal_tgid() const {
  return _impl_.tgid_;
}
inline void SchedProcessExitFtraceEvent::_internal_set_tgid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tgid_ = value;
}

// optional int32 prio = 4;
inline bool SchedProcessExitFtraceEvent::has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchedProcessExitFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SchedProcessExitFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedProcessExitFtraceEvent::set_prio(::int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.prio)
}
inline ::int32_t SchedProcessExitFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline void SchedProcessExitFtraceEvent::_internal_set_prio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prio_ = value;
}

// -------------------------------------------------------------------

// SchedProcessForkFtraceEvent

// optional string parent_comm = 1;
inline bool SchedProcessForkFtraceEvent::has_parent_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedProcessForkFtraceEvent::clear_parent_comm() {
  _impl_.parent_comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessForkFtraceEvent::parent_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
  return _internal_parent_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedProcessForkFtraceEvent::set_parent_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parent_comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
}
inline std::string* SchedProcessForkFtraceEvent::mutable_parent_comm() {
  std::string* _s = _internal_mutable_parent_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
  return _s;
}
inline const std::string& SchedProcessForkFtraceEvent::_internal_parent_comm() const {
  return _impl_.parent_comm_.Get();
}
inline void SchedProcessForkFtraceEvent::_internal_set_parent_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.parent_comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessForkFtraceEvent::_internal_mutable_parent_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.parent_comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedProcessForkFtraceEvent::release_parent_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.parent_comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedProcessForkFtraceEvent::set_allocated_parent_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_comm_.IsDefault()) {
          _impl_.parent_comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
}

// optional int32 parent_pid = 2;
inline bool SchedProcessForkFtraceEvent::has_parent_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedProcessForkFtraceEvent::clear_parent_pid() {
  _impl_.parent_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedProcessForkFtraceEvent::parent_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.parent_pid)
  return _internal_parent_pid();
}
inline void SchedProcessForkFtraceEvent::set_parent_pid(::int32_t value) {
  _internal_set_parent_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.parent_pid)
}
inline ::int32_t SchedProcessForkFtraceEvent::_internal_parent_pid() const {
  return _impl_.parent_pid_;
}
inline void SchedProcessForkFtraceEvent::_internal_set_parent_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parent_pid_ = value;
}

// optional string child_comm = 3;
inline bool SchedProcessForkFtraceEvent::has_child_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedProcessForkFtraceEvent::clear_child_comm() {
  _impl_.child_comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchedProcessForkFtraceEvent::child_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
  return _internal_child_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedProcessForkFtraceEvent::set_child_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.child_comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
}
inline std::string* SchedProcessForkFtraceEvent::mutable_child_comm() {
  std::string* _s = _internal_mutable_child_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
  return _s;
}
inline const std::string& SchedProcessForkFtraceEvent::_internal_child_comm() const {
  return _impl_.child_comm_.Get();
}
inline void SchedProcessForkFtraceEvent::_internal_set_child_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.child_comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessForkFtraceEvent::_internal_mutable_child_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.child_comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedProcessForkFtraceEvent::release_child_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.child_comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.child_comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedProcessForkFtraceEvent::set_allocated_child_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.child_comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.child_comm_.IsDefault()) {
          _impl_.child_comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
}

// optional int32 child_pid = 4;
inline bool SchedProcessForkFtraceEvent::has_child_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchedProcessForkFtraceEvent::clear_child_pid() {
  _impl_.child_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SchedProcessForkFtraceEvent::child_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.child_pid)
  return _internal_child_pid();
}
inline void SchedProcessForkFtraceEvent::set_child_pid(::int32_t value) {
  _internal_set_child_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.child_pid)
}
inline ::int32_t SchedProcessForkFtraceEvent::_internal_child_pid() const {
  return _impl_.child_pid_;
}
inline void SchedProcessForkFtraceEvent::_internal_set_child_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.child_pid_ = value;
}

// -------------------------------------------------------------------

// SchedProcessFreeFtraceEvent

// optional string comm = 1;
inline bool SchedProcessFreeFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedProcessFreeFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessFreeFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedProcessFreeFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
}
inline std::string* SchedProcessFreeFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedProcessFreeFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedProcessFreeFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessFreeFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedProcessFreeFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedProcessFreeFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessFreeFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedProcessFreeFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedProcessFreeFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessFreeFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessFreeFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessFreeFtraceEvent.pid)
}
inline ::int32_t SchedProcessFreeFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedProcessFreeFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}

// optional int32 prio = 3;
inline bool SchedProcessFreeFtraceEvent::has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedProcessFreeFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedProcessFreeFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessFreeFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedProcessFreeFtraceEvent::set_prio(::int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessFreeFtraceEvent.prio)
}
inline ::int32_t SchedProcessFreeFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline void SchedProcessFreeFtraceEvent::_internal_set_prio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}

// -------------------------------------------------------------------

// SchedProcessHangFtraceEvent

// optional string comm = 1;
inline bool SchedProcessHangFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedProcessHangFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessHangFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessHangFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedProcessHangFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessHangFtraceEvent.comm)
}
inline std::string* SchedProcessHangFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessHangFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedProcessHangFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedProcessHangFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessHangFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedProcessHangFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessHangFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedProcessHangFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessHangFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessHangFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedProcessHangFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedProcessHangFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessHangFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessHangFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessHangFtraceEvent.pid)
}
inline ::int32_t SchedProcessHangFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedProcessHangFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}

// -------------------------------------------------------------------

// SchedProcessWaitFtraceEvent

// optional string comm = 1;
inline bool SchedProcessWaitFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedProcessWaitFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessWaitFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedProcessWaitFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
}
inline std::string* SchedProcessWaitFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedProcessWaitFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedProcessWaitFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessWaitFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedProcessWaitFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedProcessWaitFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessWaitFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedProcessWaitFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedProcessWaitFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessWaitFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessWaitFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessWaitFtraceEvent.pid)
}
inline ::int32_t SchedProcessWaitFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedProcessWaitFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}

// optional int32 prio = 3;
inline bool SchedProcessWaitFtraceEvent::has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedProcessWaitFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedProcessWaitFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessWaitFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedProcessWaitFtraceEvent::set_prio(::int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessWaitFtraceEvent.prio)
}
inline ::int32_t SchedProcessWaitFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline void SchedProcessWaitFtraceEvent::_internal_set_prio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}

// -------------------------------------------------------------------

// SchedPiSetprioFtraceEvent

// optional string comm = 1;
inline bool SchedPiSetprioFtraceEvent::has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedPiSetprioFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedPiSetprioFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
  return _internal_comm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchedPiSetprioFtraceEvent::set_comm(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
}
inline std::string* SchedPiSetprioFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedPiSetprioFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedPiSetprioFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedPiSetprioFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable( GetArenaForAllocation());
}
inline std::string* SchedPiSetprioFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.comm_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comm_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchedPiSetprioFtraceEvent::set_allocated_comm(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comm_.IsDefault()) {
          _impl_.comm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
}

// optional int32 newprio = 2;
inline bool SchedPiSetprioFtraceEvent::has_newprio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedPiSetprioFtraceEvent::clear_newprio() {
  _impl_.newprio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedPiSetprioFtraceEvent::newprio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedPiSetprioFtraceEvent.newprio)
  return _internal_newprio();
}
inline void SchedPiSetprioFtraceEvent::set_newprio(::int32_t value) {
  _internal_set_newprio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedPiSetprioFtraceEvent.newprio)
}
inline ::int32_t SchedPiSetprioFtraceEvent::_internal_newprio() const {
  return _impl_.newprio_;
}
inline void SchedPiSetprioFtraceEvent::_internal_set_newprio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.newprio_ = value;
}

// optional int32 oldprio = 3;
inline bool SchedPiSetprioFtraceEvent::has_oldprio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedPiSetprioFtraceEvent::clear_oldprio() {
  _impl_.oldprio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SchedPiSetprioFtraceEvent::oldprio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedPiSetprioFtraceEvent.oldprio)
  return _internal_oldprio();
}
inline void SchedPiSetprioFtraceEvent::set_oldprio(::int32_t value) {
  _internal_set_oldprio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedPiSetprioFtraceEvent.oldprio)
}
inline ::int32_t SchedPiSetprioFtraceEvent::_internal_oldprio() const {
  return _impl_.oldprio_;
}
inline void SchedPiSetprioFtraceEvent::_internal_set_oldprio(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.oldprio_ = value;
}

// optional int32 pid = 4;
inline bool SchedPiSetprioFtraceEvent::has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchedPiSetprioFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SchedPiSetprioFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedPiSetprioFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedPiSetprioFtraceEvent::set_pid(::int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedPiSetprioFtraceEvent.pid)
}
inline ::int32_t SchedPiSetprioFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline void SchedPiSetprioFtraceEvent::_internal_set_pid(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pid_ = value;
}

// -------------------------------------------------------------------

// SchedCpuUtilCfsFtraceEvent

// optional int32 active = 1;
inline bool SchedCpuUtilCfsFtraceEvent::has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_active() {
  _impl_.active_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SchedCpuUtilCfsFtraceEvent::active() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.active)
  return _internal_active();
}
inline void SchedCpuUtilCfsFtraceEvent::set_active(::int32_t value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.active)
}
inline ::int32_t SchedCpuUtilCfsFtraceEvent::_internal_active() const {
  return _impl_.active_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_active(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.active_ = value;
}

// optional uint64 capacity = 2;
inline bool SchedCpuUtilCfsFtraceEvent::has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_capacity() {
  _impl_.capacity_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::capacity() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.capacity)
  return _internal_capacity();
}
inline void SchedCpuUtilCfsFtraceEvent::set_capacity(::uint64_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.capacity)
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::_internal_capacity() const {
  return _impl_.capacity_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_capacity(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.capacity_ = value;
}

// optional uint64 capacity_orig = 3;
inline bool SchedCpuUtilCfsFtraceEvent::has_capacity_orig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_capacity_orig() {
  _impl_.capacity_orig_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::capacity_orig() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.capacity_orig)
  return _internal_capacity_orig();
}
inline void SchedCpuUtilCfsFtraceEvent::set_capacity_orig(::uint64_t value) {
  _internal_set_capacity_orig(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.capacity_orig)
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::_internal_capacity_orig() const {
  return _impl_.capacity_orig_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_capacity_orig(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.capacity_orig_ = value;
}

// optional uint32 cpu = 4;
inline bool SchedCpuUtilCfsFtraceEvent::has_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_cpu() {
  _impl_.cpu_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu)
  return _internal_cpu();
}
inline void SchedCpuUtilCfsFtraceEvent::set_cpu(::uint32_t value) {
  _internal_set_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu)
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::_internal_cpu() const {
  return _impl_.cpu_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_cpu(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cpu_ = value;
}

// optional uint64 cpu_importance = 5;
inline bool SchedCpuUtilCfsFtraceEvent::has_cpu_importance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_cpu_importance() {
  _impl_.cpu_importance_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::cpu_importance() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu_importance)
  return _internal_cpu_importance();
}
inline void SchedCpuUtilCfsFtraceEvent::set_cpu_importance(::uint64_t value) {
  _internal_set_cpu_importance(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu_importance)
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::_internal_cpu_importance() const {
  return _impl_.cpu_importance_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_cpu_importance(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.cpu_importance_ = value;
}

// optional uint64 cpu_util = 6;
inline bool SchedCpuUtilCfsFtraceEvent::has_cpu_util() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_cpu_util() {
  _impl_.cpu_util_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::cpu_util() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu_util)
  return _internal_cpu_util();
}
inline void SchedCpuUtilCfsFtraceEvent::set_cpu_util(::uint64_t value) {
  _internal_set_cpu_util(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu_util)
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::_internal_cpu_util() const {
  return _impl_.cpu_util_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_cpu_util(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.cpu_util_ = value;
}

// optional uint32 exit_lat = 7;
inline bool SchedCpuUtilCfsFtraceEvent::has_exit_lat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_exit_lat() {
  _impl_.exit_lat_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::exit_lat() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.exit_lat)
  return _internal_exit_lat();
}
inline void SchedCpuUtilCfsFtraceEvent::set_exit_lat(::uint32_t value) {
  _internal_set_exit_lat(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.exit_lat)
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::_internal_exit_lat() const {
  return _impl_.exit_lat_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_exit_lat(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.exit_lat_ = value;
}

// optional uint64 group_capacity = 8;
inline bool SchedCpuUtilCfsFtraceEvent::has_group_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_group_capacity() {
  _impl_.group_capacity_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::group_capacity() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.group_capacity)
  return _internal_group_capacity();
}
inline void SchedCpuUtilCfsFtraceEvent::set_group_capacity(::uint64_t value) {
  _internal_set_group_capacity(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.group_capacity)
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::_internal_group_capacity() const {
  return _impl_.group_capacity_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_group_capacity(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.group_capacity_ = value;
}

// optional uint32 grp_overutilized = 9;
inline bool SchedCpuUtilCfsFtraceEvent::has_grp_overutilized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_grp_overutilized() {
  _impl_.grp_overutilized_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::grp_overutilized() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.grp_overutilized)
  return _internal_grp_overutilized();
}
inline void SchedCpuUtilCfsFtraceEvent::set_grp_overutilized(::uint32_t value) {
  _internal_set_grp_overutilized(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.grp_overutilized)
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::_internal_grp_overutilized() const {
  return _impl_.grp_overutilized_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_grp_overutilized(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.grp_overutilized_ = value;
}

// optional uint32 idle_cpu = 10;
inline bool SchedCpuUtilCfsFtraceEvent::has_idle_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_idle_cpu() {
  _impl_.idle_cpu_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::idle_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.idle_cpu)
  return _internal_idle_cpu();
}
inline void SchedCpuUtilCfsFtraceEvent::set_idle_cpu(::uint32_t value) {
  _internal_set_idle_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.idle_cpu)
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::_internal_idle_cpu() const {
  return _impl_.idle_cpu_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_idle_cpu(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.idle_cpu_ = value;
}

// optional uint32 nr_running = 11;
inline bool SchedCpuUtilCfsFtraceEvent::has_nr_running() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_nr_running() {
  _impl_.nr_running_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::nr_running() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.nr_running)
  return _internal_nr_running();
}
inline void SchedCpuUtilCfsFtraceEvent::set_nr_running(::uint32_t value) {
  _internal_set_nr_running(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.nr_running)
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::_internal_nr_running() const {
  return _impl_.nr_running_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_nr_running(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.nr_running_ = value;
}

// optional int64 spare_cap = 12;
inline bool SchedCpuUtilCfsFtraceEvent::has_spare_cap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_spare_cap() {
  _impl_.spare_cap_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int64_t SchedCpuUtilCfsFtraceEvent::spare_cap() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.spare_cap)
  return _internal_spare_cap();
}
inline void SchedCpuUtilCfsFtraceEvent::set_spare_cap(::int64_t value) {
  _internal_set_spare_cap(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.spare_cap)
}
inline ::int64_t SchedCpuUtilCfsFtraceEvent::_internal_spare_cap() const {
  return _impl_.spare_cap_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_spare_cap(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.spare_cap_ = value;
}

// optional uint32 task_fits = 13;
inline bool SchedCpuUtilCfsFtraceEvent::has_task_fits() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_task_fits() {
  _impl_.task_fits_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::task_fits() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.task_fits)
  return _internal_task_fits();
}
inline void SchedCpuUtilCfsFtraceEvent::set_task_fits(::uint32_t value) {
  _internal_set_task_fits(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.task_fits)
}
inline ::uint32_t SchedCpuUtilCfsFtraceEvent::_internal_task_fits() const {
  return _impl_.task_fits_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_task_fits(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.task_fits_ = value;
}

// optional uint64 wake_group_util = 14;
inline bool SchedCpuUtilCfsFtraceEvent::has_wake_group_util() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_wake_group_util() {
  _impl_.wake_group_util_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::wake_group_util() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.wake_group_util)
  return _internal_wake_group_util();
}
inline void SchedCpuUtilCfsFtraceEvent::set_wake_group_util(::uint64_t value) {
  _internal_set_wake_group_util(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.wake_group_util)
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::_internal_wake_group_util() const {
  return _impl_.wake_group_util_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_wake_group_util(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.wake_group_util_ = value;
}

// optional uint64 wake_util = 15;
inline bool SchedCpuUtilCfsFtraceEvent::has_wake_util() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void SchedCpuUtilCfsFtraceEvent::clear_wake_util() {
  _impl_.wake_util_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::wake_util() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.wake_util)
  return _internal_wake_util();
}
inline void SchedCpuUtilCfsFtraceEvent::set_wake_util(::uint64_t value) {
  _internal_set_wake_util(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.wake_util)
}
inline ::uint64_t SchedCpuUtilCfsFtraceEvent::_internal_wake_util() const {
  return _impl_.wake_util_;
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_wake_util(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.wake_util_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto_2epb_2eh
