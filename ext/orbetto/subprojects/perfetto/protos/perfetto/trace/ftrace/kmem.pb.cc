// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/kmem.proto

#include "protos/perfetto/trace/ftrace/kmem.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace perfetto {
namespace protos {
template <typename>
PROTOBUF_CONSTEXPR AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/ 0u

  , /*decltype(_impl_.order_)*/ 0u
} {}
struct AllocPagesIommuEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesIommuEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesIommuEndFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesIommuEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesIommuEndFtraceEventDefaultTypeInternal _AllocPagesIommuEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/ 0u

  , /*decltype(_impl_.order_)*/ 0u
} {}
struct AllocPagesIommuFailFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesIommuFailFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesIommuFailFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesIommuFailFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesIommuFailFtraceEventDefaultTypeInternal _AllocPagesIommuFailFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/ 0u

  , /*decltype(_impl_.order_)*/ 0u
} {}
struct AllocPagesIommuStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesIommuStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesIommuStartFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesIommuStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesIommuStartFtraceEventDefaultTypeInternal _AllocPagesIommuStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/ 0u

  , /*decltype(_impl_.order_)*/ 0u
} {}
struct AllocPagesSysEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesSysEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesSysEndFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesSysEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesSysEndFtraceEventDefaultTypeInternal _AllocPagesSysEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/ 0u

  , /*decltype(_impl_.order_)*/ 0u
} {}
struct AllocPagesSysFailFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesSysFailFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesSysFailFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesSysFailFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesSysFailFtraceEventDefaultTypeInternal _AllocPagesSysFailFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/ 0u

  , /*decltype(_impl_.order_)*/ 0u
} {}
struct AllocPagesSysStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesSysStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesSysStartFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesSysStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesSysStartFtraceEventDefaultTypeInternal _AllocPagesSysStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tries_)*/ 0
} {}
struct DmaAllocContiguousRetryFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DmaAllocContiguousRetryFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DmaAllocContiguousRetryFtraceEventDefaultTypeInternal() {}
  union {
    DmaAllocContiguousRetryFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DmaAllocContiguousRetryFtraceEventDefaultTypeInternal _DmaAllocContiguousRetryFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chunk_size_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pa_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.va_)*/ ::uint64_t{0u}
} {}
struct IommuMapRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IommuMapRangeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IommuMapRangeFtraceEventDefaultTypeInternal() {}
  union {
    IommuMapRangeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IommuMapRangeFtraceEventDefaultTypeInternal _IommuMapRangeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.num_)*/ 0

  , /*decltype(_impl_.pa_)*/ 0u

  , /*decltype(_impl_.va_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.sec_id_)*/ 0
} {}
struct IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal() {}
  union {
    IommuSecPtblMapRangeEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal _IommuSecPtblMapRangeEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.num_)*/ 0

  , /*decltype(_impl_.pa_)*/ 0u

  , /*decltype(_impl_.va_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.sec_id_)*/ 0
} {}
struct IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal() {}
  union {
    IommuSecPtblMapRangeStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal _IommuSecPtblMapRangeStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.flags_)*/ 0u

  , /*decltype(_impl_.mask_)*/ 0u

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonAllocBufferEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonAllocBufferEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonAllocBufferEndFtraceEventDefaultTypeInternal() {}
  union {
    IonAllocBufferEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonAllocBufferEndFtraceEventDefaultTypeInternal _IonAllocBufferEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.error_)*/ ::int64_t{0}

  , /*decltype(_impl_.flags_)*/ 0u

  , /*decltype(_impl_.mask_)*/ 0u

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonAllocBufferFailFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonAllocBufferFailFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonAllocBufferFailFtraceEventDefaultTypeInternal() {}
  union {
    IonAllocBufferFailFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonAllocBufferFailFtraceEventDefaultTypeInternal _IonAllocBufferFailFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.error_)*/ ::int64_t{0}

  , /*decltype(_impl_.flags_)*/ 0u

  , /*decltype(_impl_.mask_)*/ 0u

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonAllocBufferFallbackFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonAllocBufferFallbackFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonAllocBufferFallbackFtraceEventDefaultTypeInternal() {}
  union {
    IonAllocBufferFallbackFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonAllocBufferFallbackFtraceEventDefaultTypeInternal _IonAllocBufferFallbackFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.flags_)*/ 0u

  , /*decltype(_impl_.mask_)*/ 0u

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonAllocBufferStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonAllocBufferStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonAllocBufferStartFtraceEventDefaultTypeInternal() {}
  union {
    IonAllocBufferStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonAllocBufferStartFtraceEventDefaultTypeInternal _IonAllocBufferStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tries_)*/ 0
} {}
struct IonCpAllocRetryFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonCpAllocRetryFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonCpAllocRetryFtraceEventDefaultTypeInternal() {}
  union {
    IonCpAllocRetryFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonCpAllocRetryFtraceEventDefaultTypeInternal _IonCpAllocRetryFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.align_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonCpSecureBufferEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonCpSecureBufferEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonCpSecureBufferEndFtraceEventDefaultTypeInternal() {}
  union {
    IonCpSecureBufferEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonCpSecureBufferEndFtraceEventDefaultTypeInternal _IonCpSecureBufferEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.align_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonCpSecureBufferStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonCpSecureBufferStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonCpSecureBufferStartFtraceEventDefaultTypeInternal() {}
  union {
    IonCpSecureBufferStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonCpSecureBufferStartFtraceEventDefaultTypeInternal _IonCpSecureBufferStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonPrefetchingFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonPrefetchingFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonPrefetchingFtraceEventDefaultTypeInternal() {}
  union {
    IonPrefetchingFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonPrefetchingFtraceEventDefaultTypeInternal _IonPrefetchingFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.is_prefetch_)*/ 0u

  , /*decltype(_impl_.pool_total_)*/ 0
} {}
struct IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaAddToPoolEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal _IonSecureCmaAddToPoolEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.is_prefetch_)*/ 0u

  , /*decltype(_impl_.pool_total_)*/ 0
} {}
struct IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaAddToPoolStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal _IonSecureCmaAddToPoolStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.align_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaAllocateEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal _IonSecureCmaAllocateEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.align_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaAllocateStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal _IonSecureCmaAllocateStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drained_size_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.skipped_size_)*/ ::uint64_t{0u}
} {}
struct IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaShrinkPoolEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal _IonSecureCmaShrinkPoolEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drained_size_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.skipped_size_)*/ ::uint64_t{0u}
} {}
struct IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaShrinkPoolStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal _IonSecureCmaShrinkPoolStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KfreeFtraceEvent::KfreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.call_site_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ptr_)*/ ::uint64_t{0u}
} {}
struct KfreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KfreeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KfreeFtraceEventDefaultTypeInternal() {}
  union {
    KfreeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KfreeFtraceEventDefaultTypeInternal _KfreeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KmallocFtraceEvent::KmallocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bytes_alloc_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.bytes_req_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.call_site_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ptr_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.gfp_flags_)*/ 0u
} {}
struct KmallocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmallocFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmallocFtraceEventDefaultTypeInternal() {}
  union {
    KmallocFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmallocFtraceEventDefaultTypeInternal _KmallocFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KmallocNodeFtraceEvent::KmallocNodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bytes_alloc_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.bytes_req_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.call_site_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.gfp_flags_)*/ 0u

  , /*decltype(_impl_.node_)*/ 0

  , /*decltype(_impl_.ptr_)*/ ::uint64_t{0u}
} {}
struct KmallocNodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmallocNodeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmallocNodeFtraceEventDefaultTypeInternal() {}
  union {
    KmallocNodeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmallocNodeFtraceEventDefaultTypeInternal _KmallocNodeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bytes_alloc_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.bytes_req_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.call_site_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ptr_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.gfp_flags_)*/ 0u
} {}
struct KmemCacheAllocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmemCacheAllocFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmemCacheAllocFtraceEventDefaultTypeInternal() {}
  union {
    KmemCacheAllocFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmemCacheAllocFtraceEventDefaultTypeInternal _KmemCacheAllocFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bytes_alloc_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.bytes_req_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.call_site_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.gfp_flags_)*/ 0u

  , /*decltype(_impl_.node_)*/ 0

  , /*decltype(_impl_.ptr_)*/ ::uint64_t{0u}
} {}
struct KmemCacheAllocNodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmemCacheAllocNodeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmemCacheAllocNodeFtraceEventDefaultTypeInternal() {}
  union {
    KmemCacheAllocNodeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmemCacheAllocNodeFtraceEventDefaultTypeInternal _KmemCacheAllocNodeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.call_site_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ptr_)*/ ::uint64_t{0u}
} {}
struct KmemCacheFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmemCacheFreeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmemCacheFreeFtraceEventDefaultTypeInternal() {}
  union {
    KmemCacheFreeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmemCacheFreeFtraceEventDefaultTypeInternal _KmemCacheFreeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_)*/ 0
} {}
struct MigratePagesEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MigratePagesEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MigratePagesEndFtraceEventDefaultTypeInternal() {}
  union {
    MigratePagesEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MigratePagesEndFtraceEventDefaultTypeInternal _MigratePagesEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_)*/ 0
} {}
struct MigratePagesStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MigratePagesStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MigratePagesStartFtraceEventDefaultTypeInternal() {}
  union {
    MigratePagesStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MigratePagesStartFtraceEventDefaultTypeInternal _MigratePagesStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MigrateRetryFtraceEvent::MigrateRetryFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tries_)*/ 0
} {}
struct MigrateRetryFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MigrateRetryFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MigrateRetryFtraceEventDefaultTypeInternal() {}
  union {
    MigrateRetryFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MigrateRetryFtraceEventDefaultTypeInternal _MigrateRetryFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MmPageAllocFtraceEvent::MmPageAllocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/ 0u

  , /*decltype(_impl_.migratetype_)*/ 0

  , /*decltype(_impl_.page_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pfn_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.order_)*/ 0u
} {}
struct MmPageAllocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageAllocFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageAllocFtraceEventDefaultTypeInternal() {}
  union {
    MmPageAllocFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageAllocFtraceEventDefaultTypeInternal _MmPageAllocFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.alloc_migratetype_)*/ 0

  , /*decltype(_impl_.alloc_order_)*/ 0

  , /*decltype(_impl_.fallback_migratetype_)*/ 0

  , /*decltype(_impl_.fallback_order_)*/ 0

  , /*decltype(_impl_.page_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pfn_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.change_ownership_)*/ 0
} {}
struct MmPageAllocExtfragFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageAllocExtfragFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageAllocExtfragFtraceEventDefaultTypeInternal() {}
  union {
    MmPageAllocExtfragFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageAllocExtfragFtraceEventDefaultTypeInternal _MmPageAllocExtfragFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.migratetype_)*/ 0

  , /*decltype(_impl_.order_)*/ 0u

  , /*decltype(_impl_.page_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pfn_)*/ ::uint64_t{0u}
} {}
struct MmPageAllocZoneLockedFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageAllocZoneLockedFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageAllocZoneLockedFtraceEventDefaultTypeInternal() {}
  union {
    MmPageAllocZoneLockedFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageAllocZoneLockedFtraceEventDefaultTypeInternal _MmPageAllocZoneLockedFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MmPageFreeFtraceEvent::MmPageFreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.page_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pfn_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.order_)*/ 0u
} {}
struct MmPageFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageFreeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageFreeFtraceEventDefaultTypeInternal() {}
  union {
    MmPageFreeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageFreeFtraceEventDefaultTypeInternal _MmPageFreeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.page_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pfn_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.cold_)*/ 0
} {}
struct MmPageFreeBatchedFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageFreeBatchedFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageFreeBatchedFtraceEventDefaultTypeInternal() {}
  union {
    MmPageFreeBatchedFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageFreeBatchedFtraceEventDefaultTypeInternal _MmPageFreeBatchedFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.migratetype_)*/ 0

  , /*decltype(_impl_.order_)*/ 0u

  , /*decltype(_impl_.page_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pfn_)*/ ::uint64_t{0u}
} {}
struct MmPagePcpuDrainFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPagePcpuDrainFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPagePcpuDrainFtraceEventDefaultTypeInternal() {}
  union {
    MmPagePcpuDrainFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPagePcpuDrainFtraceEventDefaultTypeInternal _MmPagePcpuDrainFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RssStatFtraceEvent::RssStatFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.size_)*/ ::int64_t{0}

  , /*decltype(_impl_.member_)*/ 0

  , /*decltype(_impl_.curr_)*/ 0u

  , /*decltype(_impl_.mm_id_)*/ 0u
} {}
struct RssStatFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RssStatFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RssStatFtraceEventDefaultTypeInternal() {}
  union {
    RssStatFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RssStatFtraceEventDefaultTypeInternal _RssStatFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.total_allocated_)*/ ::int64_t{0}
} {}
struct IonHeapShrinkFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonHeapShrinkFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonHeapShrinkFtraceEventDefaultTypeInternal() {}
  union {
    IonHeapShrinkFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonHeapShrinkFtraceEventDefaultTypeInternal _IonHeapShrinkFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.total_allocated_)*/ ::int64_t{0}
} {}
struct IonHeapGrowFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonHeapGrowFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonHeapGrowFtraceEventDefaultTypeInternal() {}
  union {
    IonHeapGrowFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonHeapGrowFtraceEventDefaultTypeInternal _IonHeapGrowFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.addr_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonBufferCreateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonBufferCreateFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonBufferCreateFtraceEventDefaultTypeInternal() {}
  union {
    IonBufferCreateFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonBufferCreateFtraceEventDefaultTypeInternal _IonBufferCreateFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.addr_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}
} {}
struct IonBufferDestroyFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonBufferDestroyFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonBufferDestroyFtraceEventDefaultTypeInternal() {}
  union {
    IonBufferDestroyFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonBufferDestroyFtraceEventDefaultTypeInternal _IonBufferDestroyFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
static ::_pb::Metadata file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[44];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto = nullptr;
const ::uint32_t TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuEndFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuEndFtraceEvent, _impl_.order_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuFailFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuFailFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuFailFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuFailFtraceEvent, _impl_.order_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuStartFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesIommuStartFtraceEvent, _impl_.order_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysEndFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysEndFtraceEvent, _impl_.order_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysFailFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysFailFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysFailFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysFailFtraceEvent, _impl_.order_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysStartFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::AllocPagesSysStartFtraceEvent, _impl_.order_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::DmaAllocContiguousRetryFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::DmaAllocContiguousRetryFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::DmaAllocContiguousRetryFtraceEvent, _impl_.tries_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuMapRangeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuMapRangeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuMapRangeFtraceEvent, _impl_.chunk_size_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuMapRangeFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuMapRangeFtraceEvent, _impl_.pa_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuMapRangeFtraceEvent, _impl_.va_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent, _impl_.num_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent, _impl_.pa_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent, _impl_.sec_id_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent, _impl_.va_),
    0,
    1,
    2,
    4,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent, _impl_.num_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent, _impl_.pa_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent, _impl_.sec_id_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent, _impl_.va_),
    0,
    1,
    2,
    4,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferEndFtraceEvent, _impl_.client_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferEndFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferEndFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferEndFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferEndFtraceEvent, _impl_.mask_),
    0,
    2,
    1,
    4,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFailFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFailFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFailFtraceEvent, _impl_.client_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFailFtraceEvent, _impl_.error_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFailFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFailFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFailFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFailFtraceEvent, _impl_.mask_),
    0,
    2,
    3,
    1,
    5,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFallbackFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFallbackFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFallbackFtraceEvent, _impl_.client_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFallbackFtraceEvent, _impl_.error_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFallbackFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFallbackFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFallbackFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferFallbackFtraceEvent, _impl_.mask_),
    0,
    2,
    3,
    1,
    5,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferStartFtraceEvent, _impl_.client_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferStartFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferStartFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferStartFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonAllocBufferStartFtraceEvent, _impl_.mask_),
    0,
    2,
    1,
    4,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpAllocRetryFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpAllocRetryFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpAllocRetryFtraceEvent, _impl_.tries_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferEndFtraceEvent, _impl_.align_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferEndFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferEndFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferEndFtraceEvent, _impl_.len_),
    1,
    2,
    0,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferStartFtraceEvent, _impl_.align_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferStartFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferStartFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonCpSecureBufferStartFtraceEvent, _impl_.len_),
    1,
    2,
    0,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonPrefetchingFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonPrefetchingFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonPrefetchingFtraceEvent, _impl_.len_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent, _impl_.is_prefetch_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent, _impl_.pool_total_),
    1,
    0,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent, _impl_.is_prefetch_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent, _impl_.pool_total_),
    1,
    0,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent, _impl_.align_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent, _impl_.len_),
    1,
    2,
    0,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent, _impl_.align_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent, _impl_.len_),
    1,
    2,
    0,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent, _impl_.drained_size_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent, _impl_.skipped_size_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent, _impl_.drained_size_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent, _impl_.skipped_size_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KfreeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KfreeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KfreeFtraceEvent, _impl_.call_site_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KfreeFtraceEvent, _impl_.ptr_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocFtraceEvent, _impl_.bytes_alloc_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocFtraceEvent, _impl_.bytes_req_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocFtraceEvent, _impl_.call_site_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocFtraceEvent, _impl_.ptr_),
    0,
    1,
    2,
    4,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocNodeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocNodeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocNodeFtraceEvent, _impl_.bytes_alloc_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocNodeFtraceEvent, _impl_.bytes_req_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocNodeFtraceEvent, _impl_.call_site_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocNodeFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocNodeFtraceEvent, _impl_.node_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmallocNodeFtraceEvent, _impl_.ptr_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocFtraceEvent, _impl_.bytes_alloc_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocFtraceEvent, _impl_.bytes_req_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocFtraceEvent, _impl_.call_site_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocFtraceEvent, _impl_.ptr_),
    0,
    1,
    2,
    4,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocNodeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocNodeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocNodeFtraceEvent, _impl_.bytes_alloc_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocNodeFtraceEvent, _impl_.bytes_req_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocNodeFtraceEvent, _impl_.call_site_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocNodeFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocNodeFtraceEvent, _impl_.node_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheAllocNodeFtraceEvent, _impl_.ptr_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheFreeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheFreeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheFreeFtraceEvent, _impl_.call_site_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::KmemCacheFreeFtraceEvent, _impl_.ptr_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MigratePagesEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MigratePagesEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MigratePagesEndFtraceEvent, _impl_.mode_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MigratePagesStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MigratePagesStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MigratePagesStartFtraceEvent, _impl_.mode_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MigrateRetryFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MigrateRetryFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MigrateRetryFtraceEvent, _impl_.tries_),
    0,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocFtraceEvent, _impl_.gfp_flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocFtraceEvent, _impl_.migratetype_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocFtraceEvent, _impl_.order_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocFtraceEvent, _impl_.page_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocFtraceEvent, _impl_.pfn_),
    0,
    1,
    4,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocExtfragFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocExtfragFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocExtfragFtraceEvent, _impl_.alloc_migratetype_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocExtfragFtraceEvent, _impl_.alloc_order_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocExtfragFtraceEvent, _impl_.fallback_migratetype_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocExtfragFtraceEvent, _impl_.fallback_order_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocExtfragFtraceEvent, _impl_.page_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocExtfragFtraceEvent, _impl_.change_ownership_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocExtfragFtraceEvent, _impl_.pfn_),
    0,
    1,
    2,
    3,
    4,
    6,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocZoneLockedFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocZoneLockedFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocZoneLockedFtraceEvent, _impl_.migratetype_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocZoneLockedFtraceEvent, _impl_.order_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocZoneLockedFtraceEvent, _impl_.page_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageAllocZoneLockedFtraceEvent, _impl_.pfn_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeFtraceEvent, _impl_.order_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeFtraceEvent, _impl_.page_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeFtraceEvent, _impl_.pfn_),
    2,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeBatchedFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeBatchedFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeBatchedFtraceEvent, _impl_.cold_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeBatchedFtraceEvent, _impl_.page_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPageFreeBatchedFtraceEvent, _impl_.pfn_),
    2,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPagePcpuDrainFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPagePcpuDrainFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPagePcpuDrainFtraceEvent, _impl_.migratetype_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPagePcpuDrainFtraceEvent, _impl_.order_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPagePcpuDrainFtraceEvent, _impl_.page_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::MmPagePcpuDrainFtraceEvent, _impl_.pfn_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::RssStatFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::RssStatFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::RssStatFtraceEvent, _impl_.member_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::RssStatFtraceEvent, _impl_.size_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::RssStatFtraceEvent, _impl_.curr_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::RssStatFtraceEvent, _impl_.mm_id_),
    1,
    0,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapShrinkFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapShrinkFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapShrinkFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapShrinkFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapShrinkFtraceEvent, _impl_.total_allocated_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapGrowFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapGrowFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapGrowFtraceEvent, _impl_.heap_name_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapGrowFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonHeapGrowFtraceEvent, _impl_.total_allocated_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonBufferCreateFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonBufferCreateFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonBufferCreateFtraceEvent, _impl_.addr_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonBufferCreateFtraceEvent, _impl_.len_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonBufferDestroyFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonBufferDestroyFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonBufferDestroyFtraceEvent, _impl_.addr_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::IonBufferDestroyFtraceEvent, _impl_.len_),
    0,
    1,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 10, -1, sizeof(::perfetto::protos::AllocPagesIommuEndFtraceEvent)},
        { 12, 22, -1, sizeof(::perfetto::protos::AllocPagesIommuFailFtraceEvent)},
        { 24, 34, -1, sizeof(::perfetto::protos::AllocPagesIommuStartFtraceEvent)},
        { 36, 46, -1, sizeof(::perfetto::protos::AllocPagesSysEndFtraceEvent)},
        { 48, 58, -1, sizeof(::perfetto::protos::AllocPagesSysFailFtraceEvent)},
        { 60, 70, -1, sizeof(::perfetto::protos::AllocPagesSysStartFtraceEvent)},
        { 72, 81, -1, sizeof(::perfetto::protos::DmaAllocContiguousRetryFtraceEvent)},
        { 82, 94, -1, sizeof(::perfetto::protos::IommuMapRangeFtraceEvent)},
        { 98, 111, -1, sizeof(::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent)},
        { 116, 129, -1, sizeof(::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent)},
        { 134, 147, -1, sizeof(::perfetto::protos::IonAllocBufferEndFtraceEvent)},
        { 152, 166, -1, sizeof(::perfetto::protos::IonAllocBufferFailFtraceEvent)},
        { 172, 186, -1, sizeof(::perfetto::protos::IonAllocBufferFallbackFtraceEvent)},
        { 192, 205, -1, sizeof(::perfetto::protos::IonAllocBufferStartFtraceEvent)},
        { 210, 219, -1, sizeof(::perfetto::protos::IonCpAllocRetryFtraceEvent)},
        { 220, 232, -1, sizeof(::perfetto::protos::IonCpSecureBufferEndFtraceEvent)},
        { 236, 248, -1, sizeof(::perfetto::protos::IonCpSecureBufferStartFtraceEvent)},
        { 252, 261, -1, sizeof(::perfetto::protos::IonPrefetchingFtraceEvent)},
        { 262, 273, -1, sizeof(::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent)},
        { 276, 287, -1, sizeof(::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent)},
        { 290, 302, -1, sizeof(::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent)},
        { 306, 318, -1, sizeof(::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent)},
        { 322, 332, -1, sizeof(::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent)},
        { 334, 344, -1, sizeof(::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent)},
        { 346, 356, -1, sizeof(::perfetto::protos::KfreeFtraceEvent)},
        { 358, 371, -1, sizeof(::perfetto::protos::KmallocFtraceEvent)},
        { 376, 390, -1, sizeof(::perfetto::protos::KmallocNodeFtraceEvent)},
        { 396, 409, -1, sizeof(::perfetto::protos::KmemCacheAllocFtraceEvent)},
        { 414, 428, -1, sizeof(::perfetto::protos::KmemCacheAllocNodeFtraceEvent)},
        { 434, 444, -1, sizeof(::perfetto::protos::KmemCacheFreeFtraceEvent)},
        { 446, 455, -1, sizeof(::perfetto::protos::MigratePagesEndFtraceEvent)},
        { 456, 465, -1, sizeof(::perfetto::protos::MigratePagesStartFtraceEvent)},
        { 466, 475, -1, sizeof(::perfetto::protos::MigrateRetryFtraceEvent)},
        { 476, 489, -1, sizeof(::perfetto::protos::MmPageAllocFtraceEvent)},
        { 494, 509, -1, sizeof(::perfetto::protos::MmPageAllocExtfragFtraceEvent)},
        { 516, 528, -1, sizeof(::perfetto::protos::MmPageAllocZoneLockedFtraceEvent)},
        { 532, 543, -1, sizeof(::perfetto::protos::MmPageFreeFtraceEvent)},
        { 546, 557, -1, sizeof(::perfetto::protos::MmPageFreeBatchedFtraceEvent)},
        { 560, 572, -1, sizeof(::perfetto::protos::MmPagePcpuDrainFtraceEvent)},
        { 576, 588, -1, sizeof(::perfetto::protos::RssStatFtraceEvent)},
        { 592, 603, -1, sizeof(::perfetto::protos::IonHeapShrinkFtraceEvent)},
        { 606, 617, -1, sizeof(::perfetto::protos::IonHeapGrowFtraceEvent)},
        { 620, 630, -1, sizeof(::perfetto::protos::IonBufferCreateFtraceEvent)},
        { 632, 642, -1, sizeof(::perfetto::protos::IonBufferDestroyFtraceEvent)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::perfetto::protos::_AllocPagesIommuEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_AllocPagesIommuFailFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_AllocPagesIommuStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_AllocPagesSysEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_AllocPagesSysFailFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_AllocPagesSysStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_DmaAllocContiguousRetryFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IommuMapRangeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IommuSecPtblMapRangeEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IommuSecPtblMapRangeStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonAllocBufferEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonAllocBufferFailFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonAllocBufferFallbackFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonAllocBufferStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonCpAllocRetryFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonCpSecureBufferEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonCpSecureBufferStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonPrefetchingFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonSecureCmaAddToPoolEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonSecureCmaAddToPoolStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonSecureCmaAllocateEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonSecureCmaAllocateStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonSecureCmaShrinkPoolEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonSecureCmaShrinkPoolStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KfreeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KmallocFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KmallocNodeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KmemCacheAllocFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KmemCacheAllocNodeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_KmemCacheFreeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_MigratePagesEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_MigratePagesStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_MigrateRetryFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_MmPageAllocFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_MmPageAllocExtfragFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_MmPageAllocZoneLockedFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_MmPageFreeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_MmPageFreeBatchedFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_MmPagePcpuDrainFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_RssStatFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonHeapShrinkFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonHeapGrowFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonBufferCreateFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_IonBufferDestroyFtraceEvent_default_instance_._instance,
};
const char descriptor_table_protodef_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\'protos/perfetto/trace/ftrace/kmem.prot"
    "o\022\017perfetto.protos\"A\n\035AllocPagesIommuEnd"
    "FtraceEvent\022\021\n\tgfp_flags\030\001 \001(\r\022\r\n\005order\030"
    "\002 \001(\r\"B\n\036AllocPagesIommuFailFtraceEvent\022"
    "\021\n\tgfp_flags\030\001 \001(\r\022\r\n\005order\030\002 \001(\r\"C\n\037All"
    "ocPagesIommuStartFtraceEvent\022\021\n\tgfp_flag"
    "s\030\001 \001(\r\022\r\n\005order\030\002 \001(\r\"\?\n\033AllocPagesSysE"
    "ndFtraceEvent\022\021\n\tgfp_flags\030\001 \001(\r\022\r\n\005orde"
    "r\030\002 \001(\r\"@\n\034AllocPagesSysFailFtraceEvent\022"
    "\021\n\tgfp_flags\030\001 \001(\r\022\r\n\005order\030\002 \001(\r\"A\n\035All"
    "ocPagesSysStartFtraceEvent\022\021\n\tgfp_flags\030"
    "\001 \001(\r\022\r\n\005order\030\002 \001(\r\"3\n\"DmaAllocContiguo"
    "usRetryFtraceEvent\022\r\n\005tries\030\001 \001(\005\"S\n\030Iom"
    "muMapRangeFtraceEvent\022\022\n\nchunk_size\030\001 \001("
    "\004\022\013\n\003len\030\002 \001(\004\022\n\n\002pa\030\003 \001(\004\022\n\n\002va\030\004 \001(\004\"f"
    "\n\"IommuSecPtblMapRangeEndFtraceEvent\022\013\n\003"
    "len\030\001 \001(\004\022\013\n\003num\030\002 \001(\005\022\n\n\002pa\030\003 \001(\r\022\016\n\006se"
    "c_id\030\004 \001(\005\022\n\n\002va\030\005 \001(\004\"h\n$IommuSecPtblMa"
    "pRangeStartFtraceEvent\022\013\n\003len\030\001 \001(\004\022\013\n\003n"
    "um\030\002 \001(\005\022\n\n\002pa\030\003 \001(\r\022\016\n\006sec_id\030\004 \001(\005\022\n\n\002"
    "va\030\005 \001(\004\"p\n\034IonAllocBufferEndFtraceEvent"
    "\022\023\n\013client_name\030\001 \001(\t\022\r\n\005flags\030\002 \001(\r\022\021\n\t"
    "heap_name\030\003 \001(\t\022\013\n\003len\030\004 \001(\004\022\014\n\004mask\030\005 \001"
    "(\r\"\200\001\n\035IonAllocBufferFailFtraceEvent\022\023\n\013"
    "client_name\030\001 \001(\t\022\r\n\005error\030\002 \001(\003\022\r\n\005flag"
    "s\030\003 \001(\r\022\021\n\theap_name\030\004 \001(\t\022\013\n\003len\030\005 \001(\004\022"
    "\014\n\004mask\030\006 \001(\r\"\204\001\n!IonAllocBufferFallback"
    "FtraceEvent\022\023\n\013client_name\030\001 \001(\t\022\r\n\005erro"
    "r\030\002 \001(\003\022\r\n\005flags\030\003 \001(\r\022\021\n\theap_name\030\004 \001("
    "\t\022\013\n\003len\030\005 \001(\004\022\014\n\004mask\030\006 \001(\r\"r\n\036IonAlloc"
    "BufferStartFtraceEvent\022\023\n\013client_name\030\001 "
    "\001(\t\022\r\n\005flags\030\002 \001(\r\022\021\n\theap_name\030\003 \001(\t\022\013\n"
    "\003len\030\004 \001(\004\022\014\n\004mask\030\005 \001(\r\"+\n\032IonCpAllocRe"
    "tryFtraceEvent\022\r\n\005tries\030\001 \001(\005\"_\n\037IonCpSe"
    "cureBufferEndFtraceEvent\022\r\n\005align\030\001 \001(\004\022"
    "\r\n\005flags\030\002 \001(\004\022\021\n\theap_name\030\003 \001(\t\022\013\n\003len"
    "\030\004 \001(\004\"a\n!IonCpSecureBufferStartFtraceEv"
    "ent\022\r\n\005align\030\001 \001(\004\022\r\n\005flags\030\002 \001(\004\022\021\n\thea"
    "p_name\030\003 \001(\t\022\013\n\003len\030\004 \001(\004\"(\n\031IonPrefetch"
    "ingFtraceEvent\022\013\n\003len\030\001 \001(\004\"[\n#IonSecure"
    "CmaAddToPoolEndFtraceEvent\022\023\n\013is_prefetc"
    "h\030\001 \001(\r\022\013\n\003len\030\002 \001(\004\022\022\n\npool_total\030\003 \001(\005"
    "\"]\n%IonSecureCmaAddToPoolStartFtraceEven"
    "t\022\023\n\013is_prefetch\030\001 \001(\r\022\013\n\003len\030\002 \001(\004\022\022\n\np"
    "ool_total\030\003 \001(\005\"b\n\"IonSecureCmaAllocateE"
    "ndFtraceEvent\022\r\n\005align\030\001 \001(\004\022\r\n\005flags\030\002 "
    "\001(\004\022\021\n\theap_name\030\003 \001(\t\022\013\n\003len\030\004 \001(\004\"d\n$I"
    "onSecureCmaAllocateStartFtraceEvent\022\r\n\005a"
    "lign\030\001 \001(\004\022\r\n\005flags\030\002 \001(\004\022\021\n\theap_name\030\003"
    " \001(\t\022\013\n\003len\030\004 \001(\004\"R\n$IonSecureCmaShrinkP"
    "oolEndFtraceEvent\022\024\n\014drained_size\030\001 \001(\004\022"
    "\024\n\014skipped_size\030\002 \001(\004\"T\n&IonSecureCmaShr"
    "inkPoolStartFtraceEvent\022\024\n\014drained_size\030"
    "\001 \001(\004\022\024\n\014skipped_size\030\002 \001(\004\"2\n\020KfreeFtra"
    "ceEvent\022\021\n\tcall_site\030\001 \001(\004\022\013\n\003ptr\030\002 \001(\004\""
    "o\n\022KmallocFtraceEvent\022\023\n\013bytes_alloc\030\001 \001"
    "(\004\022\021\n\tbytes_req\030\002 \001(\004\022\021\n\tcall_site\030\003 \001(\004"
    "\022\021\n\tgfp_flags\030\004 \001(\r\022\013\n\003ptr\030\005 \001(\004\"\201\001\n\026Kma"
    "llocNodeFtraceEvent\022\023\n\013bytes_alloc\030\001 \001(\004"
    "\022\021\n\tbytes_req\030\002 \001(\004\022\021\n\tcall_site\030\003 \001(\004\022\021"
    "\n\tgfp_flags\030\004 \001(\r\022\014\n\004node\030\005 \001(\005\022\013\n\003ptr\030\006"
    " \001(\004\"v\n\031KmemCacheAllocFtraceEvent\022\023\n\013byt"
    "es_alloc\030\001 \001(\004\022\021\n\tbytes_req\030\002 \001(\004\022\021\n\tcal"
    "l_site\030\003 \001(\004\022\021\n\tgfp_flags\030\004 \001(\r\022\013\n\003ptr\030\005"
    " \001(\004\"\210\001\n\035KmemCacheAllocNodeFtraceEvent\022\023"
    "\n\013bytes_alloc\030\001 \001(\004\022\021\n\tbytes_req\030\002 \001(\004\022\021"
    "\n\tcall_site\030\003 \001(\004\022\021\n\tgfp_flags\030\004 \001(\r\022\014\n\004"
    "node\030\005 \001(\005\022\013\n\003ptr\030\006 \001(\004\":\n\030KmemCacheFree"
    "FtraceEvent\022\021\n\tcall_site\030\001 \001(\004\022\013\n\003ptr\030\002 "
    "\001(\004\"*\n\032MigratePagesEndFtraceEvent\022\014\n\004mod"
    "e\030\001 \001(\005\",\n\034MigratePagesStartFtraceEvent\022"
    "\014\n\004mode\030\001 \001(\005\"(\n\027MigrateRetryFtraceEvent"
    "\022\r\n\005tries\030\001 \001(\005\"j\n\026MmPageAllocFtraceEven"
    "t\022\021\n\tgfp_flags\030\001 \001(\r\022\023\n\013migratetype\030\002 \001("
    "\005\022\r\n\005order\030\003 \001(\r\022\014\n\004page\030\004 \001(\004\022\013\n\003pfn\030\005 "
    "\001(\004\"\272\001\n\035MmPageAllocExtfragFtraceEvent\022\031\n"
    "\021alloc_migratetype\030\001 \001(\005\022\023\n\013alloc_order\030"
    "\002 \001(\005\022\034\n\024fallback_migratetype\030\003 \001(\005\022\026\n\016f"
    "allback_order\030\004 \001(\005\022\014\n\004page\030\005 \001(\004\022\030\n\020cha"
    "nge_ownership\030\006 \001(\005\022\013\n\003pfn\030\007 \001(\004\"a\n MmPa"
    "geAllocZoneLockedFtraceEvent\022\023\n\013migratet"
    "ype\030\001 \001(\005\022\r\n\005order\030\002 \001(\r\022\014\n\004page\030\003 \001(\004\022\013"
    "\n\003pfn\030\004 \001(\004\"A\n\025MmPageFreeFtraceEvent\022\r\n\005"
    "order\030\001 \001(\r\022\014\n\004page\030\002 \001(\004\022\013\n\003pfn\030\003 \001(\004\"G"
    "\n\034MmPageFreeBatchedFtraceEvent\022\014\n\004cold\030\001"
    " \001(\005\022\014\n\004page\030\002 \001(\004\022\013\n\003pfn\030\003 \001(\004\"[\n\032MmPag"
    "ePcpuDrainFtraceEvent\022\023\n\013migratetype\030\001 \001"
    "(\005\022\r\n\005order\030\002 \001(\r\022\014\n\004page\030\003 \001(\004\022\013\n\003pfn\030\004"
    " \001(\004\"O\n\022RssStatFtraceEvent\022\016\n\006member\030\001 \001"
    "(\005\022\014\n\004size\030\002 \001(\003\022\014\n\004curr\030\003 \001(\r\022\r\n\005mm_id\030"
    "\004 \001(\r\"S\n\030IonHeapShrinkFtraceEvent\022\021\n\thea"
    "p_name\030\001 \001(\t\022\013\n\003len\030\002 \001(\004\022\027\n\017total_alloc"
    "ated\030\003 \001(\003\"Q\n\026IonHeapGrowFtraceEvent\022\021\n\t"
    "heap_name\030\001 \001(\t\022\013\n\003len\030\002 \001(\004\022\027\n\017total_al"
    "located\030\003 \001(\003\"7\n\032IonBufferCreateFtraceEv"
    "ent\022\014\n\004addr\030\001 \001(\004\022\013\n\003len\030\002 \001(\004\"8\n\033IonBuf"
    "ferDestroyFtraceEvent\022\014\n\004addr\030\001 \001(\004\022\013\n\003l"
    "en\030\002 \001(\004"
};
static ::absl::once_flag descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto = {
    false,
    false,
    3888,
    descriptor_table_protodef_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto,
    "protos/perfetto/trace/ftrace/kmem.proto",
    &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
    nullptr,
    0,
    44,
    schemas,
    file_default_instances,
    TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto::offsets,
    file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto,
    file_level_enum_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto,
    file_level_service_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter() {
  return &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto(&descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto);
namespace perfetto {
namespace protos {
// ===================================================================

class AllocPagesIommuEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesIommuEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AllocPagesIommuEndFtraceEvent, _impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesIommuEndFtraceEvent)
}
AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent(const AllocPagesIommuEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesIommuEndFtraceEvent)
}

inline void AllocPagesIommuEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_) { 0u }

    , decltype(_impl_.order_) { 0u }

  };
}

AllocPagesIommuEndFtraceEvent::~AllocPagesIommuEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesIommuEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesIommuEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesIommuEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AllocPagesIommuEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AllocPagesIommuEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  return target;
}

::size_t AllocPagesIommuEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AllocPagesIommuEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AllocPagesIommuEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AllocPagesIommuEndFtraceEvent::GetClassData() const { return &_class_data_; }


void AllocPagesIommuEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AllocPagesIommuEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const AllocPagesIommuEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AllocPagesIommuEndFtraceEvent::CopyFrom(const AllocPagesIommuEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesIommuEndFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesIommuEndFtraceEvent::InternalSwap(AllocPagesIommuEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesIommuEndFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesIommuEndFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesIommuEndFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AllocPagesIommuEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[0]);
}
// ===================================================================

class AllocPagesIommuFailFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesIommuFailFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AllocPagesIommuFailFtraceEvent, _impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesIommuFailFtraceEvent)
}
AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent(const AllocPagesIommuFailFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesIommuFailFtraceEvent)
}

inline void AllocPagesIommuFailFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_) { 0u }

    , decltype(_impl_.order_) { 0u }

  };
}

AllocPagesIommuFailFtraceEvent::~AllocPagesIommuFailFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesIommuFailFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesIommuFailFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesIommuFailFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AllocPagesIommuFailFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AllocPagesIommuFailFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  return target;
}

::size_t AllocPagesIommuFailFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AllocPagesIommuFailFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AllocPagesIommuFailFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AllocPagesIommuFailFtraceEvent::GetClassData() const { return &_class_data_; }


void AllocPagesIommuFailFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AllocPagesIommuFailFtraceEvent*>(&to_msg);
  auto& from = static_cast<const AllocPagesIommuFailFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AllocPagesIommuFailFtraceEvent::CopyFrom(const AllocPagesIommuFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesIommuFailFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesIommuFailFtraceEvent::InternalSwap(AllocPagesIommuFailFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesIommuFailFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesIommuFailFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesIommuFailFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AllocPagesIommuFailFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[1]);
}
// ===================================================================

class AllocPagesIommuStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesIommuStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AllocPagesIommuStartFtraceEvent, _impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesIommuStartFtraceEvent)
}
AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent(const AllocPagesIommuStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesIommuStartFtraceEvent)
}

inline void AllocPagesIommuStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_) { 0u }

    , decltype(_impl_.order_) { 0u }

  };
}

AllocPagesIommuStartFtraceEvent::~AllocPagesIommuStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesIommuStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesIommuStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesIommuStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AllocPagesIommuStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AllocPagesIommuStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  return target;
}

::size_t AllocPagesIommuStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AllocPagesIommuStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AllocPagesIommuStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AllocPagesIommuStartFtraceEvent::GetClassData() const { return &_class_data_; }


void AllocPagesIommuStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AllocPagesIommuStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const AllocPagesIommuStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AllocPagesIommuStartFtraceEvent::CopyFrom(const AllocPagesIommuStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesIommuStartFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesIommuStartFtraceEvent::InternalSwap(AllocPagesIommuStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesIommuStartFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesIommuStartFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesIommuStartFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AllocPagesIommuStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[2]);
}
// ===================================================================

class AllocPagesSysEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesSysEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AllocPagesSysEndFtraceEvent, _impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesSysEndFtraceEvent)
}
AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent(const AllocPagesSysEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesSysEndFtraceEvent)
}

inline void AllocPagesSysEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_) { 0u }

    , decltype(_impl_.order_) { 0u }

  };
}

AllocPagesSysEndFtraceEvent::~AllocPagesSysEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesSysEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesSysEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesSysEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesSysEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AllocPagesSysEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AllocPagesSysEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesSysEndFtraceEvent)
  return target;
}

::size_t AllocPagesSysEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AllocPagesSysEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AllocPagesSysEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AllocPagesSysEndFtraceEvent::GetClassData() const { return &_class_data_; }


void AllocPagesSysEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AllocPagesSysEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const AllocPagesSysEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AllocPagesSysEndFtraceEvent::CopyFrom(const AllocPagesSysEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesSysEndFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesSysEndFtraceEvent::InternalSwap(AllocPagesSysEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesSysEndFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesSysEndFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesSysEndFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AllocPagesSysEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[3]);
}
// ===================================================================

class AllocPagesSysFailFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesSysFailFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AllocPagesSysFailFtraceEvent, _impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesSysFailFtraceEvent)
}
AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent(const AllocPagesSysFailFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesSysFailFtraceEvent)
}

inline void AllocPagesSysFailFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_) { 0u }

    , decltype(_impl_.order_) { 0u }

  };
}

AllocPagesSysFailFtraceEvent::~AllocPagesSysFailFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesSysFailFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesSysFailFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesSysFailFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesSysFailFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AllocPagesSysFailFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AllocPagesSysFailFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesSysFailFtraceEvent)
  return target;
}

::size_t AllocPagesSysFailFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AllocPagesSysFailFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AllocPagesSysFailFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AllocPagesSysFailFtraceEvent::GetClassData() const { return &_class_data_; }


void AllocPagesSysFailFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AllocPagesSysFailFtraceEvent*>(&to_msg);
  auto& from = static_cast<const AllocPagesSysFailFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AllocPagesSysFailFtraceEvent::CopyFrom(const AllocPagesSysFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesSysFailFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesSysFailFtraceEvent::InternalSwap(AllocPagesSysFailFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesSysFailFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesSysFailFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesSysFailFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AllocPagesSysFailFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[4]);
}
// ===================================================================

class AllocPagesSysStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesSysStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AllocPagesSysStartFtraceEvent, _impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesSysStartFtraceEvent)
}
AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent(const AllocPagesSysStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesSysStartFtraceEvent)
}

inline void AllocPagesSysStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_) { 0u }

    , decltype(_impl_.order_) { 0u }

  };
}

AllocPagesSysStartFtraceEvent::~AllocPagesSysStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesSysStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesSysStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesSysStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesSysStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AllocPagesSysStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AllocPagesSysStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesSysStartFtraceEvent)
  return target;
}

::size_t AllocPagesSysStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AllocPagesSysStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AllocPagesSysStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AllocPagesSysStartFtraceEvent::GetClassData() const { return &_class_data_; }


void AllocPagesSysStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AllocPagesSysStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const AllocPagesSysStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AllocPagesSysStartFtraceEvent::CopyFrom(const AllocPagesSysStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesSysStartFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesSysStartFtraceEvent::InternalSwap(AllocPagesSysStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesSysStartFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesSysStartFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesSysStartFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AllocPagesSysStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[5]);
}
// ===================================================================

class DmaAllocContiguousRetryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<DmaAllocContiguousRetryFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DmaAllocContiguousRetryFtraceEvent, _impl_._has_bits_);
  static void set_has_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
}
DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent(const DmaAllocContiguousRetryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
}

inline void DmaAllocContiguousRetryFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tries_) { 0 }

  };
}

DmaAllocContiguousRetryFtraceEvent::~DmaAllocContiguousRetryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DmaAllocContiguousRetryFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void DmaAllocContiguousRetryFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DmaAllocContiguousRetryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tries_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DmaAllocContiguousRetryFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_tries(&has_bits);
          _impl_.tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DmaAllocContiguousRetryFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tries = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_tries(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  return target;
}

::size_t DmaAllocContiguousRetryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 tries = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_tries());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DmaAllocContiguousRetryFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DmaAllocContiguousRetryFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DmaAllocContiguousRetryFtraceEvent::GetClassData() const { return &_class_data_; }


void DmaAllocContiguousRetryFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DmaAllocContiguousRetryFtraceEvent*>(&to_msg);
  auto& from = static_cast<const DmaAllocContiguousRetryFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_tries(from._internal_tries());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DmaAllocContiguousRetryFtraceEvent::CopyFrom(const DmaAllocContiguousRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DmaAllocContiguousRetryFtraceEvent::IsInitialized() const {
  return true;
}

void DmaAllocContiguousRetryFtraceEvent::InternalSwap(DmaAllocContiguousRetryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.tries_, other->_impl_.tries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DmaAllocContiguousRetryFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[6]);
}
// ===================================================================

class IommuMapRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IommuMapRangeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IommuMapRangeFtraceEvent, _impl_._has_bits_);
  static void set_has_chunk_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_va(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IommuMapRangeFtraceEvent)
}
IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent(const IommuMapRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IommuMapRangeFtraceEvent)
}

inline void IommuMapRangeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chunk_size_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

    , decltype(_impl_.pa_) { ::uint64_t{0u} }

    , decltype(_impl_.va_) { ::uint64_t{0u} }

  };
}

IommuMapRangeFtraceEvent::~IommuMapRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IommuMapRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IommuMapRangeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IommuMapRangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IommuMapRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IommuMapRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.chunk_size_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.va_) -
        reinterpret_cast<char*>(&_impl_.chunk_size_)) + sizeof(_impl_.va_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IommuMapRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 chunk_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_chunk_size(&has_bits);
          _impl_.chunk_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pa(&has_bits);
          _impl_.pa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 va = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_va(&has_bits);
          _impl_.va_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IommuMapRangeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IommuMapRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 chunk_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_chunk_size(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_len(), target);
  }

  // optional uint64 pa = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_pa(), target);
  }

  // optional uint64 va = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_va(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IommuMapRangeFtraceEvent)
  return target;
}

::size_t IommuMapRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IommuMapRangeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 chunk_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_chunk_size());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

    // optional uint64 pa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pa());
    }

    // optional uint64 va = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_va());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IommuMapRangeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IommuMapRangeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IommuMapRangeFtraceEvent::GetClassData() const { return &_class_data_; }


void IommuMapRangeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IommuMapRangeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IommuMapRangeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IommuMapRangeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.chunk_size_ = from._impl_.chunk_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pa_ = from._impl_.pa_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.va_ = from._impl_.va_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IommuMapRangeFtraceEvent::CopyFrom(const IommuMapRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IommuMapRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IommuMapRangeFtraceEvent::IsInitialized() const {
  return true;
}

void IommuMapRangeFtraceEvent::InternalSwap(IommuMapRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IommuMapRangeFtraceEvent, _impl_.va_)
      + sizeof(IommuMapRangeFtraceEvent::_impl_.va_)
      - PROTOBUF_FIELD_OFFSET(IommuMapRangeFtraceEvent, _impl_.chunk_size_)>(
          reinterpret_cast<char*>(&_impl_.chunk_size_),
          reinterpret_cast<char*>(&other->_impl_.chunk_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IommuMapRangeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[7]);
}
// ===================================================================

class IommuSecPtblMapRangeEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IommuSecPtblMapRangeEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeEndFtraceEvent, _impl_._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sec_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_va(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
}
IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent(const IommuSecPtblMapRangeEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
}

inline void IommuSecPtblMapRangeEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_) { ::uint64_t{0u} }

    , decltype(_impl_.num_) { 0 }

    , decltype(_impl_.pa_) { 0u }

    , decltype(_impl_.va_) { ::uint64_t{0u} }

    , decltype(_impl_.sec_id_) { 0 }

  };
}

IommuSecPtblMapRangeEndFtraceEvent::~IommuSecPtblMapRangeEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IommuSecPtblMapRangeEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IommuSecPtblMapRangeEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IommuSecPtblMapRangeEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.sec_id_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.sec_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IommuSecPtblMapRangeEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_num(&has_bits);
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pa(&has_bits);
          _impl_.pa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 sec_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_sec_id(&has_bits);
          _impl_.sec_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 va = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_va(&has_bits);
          _impl_.va_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IommuSecPtblMapRangeEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 len = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_len(), target);
  }

  // optional int32 num = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_num(), target);
  }

  // optional uint32 pa = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_pa(), target);
  }

  // optional int32 sec_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_sec_id(), target);
  }

  // optional uint64 va = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_va(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  return target;
}

::size_t IommuSecPtblMapRangeEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 len = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

    // optional int32 num = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_num());
    }

    // optional uint32 pa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pa());
    }

    // optional uint64 va = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_va());
    }

    // optional int32 sec_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_sec_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IommuSecPtblMapRangeEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IommuSecPtblMapRangeEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IommuSecPtblMapRangeEndFtraceEvent::GetClassData() const { return &_class_data_; }


void IommuSecPtblMapRangeEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IommuSecPtblMapRangeEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IommuSecPtblMapRangeEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_ = from._impl_.num_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pa_ = from._impl_.pa_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.va_ = from._impl_.va_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sec_id_ = from._impl_.sec_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IommuSecPtblMapRangeEndFtraceEvent::CopyFrom(const IommuSecPtblMapRangeEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IommuSecPtblMapRangeEndFtraceEvent::IsInitialized() const {
  return true;
}

void IommuSecPtblMapRangeEndFtraceEvent::InternalSwap(IommuSecPtblMapRangeEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeEndFtraceEvent, _impl_.sec_id_)
      + sizeof(IommuSecPtblMapRangeEndFtraceEvent::_impl_.sec_id_)
      - PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeEndFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IommuSecPtblMapRangeEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[8]);
}
// ===================================================================

class IommuSecPtblMapRangeStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IommuSecPtblMapRangeStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeStartFtraceEvent, _impl_._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sec_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_va(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
}
IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent(const IommuSecPtblMapRangeStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
}

inline void IommuSecPtblMapRangeStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_) { ::uint64_t{0u} }

    , decltype(_impl_.num_) { 0 }

    , decltype(_impl_.pa_) { 0u }

    , decltype(_impl_.va_) { ::uint64_t{0u} }

    , decltype(_impl_.sec_id_) { 0 }

  };
}

IommuSecPtblMapRangeStartFtraceEvent::~IommuSecPtblMapRangeStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IommuSecPtblMapRangeStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IommuSecPtblMapRangeStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IommuSecPtblMapRangeStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.sec_id_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.sec_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IommuSecPtblMapRangeStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_num(&has_bits);
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pa(&has_bits);
          _impl_.pa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 sec_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_sec_id(&has_bits);
          _impl_.sec_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 va = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_va(&has_bits);
          _impl_.va_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IommuSecPtblMapRangeStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 len = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_len(), target);
  }

  // optional int32 num = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_num(), target);
  }

  // optional uint32 pa = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_pa(), target);
  }

  // optional int32 sec_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_sec_id(), target);
  }

  // optional uint64 va = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_va(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  return target;
}

::size_t IommuSecPtblMapRangeStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 len = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

    // optional int32 num = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_num());
    }

    // optional uint32 pa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pa());
    }

    // optional uint64 va = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_va());
    }

    // optional int32 sec_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_sec_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IommuSecPtblMapRangeStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IommuSecPtblMapRangeStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IommuSecPtblMapRangeStartFtraceEvent::GetClassData() const { return &_class_data_; }


void IommuSecPtblMapRangeStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IommuSecPtblMapRangeStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IommuSecPtblMapRangeStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_ = from._impl_.num_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pa_ = from._impl_.pa_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.va_ = from._impl_.va_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sec_id_ = from._impl_.sec_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IommuSecPtblMapRangeStartFtraceEvent::CopyFrom(const IommuSecPtblMapRangeStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IommuSecPtblMapRangeStartFtraceEvent::IsInitialized() const {
  return true;
}

void IommuSecPtblMapRangeStartFtraceEvent::InternalSwap(IommuSecPtblMapRangeStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeStartFtraceEvent, _impl_.sec_id_)
      + sizeof(IommuSecPtblMapRangeStartFtraceEvent::_impl_.sec_id_)
      - PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeStartFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IommuSecPtblMapRangeStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[9]);
}
// ===================================================================

class IonAllocBufferEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonAllocBufferEndFtraceEvent, _impl_._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonAllocBufferEndFtraceEvent)
}
IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent(const IonAllocBufferEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonAllocBufferEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_) {}

    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.flags_) {}

    , decltype(_impl_.mask_) {}

    , decltype(_impl_.len_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), _this->GetArenaForAllocation());
  }
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferEndFtraceEvent)
}

inline void IonAllocBufferEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_) {}

    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.flags_) { 0u }

    , decltype(_impl_.mask_) { 0u }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonAllocBufferEndFtraceEvent::~IonAllocBufferEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonAllocBufferEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_name_.Destroy();
  _impl_.heap_name_.Destroy();
}

void IonAllocBufferEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonAllocBufferEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.heap_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.flags_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonAllocBufferEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonAllocBufferEndFtraceEvent.client_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_mask(&has_bits);
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonAllocBufferEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_client_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonAllocBufferEndFtraceEvent.client_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 mask = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonAllocBufferEndFtraceEvent)
  return target;
}

::size_t IonAllocBufferEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_client_name());
    }

    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 mask = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mask());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonAllocBufferEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonAllocBufferEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonAllocBufferEndFtraceEvent::GetClassData() const { return &_class_data_; }


void IonAllocBufferEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonAllocBufferEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonAllocBufferEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_name(from._internal_client_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonAllocBufferEndFtraceEvent::CopyFrom(const IonAllocBufferEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferEndFtraceEvent::InternalSwap(IonAllocBufferEndFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.client_name_, lhs_arena,
                                       &other->_impl_.client_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonAllocBufferEndFtraceEvent, _impl_.len_)
      + sizeof(IonAllocBufferEndFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonAllocBufferEndFtraceEvent, _impl_.flags_)>(
          reinterpret_cast<char*>(&_impl_.flags_),
          reinterpret_cast<char*>(&other->_impl_.flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonAllocBufferEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[10]);
}
// ===================================================================

class IonAllocBufferFailFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferFailFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonAllocBufferFailFtraceEvent, _impl_._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonAllocBufferFailFtraceEvent)
}
IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent(const IonAllocBufferFailFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonAllocBufferFailFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_) {}

    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.error_) {}

    , decltype(_impl_.flags_) {}

    , decltype(_impl_.mask_) {}

    , decltype(_impl_.len_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), _this->GetArenaForAllocation());
  }
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.error_, &from._impl_.error_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferFailFtraceEvent)
}

inline void IonAllocBufferFailFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_) {}

    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.error_) { ::int64_t{0} }

    , decltype(_impl_.flags_) { 0u }

    , decltype(_impl_.mask_) { 0u }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonAllocBufferFailFtraceEvent::~IonAllocBufferFailFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferFailFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonAllocBufferFailFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_name_.Destroy();
  _impl_.heap_name_.Destroy();
}

void IonAllocBufferFailFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonAllocBufferFailFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.heap_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.error_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonAllocBufferFailFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonAllocBufferFailFtraceEvent.client_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          _impl_.error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string heap_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mask = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_mask(&has_bits);
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonAllocBufferFailFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_client_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonAllocBufferFailFtraceEvent.client_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int64 error = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_error(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_flags(), target);
  }

  // optional string heap_name = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional uint64 len = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_len(), target);
  }

  // optional uint32 mask = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonAllocBufferFailFtraceEvent)
  return target;
}

::size_t IonAllocBufferFailFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_client_name());
    }

    // optional string heap_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional int64 error = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_error());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 mask = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mask());
    }

    // optional uint64 len = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonAllocBufferFailFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonAllocBufferFailFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonAllocBufferFailFtraceEvent::GetClassData() const { return &_class_data_; }


void IonAllocBufferFailFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonAllocBufferFailFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonAllocBufferFailFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_name(from._internal_client_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonAllocBufferFailFtraceEvent::CopyFrom(const IonAllocBufferFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferFailFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferFailFtraceEvent::InternalSwap(IonAllocBufferFailFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.client_name_, lhs_arena,
                                       &other->_impl_.client_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonAllocBufferFailFtraceEvent, _impl_.len_)
      + sizeof(IonAllocBufferFailFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonAllocBufferFailFtraceEvent, _impl_.error_)>(
          reinterpret_cast<char*>(&_impl_.error_),
          reinterpret_cast<char*>(&other->_impl_.error_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonAllocBufferFailFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[11]);
}
// ===================================================================

class IonAllocBufferFallbackFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferFallbackFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonAllocBufferFallbackFtraceEvent, _impl_._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
}
IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent(const IonAllocBufferFallbackFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonAllocBufferFallbackFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_) {}

    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.error_) {}

    , decltype(_impl_.flags_) {}

    , decltype(_impl_.mask_) {}

    , decltype(_impl_.len_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), _this->GetArenaForAllocation());
  }
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.error_, &from._impl_.error_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
}

inline void IonAllocBufferFallbackFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_) {}

    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.error_) { ::int64_t{0} }

    , decltype(_impl_.flags_) { 0u }

    , decltype(_impl_.mask_) { 0u }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonAllocBufferFallbackFtraceEvent::~IonAllocBufferFallbackFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonAllocBufferFallbackFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_name_.Destroy();
  _impl_.heap_name_.Destroy();
}

void IonAllocBufferFallbackFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonAllocBufferFallbackFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.heap_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.error_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonAllocBufferFallbackFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          _impl_.error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string heap_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mask = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_mask(&has_bits);
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonAllocBufferFallbackFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_client_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int64 error = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_error(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_flags(), target);
  }

  // optional string heap_name = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional uint64 len = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_len(), target);
  }

  // optional uint32 mask = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  return target;
}

::size_t IonAllocBufferFallbackFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_client_name());
    }

    // optional string heap_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional int64 error = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_error());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 mask = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mask());
    }

    // optional uint64 len = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonAllocBufferFallbackFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonAllocBufferFallbackFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonAllocBufferFallbackFtraceEvent::GetClassData() const { return &_class_data_; }


void IonAllocBufferFallbackFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonAllocBufferFallbackFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonAllocBufferFallbackFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_name(from._internal_client_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonAllocBufferFallbackFtraceEvent::CopyFrom(const IonAllocBufferFallbackFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferFallbackFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferFallbackFtraceEvent::InternalSwap(IonAllocBufferFallbackFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.client_name_, lhs_arena,
                                       &other->_impl_.client_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonAllocBufferFallbackFtraceEvent, _impl_.len_)
      + sizeof(IonAllocBufferFallbackFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonAllocBufferFallbackFtraceEvent, _impl_.error_)>(
          reinterpret_cast<char*>(&_impl_.error_),
          reinterpret_cast<char*>(&other->_impl_.error_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonAllocBufferFallbackFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[12]);
}
// ===================================================================

class IonAllocBufferStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonAllocBufferStartFtraceEvent, _impl_._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonAllocBufferStartFtraceEvent)
}
IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent(const IonAllocBufferStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonAllocBufferStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_) {}

    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.flags_) {}

    , decltype(_impl_.mask_) {}

    , decltype(_impl_.len_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), _this->GetArenaForAllocation());
  }
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferStartFtraceEvent)
}

inline void IonAllocBufferStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_) {}

    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.flags_) { 0u }

    , decltype(_impl_.mask_) { 0u }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonAllocBufferStartFtraceEvent::~IonAllocBufferStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonAllocBufferStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_name_.Destroy();
  _impl_.heap_name_.Destroy();
}

void IonAllocBufferStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonAllocBufferStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.heap_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.flags_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonAllocBufferStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonAllocBufferStartFtraceEvent.client_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_mask(&has_bits);
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonAllocBufferStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_client_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonAllocBufferStartFtraceEvent.client_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 mask = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonAllocBufferStartFtraceEvent)
  return target;
}

::size_t IonAllocBufferStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_client_name());
    }

    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 mask = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mask());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonAllocBufferStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonAllocBufferStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonAllocBufferStartFtraceEvent::GetClassData() const { return &_class_data_; }


void IonAllocBufferStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonAllocBufferStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonAllocBufferStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_name(from._internal_client_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonAllocBufferStartFtraceEvent::CopyFrom(const IonAllocBufferStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferStartFtraceEvent::InternalSwap(IonAllocBufferStartFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.client_name_, lhs_arena,
                                       &other->_impl_.client_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonAllocBufferStartFtraceEvent, _impl_.len_)
      + sizeof(IonAllocBufferStartFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonAllocBufferStartFtraceEvent, _impl_.flags_)>(
          reinterpret_cast<char*>(&_impl_.flags_),
          reinterpret_cast<char*>(&other->_impl_.flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonAllocBufferStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[13]);
}
// ===================================================================

class IonCpAllocRetryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonCpAllocRetryFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonCpAllocRetryFtraceEvent, _impl_._has_bits_);
  static void set_has_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonCpAllocRetryFtraceEvent)
}
IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent(const IonCpAllocRetryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonCpAllocRetryFtraceEvent)
}

inline void IonCpAllocRetryFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tries_) { 0 }

  };
}

IonCpAllocRetryFtraceEvent::~IonCpAllocRetryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonCpAllocRetryFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonCpAllocRetryFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonCpAllocRetryFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonCpAllocRetryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tries_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonCpAllocRetryFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_tries(&has_bits);
          _impl_.tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonCpAllocRetryFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tries = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_tries(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonCpAllocRetryFtraceEvent)
  return target;
}

::size_t IonCpAllocRetryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 tries = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_tries());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonCpAllocRetryFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonCpAllocRetryFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonCpAllocRetryFtraceEvent::GetClassData() const { return &_class_data_; }


void IonCpAllocRetryFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonCpAllocRetryFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonCpAllocRetryFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_tries(from._internal_tries());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonCpAllocRetryFtraceEvent::CopyFrom(const IonCpAllocRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonCpAllocRetryFtraceEvent::IsInitialized() const {
  return true;
}

void IonCpAllocRetryFtraceEvent::InternalSwap(IonCpAllocRetryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.tries_, other->_impl_.tries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IonCpAllocRetryFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[14]);
}
// ===================================================================

class IonCpSecureBufferEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonCpSecureBufferEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonCpSecureBufferEndFtraceEvent, _impl_._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
}
IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent(const IonCpSecureBufferEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonCpSecureBufferEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.align_) {}

    , decltype(_impl_.flags_) {}

    , decltype(_impl_.len_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.align_, &from._impl_.align_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
}

inline void IonCpSecureBufferEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.align_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonCpSecureBufferEndFtraceEvent::~IonCpSecureBufferEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonCpSecureBufferEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonCpSecureBufferEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonCpSecureBufferEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.align_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonCpSecureBufferEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          _impl_.align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonCpSecureBufferEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_align(), target);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  return target;
}

::size_t IonCpSecureBufferEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonCpSecureBufferEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonCpSecureBufferEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonCpSecureBufferEndFtraceEvent::GetClassData() const { return &_class_data_; }


void IonCpSecureBufferEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonCpSecureBufferEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonCpSecureBufferEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.align_ = from._impl_.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonCpSecureBufferEndFtraceEvent::CopyFrom(const IonCpSecureBufferEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonCpSecureBufferEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonCpSecureBufferEndFtraceEvent::InternalSwap(IonCpSecureBufferEndFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonCpSecureBufferEndFtraceEvent, _impl_.len_)
      + sizeof(IonCpSecureBufferEndFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonCpSecureBufferEndFtraceEvent, _impl_.align_)>(
          reinterpret_cast<char*>(&_impl_.align_),
          reinterpret_cast<char*>(&other->_impl_.align_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonCpSecureBufferEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[15]);
}
// ===================================================================

class IonCpSecureBufferStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonCpSecureBufferStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonCpSecureBufferStartFtraceEvent, _impl_._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
}
IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent(const IonCpSecureBufferStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonCpSecureBufferStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.align_) {}

    , decltype(_impl_.flags_) {}

    , decltype(_impl_.len_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.align_, &from._impl_.align_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
}

inline void IonCpSecureBufferStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.align_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonCpSecureBufferStartFtraceEvent::~IonCpSecureBufferStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonCpSecureBufferStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonCpSecureBufferStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonCpSecureBufferStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.align_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonCpSecureBufferStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          _impl_.align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonCpSecureBufferStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_align(), target);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  return target;
}

::size_t IonCpSecureBufferStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonCpSecureBufferStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonCpSecureBufferStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonCpSecureBufferStartFtraceEvent::GetClassData() const { return &_class_data_; }


void IonCpSecureBufferStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonCpSecureBufferStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonCpSecureBufferStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.align_ = from._impl_.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonCpSecureBufferStartFtraceEvent::CopyFrom(const IonCpSecureBufferStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonCpSecureBufferStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonCpSecureBufferStartFtraceEvent::InternalSwap(IonCpSecureBufferStartFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonCpSecureBufferStartFtraceEvent, _impl_.len_)
      + sizeof(IonCpSecureBufferStartFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonCpSecureBufferStartFtraceEvent, _impl_.align_)>(
          reinterpret_cast<char*>(&_impl_.align_),
          reinterpret_cast<char*>(&other->_impl_.align_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonCpSecureBufferStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[16]);
}
// ===================================================================

class IonPrefetchingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonPrefetchingFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonPrefetchingFtraceEvent, _impl_._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonPrefetchingFtraceEvent)
}
IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent(const IonPrefetchingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonPrefetchingFtraceEvent)
}

inline void IonPrefetchingFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
}

IonPrefetchingFtraceEvent::~IonPrefetchingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonPrefetchingFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonPrefetchingFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonPrefetchingFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonPrefetchingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonPrefetchingFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonPrefetchingFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonPrefetchingFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonPrefetchingFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 len = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonPrefetchingFtraceEvent)
  return target;
}

::size_t IonPrefetchingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonPrefetchingFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 len = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_len());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonPrefetchingFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonPrefetchingFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonPrefetchingFtraceEvent::GetClassData() const { return &_class_data_; }


void IonPrefetchingFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonPrefetchingFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonPrefetchingFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonPrefetchingFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_len(from._internal_len());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonPrefetchingFtraceEvent::CopyFrom(const IonPrefetchingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonPrefetchingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonPrefetchingFtraceEvent::IsInitialized() const {
  return true;
}

void IonPrefetchingFtraceEvent::InternalSwap(IonPrefetchingFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.len_, other->_impl_.len_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IonPrefetchingFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[17]);
}
// ===================================================================

class IonSecureCmaAddToPoolEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAddToPoolEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolEndFtraceEvent, _impl_._has_bits_);
  static void set_has_is_prefetch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pool_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
}
IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent(const IonSecureCmaAddToPoolEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
}

inline void IonSecureCmaAddToPoolEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_) { ::uint64_t{0u} }

    , decltype(_impl_.is_prefetch_) { 0u }

    , decltype(_impl_.pool_total_) { 0 }

  };
}

IonSecureCmaAddToPoolEndFtraceEvent::~IonSecureCmaAddToPoolEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaAddToPoolEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonSecureCmaAddToPoolEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaAddToPoolEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pool_total_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.pool_total_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonSecureCmaAddToPoolEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 is_prefetch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_is_prefetch(&has_bits);
          _impl_.is_prefetch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pool_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pool_total(&has_bits);
          _impl_.pool_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonSecureCmaAddToPoolEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 is_prefetch = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_is_prefetch(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_len(), target);
  }

  // optional int32 pool_total = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_pool_total(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  return target;
}

::size_t IonSecureCmaAddToPoolEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 is_prefetch = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_is_prefetch());
    }

    // optional int32 pool_total = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pool_total());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonSecureCmaAddToPoolEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonSecureCmaAddToPoolEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonSecureCmaAddToPoolEndFtraceEvent::GetClassData() const { return &_class_data_; }


void IonSecureCmaAddToPoolEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonSecureCmaAddToPoolEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonSecureCmaAddToPoolEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_prefetch_ = from._impl_.is_prefetch_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pool_total_ = from._impl_.pool_total_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonSecureCmaAddToPoolEndFtraceEvent::CopyFrom(const IonSecureCmaAddToPoolEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAddToPoolEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAddToPoolEndFtraceEvent::InternalSwap(IonSecureCmaAddToPoolEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolEndFtraceEvent, _impl_.pool_total_)
      + sizeof(IonSecureCmaAddToPoolEndFtraceEvent::_impl_.pool_total_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolEndFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonSecureCmaAddToPoolEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[18]);
}
// ===================================================================

class IonSecureCmaAddToPoolStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAddToPoolStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolStartFtraceEvent, _impl_._has_bits_);
  static void set_has_is_prefetch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pool_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
}
IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent(const IonSecureCmaAddToPoolStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
}

inline void IonSecureCmaAddToPoolStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_) { ::uint64_t{0u} }

    , decltype(_impl_.is_prefetch_) { 0u }

    , decltype(_impl_.pool_total_) { 0 }

  };
}

IonSecureCmaAddToPoolStartFtraceEvent::~IonSecureCmaAddToPoolStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaAddToPoolStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonSecureCmaAddToPoolStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaAddToPoolStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pool_total_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.pool_total_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonSecureCmaAddToPoolStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 is_prefetch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_is_prefetch(&has_bits);
          _impl_.is_prefetch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pool_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pool_total(&has_bits);
          _impl_.pool_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonSecureCmaAddToPoolStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 is_prefetch = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_is_prefetch(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_len(), target);
  }

  // optional int32 pool_total = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_pool_total(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  return target;
}

::size_t IonSecureCmaAddToPoolStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 is_prefetch = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_is_prefetch());
    }

    // optional int32 pool_total = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pool_total());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonSecureCmaAddToPoolStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonSecureCmaAddToPoolStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonSecureCmaAddToPoolStartFtraceEvent::GetClassData() const { return &_class_data_; }


void IonSecureCmaAddToPoolStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonSecureCmaAddToPoolStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonSecureCmaAddToPoolStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_prefetch_ = from._impl_.is_prefetch_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pool_total_ = from._impl_.pool_total_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonSecureCmaAddToPoolStartFtraceEvent::CopyFrom(const IonSecureCmaAddToPoolStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAddToPoolStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAddToPoolStartFtraceEvent::InternalSwap(IonSecureCmaAddToPoolStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolStartFtraceEvent, _impl_.pool_total_)
      + sizeof(IonSecureCmaAddToPoolStartFtraceEvent::_impl_.pool_total_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolStartFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonSecureCmaAddToPoolStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[19]);
}
// ===================================================================

class IonSecureCmaAllocateEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAllocateEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateEndFtraceEvent, _impl_._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
}
IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent(const IonSecureCmaAllocateEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonSecureCmaAllocateEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.align_) {}

    , decltype(_impl_.flags_) {}

    , decltype(_impl_.len_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.align_, &from._impl_.align_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
}

inline void IonSecureCmaAllocateEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.align_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonSecureCmaAllocateEndFtraceEvent::~IonSecureCmaAllocateEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaAllocateEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonSecureCmaAllocateEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaAllocateEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.align_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonSecureCmaAllocateEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          _impl_.align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonSecureCmaAllocateEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_align(), target);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  return target;
}

::size_t IonSecureCmaAllocateEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonSecureCmaAllocateEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonSecureCmaAllocateEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonSecureCmaAllocateEndFtraceEvent::GetClassData() const { return &_class_data_; }


void IonSecureCmaAllocateEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonSecureCmaAllocateEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonSecureCmaAllocateEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.align_ = from._impl_.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonSecureCmaAllocateEndFtraceEvent::CopyFrom(const IonSecureCmaAllocateEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAllocateEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAllocateEndFtraceEvent::InternalSwap(IonSecureCmaAllocateEndFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateEndFtraceEvent, _impl_.len_)
      + sizeof(IonSecureCmaAllocateEndFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateEndFtraceEvent, _impl_.align_)>(
          reinterpret_cast<char*>(&_impl_.align_),
          reinterpret_cast<char*>(&other->_impl_.align_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonSecureCmaAllocateEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[20]);
}
// ===================================================================

class IonSecureCmaAllocateStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAllocateStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateStartFtraceEvent, _impl_._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
}
IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent(const IonSecureCmaAllocateStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonSecureCmaAllocateStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.align_) {}

    , decltype(_impl_.flags_) {}

    , decltype(_impl_.len_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.align_, &from._impl_.align_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
}

inline void IonSecureCmaAllocateStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.align_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonSecureCmaAllocateStartFtraceEvent::~IonSecureCmaAllocateStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaAllocateStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonSecureCmaAllocateStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaAllocateStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.align_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonSecureCmaAllocateStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          _impl_.align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonSecureCmaAllocateStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_align(), target);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  return target;
}

::size_t IonSecureCmaAllocateStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonSecureCmaAllocateStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonSecureCmaAllocateStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonSecureCmaAllocateStartFtraceEvent::GetClassData() const { return &_class_data_; }


void IonSecureCmaAllocateStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonSecureCmaAllocateStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonSecureCmaAllocateStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.align_ = from._impl_.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonSecureCmaAllocateStartFtraceEvent::CopyFrom(const IonSecureCmaAllocateStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAllocateStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAllocateStartFtraceEvent::InternalSwap(IonSecureCmaAllocateStartFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateStartFtraceEvent, _impl_.len_)
      + sizeof(IonSecureCmaAllocateStartFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateStartFtraceEvent, _impl_.align_)>(
          reinterpret_cast<char*>(&_impl_.align_),
          reinterpret_cast<char*>(&other->_impl_.align_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonSecureCmaAllocateStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[21]);
}
// ===================================================================

class IonSecureCmaShrinkPoolEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaShrinkPoolEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolEndFtraceEvent, _impl_._has_bits_);
  static void set_has_drained_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_skipped_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
}
IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent(const IonSecureCmaShrinkPoolEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
}

inline void IonSecureCmaShrinkPoolEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drained_size_) { ::uint64_t{0u} }

    , decltype(_impl_.skipped_size_) { ::uint64_t{0u} }

  };
}

IonSecureCmaShrinkPoolEndFtraceEvent::~IonSecureCmaShrinkPoolEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaShrinkPoolEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonSecureCmaShrinkPoolEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaShrinkPoolEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.drained_size_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.skipped_size_) -
        reinterpret_cast<char*>(&_impl_.drained_size_)) + sizeof(_impl_.skipped_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonSecureCmaShrinkPoolEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 drained_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_drained_size(&has_bits);
          _impl_.drained_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 skipped_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_skipped_size(&has_bits);
          _impl_.skipped_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonSecureCmaShrinkPoolEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 drained_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_drained_size(), target);
  }

  // optional uint64 skipped_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_skipped_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  return target;
}

::size_t IonSecureCmaShrinkPoolEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 drained_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_drained_size());
    }

    // optional uint64 skipped_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_skipped_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonSecureCmaShrinkPoolEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonSecureCmaShrinkPoolEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonSecureCmaShrinkPoolEndFtraceEvent::GetClassData() const { return &_class_data_; }


void IonSecureCmaShrinkPoolEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonSecureCmaShrinkPoolEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonSecureCmaShrinkPoolEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.drained_size_ = from._impl_.drained_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.skipped_size_ = from._impl_.skipped_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonSecureCmaShrinkPoolEndFtraceEvent::CopyFrom(const IonSecureCmaShrinkPoolEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaShrinkPoolEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaShrinkPoolEndFtraceEvent::InternalSwap(IonSecureCmaShrinkPoolEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolEndFtraceEvent, _impl_.skipped_size_)
      + sizeof(IonSecureCmaShrinkPoolEndFtraceEvent::_impl_.skipped_size_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolEndFtraceEvent, _impl_.drained_size_)>(
          reinterpret_cast<char*>(&_impl_.drained_size_),
          reinterpret_cast<char*>(&other->_impl_.drained_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonSecureCmaShrinkPoolEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[22]);
}
// ===================================================================

class IonSecureCmaShrinkPoolStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaShrinkPoolStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolStartFtraceEvent, _impl_._has_bits_);
  static void set_has_drained_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_skipped_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
}
IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent(const IonSecureCmaShrinkPoolStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
}

inline void IonSecureCmaShrinkPoolStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drained_size_) { ::uint64_t{0u} }

    , decltype(_impl_.skipped_size_) { ::uint64_t{0u} }

  };
}

IonSecureCmaShrinkPoolStartFtraceEvent::~IonSecureCmaShrinkPoolStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaShrinkPoolStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonSecureCmaShrinkPoolStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaShrinkPoolStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.drained_size_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.skipped_size_) -
        reinterpret_cast<char*>(&_impl_.drained_size_)) + sizeof(_impl_.skipped_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonSecureCmaShrinkPoolStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 drained_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_drained_size(&has_bits);
          _impl_.drained_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 skipped_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_skipped_size(&has_bits);
          _impl_.skipped_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonSecureCmaShrinkPoolStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 drained_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_drained_size(), target);
  }

  // optional uint64 skipped_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_skipped_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  return target;
}

::size_t IonSecureCmaShrinkPoolStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 drained_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_drained_size());
    }

    // optional uint64 skipped_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_skipped_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonSecureCmaShrinkPoolStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonSecureCmaShrinkPoolStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonSecureCmaShrinkPoolStartFtraceEvent::GetClassData() const { return &_class_data_; }


void IonSecureCmaShrinkPoolStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonSecureCmaShrinkPoolStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonSecureCmaShrinkPoolStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.drained_size_ = from._impl_.drained_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.skipped_size_ = from._impl_.skipped_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonSecureCmaShrinkPoolStartFtraceEvent::CopyFrom(const IonSecureCmaShrinkPoolStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaShrinkPoolStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaShrinkPoolStartFtraceEvent::InternalSwap(IonSecureCmaShrinkPoolStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolStartFtraceEvent, _impl_.skipped_size_)
      + sizeof(IonSecureCmaShrinkPoolStartFtraceEvent::_impl_.skipped_size_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolStartFtraceEvent, _impl_.drained_size_)>(
          reinterpret_cast<char*>(&_impl_.drained_size_),
          reinterpret_cast<char*>(&other->_impl_.drained_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonSecureCmaShrinkPoolStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[23]);
}
// ===================================================================

class KfreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KfreeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KfreeFtraceEvent, _impl_._has_bits_);
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KfreeFtraceEvent::KfreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KfreeFtraceEvent)
}
KfreeFtraceEvent::KfreeFtraceEvent(const KfreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KfreeFtraceEvent)
}

inline void KfreeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.call_site_) { ::uint64_t{0u} }

    , decltype(_impl_.ptr_) { ::uint64_t{0u} }

  };
}

KfreeFtraceEvent::~KfreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KfreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KfreeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KfreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KfreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KfreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.call_site_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ptr_) -
        reinterpret_cast<char*>(&_impl_.call_site_)) + sizeof(_impl_.ptr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KfreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 call_site = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ptr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KfreeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KfreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 call_site = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_call_site(), target);
  }

  // optional uint64 ptr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KfreeFtraceEvent)
  return target;
}

::size_t KfreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KfreeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 call_site = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_call_site());
    }

    // optional uint64 ptr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ptr());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KfreeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KfreeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KfreeFtraceEvent::GetClassData() const { return &_class_data_; }


void KfreeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KfreeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KfreeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KfreeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KfreeFtraceEvent::CopyFrom(const KfreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KfreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KfreeFtraceEvent::IsInitialized() const {
  return true;
}

void KfreeFtraceEvent::InternalSwap(KfreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KfreeFtraceEvent, _impl_.ptr_)
      + sizeof(KfreeFtraceEvent::_impl_.ptr_)
      - PROTOBUF_FIELD_OFFSET(KfreeFtraceEvent, _impl_.call_site_)>(
          reinterpret_cast<char*>(&_impl_.call_site_),
          reinterpret_cast<char*>(&other->_impl_.call_site_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KfreeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[24]);
}
// ===================================================================

class KmallocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmallocFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KmallocFtraceEvent, _impl_._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KmallocFtraceEvent::KmallocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmallocFtraceEvent)
}
KmallocFtraceEvent::KmallocFtraceEvent(const KmallocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmallocFtraceEvent)
}

inline void KmallocFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_) { ::uint64_t{0u} }

    , decltype(_impl_.bytes_req_) { ::uint64_t{0u} }

    , decltype(_impl_.call_site_) { ::uint64_t{0u} }

    , decltype(_impl_.ptr_) { ::uint64_t{0u} }

    , decltype(_impl_.gfp_flags_) { 0u }

  };
}

KmallocFtraceEvent::~KmallocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmallocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmallocFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmallocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmallocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmallocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.bytes_alloc_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.gfp_flags_) -
        reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.gfp_flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KmallocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          _impl_.bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          _impl_.bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ptr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KmallocFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmallocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_bytes_alloc(), target);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_bytes_req(), target);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_call_site(), target);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_gfp_flags(), target);
  }

  // optional uint64 ptr = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmallocFtraceEvent)
  return target;
}

::size_t KmallocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmallocFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_call_site());
    }

    // optional uint64 ptr = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ptr());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KmallocFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KmallocFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KmallocFtraceEvent::GetClassData() const { return &_class_data_; }


void KmallocFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KmallocFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KmallocFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmallocFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bytes_alloc_ = from._impl_.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bytes_req_ = from._impl_.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KmallocFtraceEvent::CopyFrom(const KmallocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmallocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmallocFtraceEvent::IsInitialized() const {
  return true;
}

void KmallocFtraceEvent::InternalSwap(KmallocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmallocFtraceEvent, _impl_.gfp_flags_)
      + sizeof(KmallocFtraceEvent::_impl_.gfp_flags_)
      - PROTOBUF_FIELD_OFFSET(KmallocFtraceEvent, _impl_.bytes_alloc_)>(
          reinterpret_cast<char*>(&_impl_.bytes_alloc_),
          reinterpret_cast<char*>(&other->_impl_.bytes_alloc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KmallocFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[25]);
}
// ===================================================================

class KmallocNodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmallocNodeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KmallocNodeFtraceEvent, _impl_._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_node(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

KmallocNodeFtraceEvent::KmallocNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmallocNodeFtraceEvent)
}
KmallocNodeFtraceEvent::KmallocNodeFtraceEvent(const KmallocNodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmallocNodeFtraceEvent)
}

inline void KmallocNodeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_) { ::uint64_t{0u} }

    , decltype(_impl_.bytes_req_) { ::uint64_t{0u} }

    , decltype(_impl_.call_site_) { ::uint64_t{0u} }

    , decltype(_impl_.gfp_flags_) { 0u }

    , decltype(_impl_.node_) { 0 }

    , decltype(_impl_.ptr_) { ::uint64_t{0u} }

  };
}

KmallocNodeFtraceEvent::~KmallocNodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmallocNodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmallocNodeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmallocNodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmallocNodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmallocNodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.bytes_alloc_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ptr_) -
        reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.ptr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KmallocNodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          _impl_.bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          _impl_.bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 node = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_node(&has_bits);
          _impl_.node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ptr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KmallocNodeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmallocNodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_bytes_alloc(), target);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_bytes_req(), target);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_call_site(), target);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_gfp_flags(), target);
  }

  // optional int32 node = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_node(), target);
  }

  // optional uint64 ptr = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmallocNodeFtraceEvent)
  return target;
}

::size_t KmallocNodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmallocNodeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_call_site());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

    // optional int32 node = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_node());
    }

    // optional uint64 ptr = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ptr());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KmallocNodeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KmallocNodeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KmallocNodeFtraceEvent::GetClassData() const { return &_class_data_; }


void KmallocNodeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KmallocNodeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KmallocNodeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmallocNodeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bytes_alloc_ = from._impl_.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bytes_req_ = from._impl_.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.node_ = from._impl_.node_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KmallocNodeFtraceEvent::CopyFrom(const KmallocNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmallocNodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmallocNodeFtraceEvent::IsInitialized() const {
  return true;
}

void KmallocNodeFtraceEvent::InternalSwap(KmallocNodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmallocNodeFtraceEvent, _impl_.ptr_)
      + sizeof(KmallocNodeFtraceEvent::_impl_.ptr_)
      - PROTOBUF_FIELD_OFFSET(KmallocNodeFtraceEvent, _impl_.bytes_alloc_)>(
          reinterpret_cast<char*>(&_impl_.bytes_alloc_),
          reinterpret_cast<char*>(&other->_impl_.bytes_alloc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KmallocNodeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[26]);
}
// ===================================================================

class KmemCacheAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmemCacheAllocFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KmemCacheAllocFtraceEvent, _impl_._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmemCacheAllocFtraceEvent)
}
KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent(const KmemCacheAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmemCacheAllocFtraceEvent)
}

inline void KmemCacheAllocFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_) { ::uint64_t{0u} }

    , decltype(_impl_.bytes_req_) { ::uint64_t{0u} }

    , decltype(_impl_.call_site_) { ::uint64_t{0u} }

    , decltype(_impl_.ptr_) { ::uint64_t{0u} }

    , decltype(_impl_.gfp_flags_) { 0u }

  };
}

KmemCacheAllocFtraceEvent::~KmemCacheAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmemCacheAllocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmemCacheAllocFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmemCacheAllocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmemCacheAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.bytes_alloc_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.gfp_flags_) -
        reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.gfp_flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KmemCacheAllocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          _impl_.bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          _impl_.bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ptr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KmemCacheAllocFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_bytes_alloc(), target);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_bytes_req(), target);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_call_site(), target);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_gfp_flags(), target);
  }

  // optional uint64 ptr = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmemCacheAllocFtraceEvent)
  return target;
}

::size_t KmemCacheAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_call_site());
    }

    // optional uint64 ptr = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ptr());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KmemCacheAllocFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KmemCacheAllocFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KmemCacheAllocFtraceEvent::GetClassData() const { return &_class_data_; }


void KmemCacheAllocFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KmemCacheAllocFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KmemCacheAllocFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bytes_alloc_ = from._impl_.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bytes_req_ = from._impl_.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KmemCacheAllocFtraceEvent::CopyFrom(const KmemCacheAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmemCacheAllocFtraceEvent::IsInitialized() const {
  return true;
}

void KmemCacheAllocFtraceEvent::InternalSwap(KmemCacheAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmemCacheAllocFtraceEvent, _impl_.gfp_flags_)
      + sizeof(KmemCacheAllocFtraceEvent::_impl_.gfp_flags_)
      - PROTOBUF_FIELD_OFFSET(KmemCacheAllocFtraceEvent, _impl_.bytes_alloc_)>(
          reinterpret_cast<char*>(&_impl_.bytes_alloc_),
          reinterpret_cast<char*>(&other->_impl_.bytes_alloc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KmemCacheAllocFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[27]);
}
// ===================================================================

class KmemCacheAllocNodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmemCacheAllocNodeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KmemCacheAllocNodeFtraceEvent, _impl_._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_node(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
}
KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent(const KmemCacheAllocNodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
}

inline void KmemCacheAllocNodeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_) { ::uint64_t{0u} }

    , decltype(_impl_.bytes_req_) { ::uint64_t{0u} }

    , decltype(_impl_.call_site_) { ::uint64_t{0u} }

    , decltype(_impl_.gfp_flags_) { 0u }

    , decltype(_impl_.node_) { 0 }

    , decltype(_impl_.ptr_) { ::uint64_t{0u} }

  };
}

KmemCacheAllocNodeFtraceEvent::~KmemCacheAllocNodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmemCacheAllocNodeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmemCacheAllocNodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmemCacheAllocNodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.bytes_alloc_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ptr_) -
        reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.ptr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KmemCacheAllocNodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          _impl_.bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          _impl_.bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 node = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_node(&has_bits);
          _impl_.node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ptr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KmemCacheAllocNodeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_bytes_alloc(), target);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_bytes_req(), target);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_call_site(), target);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_gfp_flags(), target);
  }

  // optional int32 node = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_node(), target);
  }

  // optional uint64 ptr = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  return target;
}

::size_t KmemCacheAllocNodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_call_site());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

    // optional int32 node = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_node());
    }

    // optional uint64 ptr = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ptr());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KmemCacheAllocNodeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KmemCacheAllocNodeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KmemCacheAllocNodeFtraceEvent::GetClassData() const { return &_class_data_; }


void KmemCacheAllocNodeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KmemCacheAllocNodeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KmemCacheAllocNodeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bytes_alloc_ = from._impl_.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bytes_req_ = from._impl_.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.node_ = from._impl_.node_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KmemCacheAllocNodeFtraceEvent::CopyFrom(const KmemCacheAllocNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmemCacheAllocNodeFtraceEvent::IsInitialized() const {
  return true;
}

void KmemCacheAllocNodeFtraceEvent::InternalSwap(KmemCacheAllocNodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmemCacheAllocNodeFtraceEvent, _impl_.ptr_)
      + sizeof(KmemCacheAllocNodeFtraceEvent::_impl_.ptr_)
      - PROTOBUF_FIELD_OFFSET(KmemCacheAllocNodeFtraceEvent, _impl_.bytes_alloc_)>(
          reinterpret_cast<char*>(&_impl_.bytes_alloc_),
          reinterpret_cast<char*>(&other->_impl_.bytes_alloc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KmemCacheAllocNodeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[28]);
}
// ===================================================================

class KmemCacheFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmemCacheFreeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KmemCacheFreeFtraceEvent, _impl_._has_bits_);
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmemCacheFreeFtraceEvent)
}
KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent(const KmemCacheFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmemCacheFreeFtraceEvent)
}

inline void KmemCacheFreeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.call_site_) { ::uint64_t{0u} }

    , decltype(_impl_.ptr_) { ::uint64_t{0u} }

  };
}

KmemCacheFreeFtraceEvent::~KmemCacheFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmemCacheFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmemCacheFreeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmemCacheFreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmemCacheFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.call_site_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ptr_) -
        reinterpret_cast<char*>(&_impl_.call_site_)) + sizeof(_impl_.ptr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KmemCacheFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 call_site = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ptr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KmemCacheFreeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 call_site = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_call_site(), target);
  }

  // optional uint64 ptr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmemCacheFreeFtraceEvent)
  return target;
}

::size_t KmemCacheFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 call_site = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_call_site());
    }

    // optional uint64 ptr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ptr());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KmemCacheFreeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KmemCacheFreeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KmemCacheFreeFtraceEvent::GetClassData() const { return &_class_data_; }


void KmemCacheFreeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KmemCacheFreeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const KmemCacheFreeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KmemCacheFreeFtraceEvent::CopyFrom(const KmemCacheFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmemCacheFreeFtraceEvent::IsInitialized() const {
  return true;
}

void KmemCacheFreeFtraceEvent::InternalSwap(KmemCacheFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmemCacheFreeFtraceEvent, _impl_.ptr_)
      + sizeof(KmemCacheFreeFtraceEvent::_impl_.ptr_)
      - PROTOBUF_FIELD_OFFSET(KmemCacheFreeFtraceEvent, _impl_.call_site_)>(
          reinterpret_cast<char*>(&_impl_.call_site_),
          reinterpret_cast<char*>(&other->_impl_.call_site_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KmemCacheFreeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[29]);
}
// ===================================================================

class MigratePagesEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MigratePagesEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MigratePagesEndFtraceEvent, _impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MigratePagesEndFtraceEvent)
}
MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent(const MigratePagesEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MigratePagesEndFtraceEvent)
}

inline void MigratePagesEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_) { 0 }

  };
}

MigratePagesEndFtraceEvent::~MigratePagesEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MigratePagesEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MigratePagesEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MigratePagesEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MigratePagesEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MigratePagesEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MigratePagesEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MigratePagesEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MigratePagesEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MigratePagesEndFtraceEvent)
  return target;
}

::size_t MigratePagesEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MigratePagesEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MigratePagesEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MigratePagesEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MigratePagesEndFtraceEvent::GetClassData() const { return &_class_data_; }


void MigratePagesEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MigratePagesEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const MigratePagesEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MigratePagesEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MigratePagesEndFtraceEvent::CopyFrom(const MigratePagesEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MigratePagesEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MigratePagesEndFtraceEvent::IsInitialized() const {
  return true;
}

void MigratePagesEndFtraceEvent::InternalSwap(MigratePagesEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MigratePagesEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[30]);
}
// ===================================================================

class MigratePagesStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MigratePagesStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MigratePagesStartFtraceEvent, _impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MigratePagesStartFtraceEvent)
}
MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent(const MigratePagesStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MigratePagesStartFtraceEvent)
}

inline void MigratePagesStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_) { 0 }

  };
}

MigratePagesStartFtraceEvent::~MigratePagesStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MigratePagesStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MigratePagesStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MigratePagesStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MigratePagesStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MigratePagesStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MigratePagesStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MigratePagesStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MigratePagesStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MigratePagesStartFtraceEvent)
  return target;
}

::size_t MigratePagesStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MigratePagesStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MigratePagesStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MigratePagesStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MigratePagesStartFtraceEvent::GetClassData() const { return &_class_data_; }


void MigratePagesStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MigratePagesStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const MigratePagesStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MigratePagesStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MigratePagesStartFtraceEvent::CopyFrom(const MigratePagesStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MigratePagesStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MigratePagesStartFtraceEvent::IsInitialized() const {
  return true;
}

void MigratePagesStartFtraceEvent::InternalSwap(MigratePagesStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MigratePagesStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[31]);
}
// ===================================================================

class MigrateRetryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MigrateRetryFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MigrateRetryFtraceEvent, _impl_._has_bits_);
  static void set_has_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MigrateRetryFtraceEvent::MigrateRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MigrateRetryFtraceEvent)
}
MigrateRetryFtraceEvent::MigrateRetryFtraceEvent(const MigrateRetryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MigrateRetryFtraceEvent)
}

inline void MigrateRetryFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tries_) { 0 }

  };
}

MigrateRetryFtraceEvent::~MigrateRetryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MigrateRetryFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MigrateRetryFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MigrateRetryFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MigrateRetryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MigrateRetryFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tries_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MigrateRetryFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_tries(&has_bits);
          _impl_.tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MigrateRetryFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MigrateRetryFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tries = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_tries(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MigrateRetryFtraceEvent)
  return target;
}

::size_t MigrateRetryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MigrateRetryFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 tries = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_tries());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MigrateRetryFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MigrateRetryFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MigrateRetryFtraceEvent::GetClassData() const { return &_class_data_; }


void MigrateRetryFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MigrateRetryFtraceEvent*>(&to_msg);
  auto& from = static_cast<const MigrateRetryFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MigrateRetryFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_tries(from._internal_tries());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MigrateRetryFtraceEvent::CopyFrom(const MigrateRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MigrateRetryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MigrateRetryFtraceEvent::IsInitialized() const {
  return true;
}

void MigrateRetryFtraceEvent::InternalSwap(MigrateRetryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.tries_, other->_impl_.tries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MigrateRetryFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[32]);
}
// ===================================================================

class MmPageAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageAllocFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MmPageAllocFtraceEvent, _impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MmPageAllocFtraceEvent::MmPageAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageAllocFtraceEvent)
}
MmPageAllocFtraceEvent::MmPageAllocFtraceEvent(const MmPageAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageAllocFtraceEvent)
}

inline void MmPageAllocFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_) { 0u }

    , decltype(_impl_.migratetype_) { 0 }

    , decltype(_impl_.page_) { ::uint64_t{0u} }

    , decltype(_impl_.pfn_) { ::uint64_t{0u} }

    , decltype(_impl_.order_) { 0u }

  };
}

MmPageAllocFtraceEvent::~MmPageAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageAllocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageAllocFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageAllocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageAllocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MmPageAllocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 migratetype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_migratetype(&has_bits);
          _impl_.migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 order = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 page = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pfn = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MmPageAllocFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageAllocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_gfp_flags(), target);
  }

  // optional int32 migratetype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_migratetype(), target);
  }

  // optional uint32 order = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_order(), target);
  }

  // optional uint64 page = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_page(), target);
  }

  // optional uint64 pfn = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageAllocFtraceEvent)
  return target;
}

::size_t MmPageAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageAllocFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gfp_flags());
    }

    // optional int32 migratetype = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_migratetype());
    }

    // optional uint64 page = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_page());
    }

    // optional uint64 pfn = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pfn());
    }

    // optional uint32 order = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MmPageAllocFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MmPageAllocFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MmPageAllocFtraceEvent::GetClassData() const { return &_class_data_; }


void MmPageAllocFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MmPageAllocFtraceEvent*>(&to_msg);
  auto& from = static_cast<const MmPageAllocFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageAllocFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.migratetype_ = from._impl_.migratetype_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MmPageAllocFtraceEvent::CopyFrom(const MmPageAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageAllocFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageAllocFtraceEvent::InternalSwap(MmPageAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageAllocFtraceEvent, _impl_.order_)
      + sizeof(MmPageAllocFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(MmPageAllocFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MmPageAllocFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[33]);
}
// ===================================================================

class MmPageAllocExtfragFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageAllocExtfragFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MmPageAllocExtfragFtraceEvent, _impl_._has_bits_);
  static void set_has_alloc_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alloc_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fallback_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fallback_order(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_change_ownership(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageAllocExtfragFtraceEvent)
}
MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent(const MmPageAllocExtfragFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageAllocExtfragFtraceEvent)
}

inline void MmPageAllocExtfragFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alloc_migratetype_) { 0 }

    , decltype(_impl_.alloc_order_) { 0 }

    , decltype(_impl_.fallback_migratetype_) { 0 }

    , decltype(_impl_.fallback_order_) { 0 }

    , decltype(_impl_.page_) { ::uint64_t{0u} }

    , decltype(_impl_.pfn_) { ::uint64_t{0u} }

    , decltype(_impl_.change_ownership_) { 0 }

  };
}

MmPageAllocExtfragFtraceEvent::~MmPageAllocExtfragFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageAllocExtfragFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageAllocExtfragFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageAllocExtfragFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.alloc_migratetype_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.change_ownership_) -
        reinterpret_cast<char*>(&_impl_.alloc_migratetype_)) + sizeof(_impl_.change_ownership_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MmPageAllocExtfragFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 alloc_migratetype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_alloc_migratetype(&has_bits);
          _impl_.alloc_migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 alloc_order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_alloc_order(&has_bits);
          _impl_.alloc_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 fallback_migratetype = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_fallback_migratetype(&has_bits);
          _impl_.fallback_migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 fallback_order = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_fallback_order(&has_bits);
          _impl_.fallback_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 page = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 change_ownership = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_change_ownership(&has_bits);
          _impl_.change_ownership_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pfn = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MmPageAllocExtfragFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 alloc_migratetype = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_alloc_migratetype(), target);
  }

  // optional int32 alloc_order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_alloc_order(), target);
  }

  // optional int32 fallback_migratetype = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_fallback_migratetype(), target);
  }

  // optional int32 fallback_order = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_fallback_order(), target);
  }

  // optional uint64 page = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_page(), target);
  }

  // optional int32 change_ownership = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_change_ownership(), target);
  }

  // optional uint64 pfn = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  return target;
}

::size_t MmPageAllocExtfragFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int32 alloc_migratetype = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_alloc_migratetype());
    }

    // optional int32 alloc_order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_alloc_order());
    }

    // optional int32 fallback_migratetype = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_fallback_migratetype());
    }

    // optional int32 fallback_order = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_fallback_order());
    }

    // optional uint64 page = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_page());
    }

    // optional uint64 pfn = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pfn());
    }

    // optional int32 change_ownership = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_change_ownership());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MmPageAllocExtfragFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MmPageAllocExtfragFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MmPageAllocExtfragFtraceEvent::GetClassData() const { return &_class_data_; }


void MmPageAllocExtfragFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MmPageAllocExtfragFtraceEvent*>(&to_msg);
  auto& from = static_cast<const MmPageAllocExtfragFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.alloc_migratetype_ = from._impl_.alloc_migratetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.alloc_order_ = from._impl_.alloc_order_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.fallback_migratetype_ = from._impl_.fallback_migratetype_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.fallback_order_ = from._impl_.fallback_order_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.change_ownership_ = from._impl_.change_ownership_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MmPageAllocExtfragFtraceEvent::CopyFrom(const MmPageAllocExtfragFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageAllocExtfragFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageAllocExtfragFtraceEvent::InternalSwap(MmPageAllocExtfragFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageAllocExtfragFtraceEvent, _impl_.change_ownership_)
      + sizeof(MmPageAllocExtfragFtraceEvent::_impl_.change_ownership_)
      - PROTOBUF_FIELD_OFFSET(MmPageAllocExtfragFtraceEvent, _impl_.alloc_migratetype_)>(
          reinterpret_cast<char*>(&_impl_.alloc_migratetype_),
          reinterpret_cast<char*>(&other->_impl_.alloc_migratetype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MmPageAllocExtfragFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[34]);
}
// ===================================================================

class MmPageAllocZoneLockedFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageAllocZoneLockedFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MmPageAllocZoneLockedFtraceEvent, _impl_._has_bits_);
  static void set_has_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
}
MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent(const MmPageAllocZoneLockedFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
}

inline void MmPageAllocZoneLockedFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.migratetype_) { 0 }

    , decltype(_impl_.order_) { 0u }

    , decltype(_impl_.page_) { ::uint64_t{0u} }

    , decltype(_impl_.pfn_) { ::uint64_t{0u} }

  };
}

MmPageAllocZoneLockedFtraceEvent::~MmPageAllocZoneLockedFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageAllocZoneLockedFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageAllocZoneLockedFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageAllocZoneLockedFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.migratetype_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pfn_) -
        reinterpret_cast<char*>(&_impl_.migratetype_)) + sizeof(_impl_.pfn_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MmPageAllocZoneLockedFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 migratetype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_migratetype(&has_bits);
          _impl_.migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pfn = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MmPageAllocZoneLockedFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 migratetype = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_migratetype(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_order(), target);
  }

  // optional uint64 page = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_page(), target);
  }

  // optional uint64 pfn = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  return target;
}

::size_t MmPageAllocZoneLockedFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 migratetype = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_migratetype());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

    // optional uint64 page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_page());
    }

    // optional uint64 pfn = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pfn());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MmPageAllocZoneLockedFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MmPageAllocZoneLockedFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MmPageAllocZoneLockedFtraceEvent::GetClassData() const { return &_class_data_; }


void MmPageAllocZoneLockedFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MmPageAllocZoneLockedFtraceEvent*>(&to_msg);
  auto& from = static_cast<const MmPageAllocZoneLockedFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.migratetype_ = from._impl_.migratetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MmPageAllocZoneLockedFtraceEvent::CopyFrom(const MmPageAllocZoneLockedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageAllocZoneLockedFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageAllocZoneLockedFtraceEvent::InternalSwap(MmPageAllocZoneLockedFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageAllocZoneLockedFtraceEvent, _impl_.pfn_)
      + sizeof(MmPageAllocZoneLockedFtraceEvent::_impl_.pfn_)
      - PROTOBUF_FIELD_OFFSET(MmPageAllocZoneLockedFtraceEvent, _impl_.migratetype_)>(
          reinterpret_cast<char*>(&_impl_.migratetype_),
          reinterpret_cast<char*>(&other->_impl_.migratetype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MmPageAllocZoneLockedFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[35]);
}
// ===================================================================

class MmPageFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageFreeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MmPageFreeFtraceEvent, _impl_._has_bits_);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MmPageFreeFtraceEvent::MmPageFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageFreeFtraceEvent)
}
MmPageFreeFtraceEvent::MmPageFreeFtraceEvent(const MmPageFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageFreeFtraceEvent)
}

inline void MmPageFreeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.page_) { ::uint64_t{0u} }

    , decltype(_impl_.pfn_) { ::uint64_t{0u} }

    , decltype(_impl_.order_) { 0u }

  };
}

MmPageFreeFtraceEvent::~MmPageFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageFreeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageFreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.page_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.page_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MmPageFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 order = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 page = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pfn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MmPageFreeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 order = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_order(), target);
  }

  // optional uint64 page = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_page(), target);
  }

  // optional uint64 pfn = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageFreeFtraceEvent)
  return target;
}

::size_t MmPageFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageFreeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 page = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_page());
    }

    // optional uint64 pfn = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pfn());
    }

    // optional uint32 order = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MmPageFreeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MmPageFreeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MmPageFreeFtraceEvent::GetClassData() const { return &_class_data_; }


void MmPageFreeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MmPageFreeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const MmPageFreeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageFreeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MmPageFreeFtraceEvent::CopyFrom(const MmPageFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageFreeFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageFreeFtraceEvent::InternalSwap(MmPageFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageFreeFtraceEvent, _impl_.order_)
      + sizeof(MmPageFreeFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(MmPageFreeFtraceEvent, _impl_.page_)>(
          reinterpret_cast<char*>(&_impl_.page_),
          reinterpret_cast<char*>(&other->_impl_.page_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MmPageFreeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[36]);
}
// ===================================================================

class MmPageFreeBatchedFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageFreeBatchedFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MmPageFreeBatchedFtraceEvent, _impl_._has_bits_);
  static void set_has_cold(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageFreeBatchedFtraceEvent)
}
MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent(const MmPageFreeBatchedFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageFreeBatchedFtraceEvent)
}

inline void MmPageFreeBatchedFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.page_) { ::uint64_t{0u} }

    , decltype(_impl_.pfn_) { ::uint64_t{0u} }

    , decltype(_impl_.cold_) { 0 }

  };
}

MmPageFreeBatchedFtraceEvent::~MmPageFreeBatchedFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageFreeBatchedFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageFreeBatchedFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageFreeBatchedFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.page_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.cold_) -
        reinterpret_cast<char*>(&_impl_.page_)) + sizeof(_impl_.cold_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MmPageFreeBatchedFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cold = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_cold(&has_bits);
          _impl_.cold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 page = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pfn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MmPageFreeBatchedFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cold = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_cold(), target);
  }

  // optional uint64 page = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_page(), target);
  }

  // optional uint64 pfn = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  return target;
}

::size_t MmPageFreeBatchedFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 page = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_page());
    }

    // optional uint64 pfn = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pfn());
    }

    // optional int32 cold = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_cold());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MmPageFreeBatchedFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MmPageFreeBatchedFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MmPageFreeBatchedFtraceEvent::GetClassData() const { return &_class_data_; }


void MmPageFreeBatchedFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MmPageFreeBatchedFtraceEvent*>(&to_msg);
  auto& from = static_cast<const MmPageFreeBatchedFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cold_ = from._impl_.cold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MmPageFreeBatchedFtraceEvent::CopyFrom(const MmPageFreeBatchedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageFreeBatchedFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageFreeBatchedFtraceEvent::InternalSwap(MmPageFreeBatchedFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageFreeBatchedFtraceEvent, _impl_.cold_)
      + sizeof(MmPageFreeBatchedFtraceEvent::_impl_.cold_)
      - PROTOBUF_FIELD_OFFSET(MmPageFreeBatchedFtraceEvent, _impl_.page_)>(
          reinterpret_cast<char*>(&_impl_.page_),
          reinterpret_cast<char*>(&other->_impl_.page_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MmPageFreeBatchedFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[37]);
}
// ===================================================================

class MmPagePcpuDrainFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPagePcpuDrainFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MmPagePcpuDrainFtraceEvent, _impl_._has_bits_);
  static void set_has_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPagePcpuDrainFtraceEvent)
}
MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent(const MmPagePcpuDrainFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPagePcpuDrainFtraceEvent)
}

inline void MmPagePcpuDrainFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.migratetype_) { 0 }

    , decltype(_impl_.order_) { 0u }

    , decltype(_impl_.page_) { ::uint64_t{0u} }

    , decltype(_impl_.pfn_) { ::uint64_t{0u} }

  };
}

MmPagePcpuDrainFtraceEvent::~MmPagePcpuDrainFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPagePcpuDrainFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPagePcpuDrainFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPagePcpuDrainFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.migratetype_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pfn_) -
        reinterpret_cast<char*>(&_impl_.migratetype_)) + sizeof(_impl_.pfn_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MmPagePcpuDrainFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 migratetype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_migratetype(&has_bits);
          _impl_.migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pfn = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MmPagePcpuDrainFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 migratetype = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_migratetype(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_order(), target);
  }

  // optional uint64 page = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_page(), target);
  }

  // optional uint64 pfn = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  return target;
}

::size_t MmPagePcpuDrainFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 migratetype = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_migratetype());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_order());
    }

    // optional uint64 page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_page());
    }

    // optional uint64 pfn = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pfn());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MmPagePcpuDrainFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MmPagePcpuDrainFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MmPagePcpuDrainFtraceEvent::GetClassData() const { return &_class_data_; }


void MmPagePcpuDrainFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MmPagePcpuDrainFtraceEvent*>(&to_msg);
  auto& from = static_cast<const MmPagePcpuDrainFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.migratetype_ = from._impl_.migratetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MmPagePcpuDrainFtraceEvent::CopyFrom(const MmPagePcpuDrainFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPagePcpuDrainFtraceEvent::IsInitialized() const {
  return true;
}

void MmPagePcpuDrainFtraceEvent::InternalSwap(MmPagePcpuDrainFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPagePcpuDrainFtraceEvent, _impl_.pfn_)
      + sizeof(MmPagePcpuDrainFtraceEvent::_impl_.pfn_)
      - PROTOBUF_FIELD_OFFSET(MmPagePcpuDrainFtraceEvent, _impl_.migratetype_)>(
          reinterpret_cast<char*>(&_impl_.migratetype_),
          reinterpret_cast<char*>(&other->_impl_.migratetype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MmPagePcpuDrainFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[38]);
}
// ===================================================================

class RssStatFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<RssStatFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RssStatFtraceEvent, _impl_._has_bits_);
  static void set_has_member(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_curr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mm_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RssStatFtraceEvent::RssStatFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.RssStatFtraceEvent)
}
RssStatFtraceEvent::RssStatFtraceEvent(const RssStatFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.RssStatFtraceEvent)
}

inline void RssStatFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.size_) { ::int64_t{0} }

    , decltype(_impl_.member_) { 0 }

    , decltype(_impl_.curr_) { 0u }

    , decltype(_impl_.mm_id_) { 0u }

  };
}

RssStatFtraceEvent::~RssStatFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.RssStatFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RssStatFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void RssStatFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RssStatFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.RssStatFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.size_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mm_id_) -
        reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.mm_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RssStatFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 member = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_member(&has_bits);
          _impl_.member_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 curr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_curr(&has_bits);
          _impl_.curr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mm_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_mm_id(&has_bits);
          _impl_.mm_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RssStatFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.RssStatFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 member = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_member(), target);
  }

  // optional int64 size = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_size(), target);
  }

  // optional uint32 curr = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_curr(), target);
  }

  // optional uint32 mm_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_mm_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.RssStatFtraceEvent)
  return target;
}

::size_t RssStatFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.RssStatFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 size = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_size());
    }

    // optional int32 member = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_member());
    }

    // optional uint32 curr = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_curr());
    }

    // optional uint32 mm_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mm_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RssStatFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RssStatFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RssStatFtraceEvent::GetClassData() const { return &_class_data_; }


void RssStatFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RssStatFtraceEvent*>(&to_msg);
  auto& from = static_cast<const RssStatFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.RssStatFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.member_ = from._impl_.member_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.curr_ = from._impl_.curr_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mm_id_ = from._impl_.mm_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RssStatFtraceEvent::CopyFrom(const RssStatFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.RssStatFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RssStatFtraceEvent::IsInitialized() const {
  return true;
}

void RssStatFtraceEvent::InternalSwap(RssStatFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RssStatFtraceEvent, _impl_.mm_id_)
      + sizeof(RssStatFtraceEvent::_impl_.mm_id_)
      - PROTOBUF_FIELD_OFFSET(RssStatFtraceEvent, _impl_.size_)>(
          reinterpret_cast<char*>(&_impl_.size_),
          reinterpret_cast<char*>(&other->_impl_.size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RssStatFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[39]);
}
// ===================================================================

class IonHeapShrinkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonHeapShrinkFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonHeapShrinkFtraceEvent, _impl_._has_bits_);
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_total_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonHeapShrinkFtraceEvent)
}
IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent(const IonHeapShrinkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonHeapShrinkFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.len_) {}

    , decltype(_impl_.total_allocated_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.total_allocated_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.total_allocated_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonHeapShrinkFtraceEvent)
}

inline void IonHeapShrinkFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.len_) { ::uint64_t{0u} }

    , decltype(_impl_.total_allocated_) { ::int64_t{0} }

  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonHeapShrinkFtraceEvent::~IonHeapShrinkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonHeapShrinkFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonHeapShrinkFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonHeapShrinkFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonHeapShrinkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.total_allocated_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.total_allocated_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonHeapShrinkFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string heap_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonHeapShrinkFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 total_allocated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_total_allocated(&has_bits);
          _impl_.total_allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonHeapShrinkFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string heap_name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonHeapShrinkFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_len(), target);
  }

  // optional int64 total_allocated = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_total_allocated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonHeapShrinkFtraceEvent)
  return target;
}

::size_t IonHeapShrinkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string heap_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

    // optional int64 total_allocated = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_total_allocated());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonHeapShrinkFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonHeapShrinkFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonHeapShrinkFtraceEvent::GetClassData() const { return &_class_data_; }


void IonHeapShrinkFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonHeapShrinkFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonHeapShrinkFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.total_allocated_ = from._impl_.total_allocated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonHeapShrinkFtraceEvent::CopyFrom(const IonHeapShrinkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonHeapShrinkFtraceEvent::IsInitialized() const {
  return true;
}

void IonHeapShrinkFtraceEvent::InternalSwap(IonHeapShrinkFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonHeapShrinkFtraceEvent, _impl_.total_allocated_)
      + sizeof(IonHeapShrinkFtraceEvent::_impl_.total_allocated_)
      - PROTOBUF_FIELD_OFFSET(IonHeapShrinkFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonHeapShrinkFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[40]);
}
// ===================================================================

class IonHeapGrowFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonHeapGrowFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonHeapGrowFtraceEvent, _impl_._has_bits_);
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_total_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonHeapGrowFtraceEvent)
}
IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent(const IonHeapGrowFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IonHeapGrowFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.len_) {}

    , decltype(_impl_.total_allocated_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.total_allocated_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.total_allocated_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonHeapGrowFtraceEvent)
}

inline void IonHeapGrowFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_) {}

    , decltype(_impl_.len_) { ::uint64_t{0u} }

    , decltype(_impl_.total_allocated_) { ::int64_t{0} }

  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonHeapGrowFtraceEvent::~IonHeapGrowFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonHeapGrowFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonHeapGrowFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonHeapGrowFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonHeapGrowFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonHeapGrowFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.total_allocated_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.total_allocated_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonHeapGrowFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string heap_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "perfetto.protos.IonHeapGrowFtraceEvent.heap_name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 total_allocated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_total_allocated(&has_bits);
          _impl_.total_allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonHeapGrowFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonHeapGrowFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string heap_name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_heap_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "perfetto.protos.IonHeapGrowFtraceEvent.heap_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_len(), target);
  }

  // optional int64 total_allocated = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_total_allocated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonHeapGrowFtraceEvent)
  return target;
}

::size_t IonHeapGrowFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonHeapGrowFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string heap_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_heap_name());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

    // optional int64 total_allocated = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_total_allocated());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonHeapGrowFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonHeapGrowFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonHeapGrowFtraceEvent::GetClassData() const { return &_class_data_; }


void IonHeapGrowFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonHeapGrowFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonHeapGrowFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonHeapGrowFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.total_allocated_ = from._impl_.total_allocated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonHeapGrowFtraceEvent::CopyFrom(const IonHeapGrowFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonHeapGrowFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonHeapGrowFtraceEvent::IsInitialized() const {
  return true;
}

void IonHeapGrowFtraceEvent::InternalSwap(IonHeapGrowFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.heap_name_, lhs_arena,
                                       &other->_impl_.heap_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonHeapGrowFtraceEvent, _impl_.total_allocated_)
      + sizeof(IonHeapGrowFtraceEvent::_impl_.total_allocated_)
      - PROTOBUF_FIELD_OFFSET(IonHeapGrowFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonHeapGrowFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[41]);
}
// ===================================================================

class IonBufferCreateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonBufferCreateFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonBufferCreateFtraceEvent, _impl_._has_bits_);
  static void set_has_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonBufferCreateFtraceEvent)
}
IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent(const IonBufferCreateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonBufferCreateFtraceEvent)
}

inline void IonBufferCreateFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.addr_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
}

IonBufferCreateFtraceEvent::~IonBufferCreateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonBufferCreateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonBufferCreateFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonBufferCreateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonBufferCreateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonBufferCreateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.addr_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.addr_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonBufferCreateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 addr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_addr(&has_bits);
          _impl_.addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonBufferCreateFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonBufferCreateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 addr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_addr(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonBufferCreateFtraceEvent)
  return target;
}

::size_t IonBufferCreateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonBufferCreateFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 addr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_addr());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonBufferCreateFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonBufferCreateFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonBufferCreateFtraceEvent::GetClassData() const { return &_class_data_; }


void IonBufferCreateFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonBufferCreateFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonBufferCreateFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonBufferCreateFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.addr_ = from._impl_.addr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonBufferCreateFtraceEvent::CopyFrom(const IonBufferCreateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonBufferCreateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonBufferCreateFtraceEvent::IsInitialized() const {
  return true;
}

void IonBufferCreateFtraceEvent::InternalSwap(IonBufferCreateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonBufferCreateFtraceEvent, _impl_.len_)
      + sizeof(IonBufferCreateFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonBufferCreateFtraceEvent, _impl_.addr_)>(
          reinterpret_cast<char*>(&_impl_.addr_),
          reinterpret_cast<char*>(&other->_impl_.addr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonBufferCreateFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[42]);
}
// ===================================================================

class IonBufferDestroyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonBufferDestroyFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IonBufferDestroyFtraceEvent, _impl_._has_bits_);
  static void set_has_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonBufferDestroyFtraceEvent)
}
IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent(const IonBufferDestroyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonBufferDestroyFtraceEvent)
}

inline void IonBufferDestroyFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.addr_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

  };
}

IonBufferDestroyFtraceEvent::~IonBufferDestroyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonBufferDestroyFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonBufferDestroyFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonBufferDestroyFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonBufferDestroyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.addr_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.addr_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IonBufferDestroyFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 addr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_addr(&has_bits);
          _impl_.addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IonBufferDestroyFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 addr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_addr(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonBufferDestroyFtraceEvent)
  return target;
}

::size_t IonBufferDestroyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 addr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_addr());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IonBufferDestroyFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IonBufferDestroyFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IonBufferDestroyFtraceEvent::GetClassData() const { return &_class_data_; }


void IonBufferDestroyFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IonBufferDestroyFtraceEvent*>(&to_msg);
  auto& from = static_cast<const IonBufferDestroyFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.addr_ = from._impl_.addr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IonBufferDestroyFtraceEvent::CopyFrom(const IonBufferDestroyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonBufferDestroyFtraceEvent::IsInitialized() const {
  return true;
}

void IonBufferDestroyFtraceEvent::InternalSwap(IonBufferDestroyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonBufferDestroyFtraceEvent, _impl_.len_)
      + sizeof(IonBufferDestroyFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonBufferDestroyFtraceEvent, _impl_.addr_)>(
          reinterpret_cast<char*>(&_impl_.addr_),
          reinterpret_cast<char*>(&other->_impl_.addr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IonBufferDestroyFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto[43]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesIommuEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesIommuEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesIommuEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesIommuFailFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesIommuFailFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesIommuFailFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesIommuStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesIommuStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesIommuStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesSysEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesSysEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesSysEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesSysFailFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesSysFailFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesSysFailFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesSysStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesSysStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesSysStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IommuMapRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IommuMapRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IommuMapRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonAllocBufferEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferFailFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferFailFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonAllocBufferFailFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferFallbackFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferFallbackFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonAllocBufferFallbackFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonAllocBufferStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonCpAllocRetryFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonCpAllocRetryFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonCpAllocRetryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonCpSecureBufferEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonCpSecureBufferEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonCpSecureBufferEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonCpSecureBufferStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonCpSecureBufferStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonCpSecureBufferStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonPrefetchingFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonPrefetchingFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonPrefetchingFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KfreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KfreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KfreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmallocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmallocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmallocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmallocNodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmallocNodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmallocNodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmemCacheAllocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmemCacheAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmemCacheAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmemCacheAllocNodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmemCacheAllocNodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmemCacheAllocNodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmemCacheFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmemCacheFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmemCacheFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MigratePagesEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MigratePagesEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MigratePagesEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MigratePagesStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MigratePagesStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MigratePagesStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MigrateRetryFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MigrateRetryFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MigrateRetryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageAllocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageAllocExtfragFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageAllocExtfragFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageAllocExtfragFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageFreeBatchedFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageFreeBatchedFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageFreeBatchedFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPagePcpuDrainFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPagePcpuDrainFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPagePcpuDrainFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::RssStatFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::RssStatFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::RssStatFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonHeapShrinkFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonHeapShrinkFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonHeapShrinkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonHeapGrowFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonHeapGrowFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonHeapGrowFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonBufferCreateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonBufferCreateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonBufferCreateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonBufferDestroyFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonBufferDestroyFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonBufferDestroyFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
