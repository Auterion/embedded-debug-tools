// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/ext4.proto

#include "protos/perfetto/trace/ftrace/ext4.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace perfetto {
namespace protos {
template <typename>
PROTOBUF_CONSTEXPR Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pos_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.flags_)*/ 0u
} {}
struct Ext4DaWriteBeginFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaWriteBeginFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaWriteBeginFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaWriteBeginFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaWriteBeginFtraceEventDefaultTypeInternal _Ext4DaWriteBeginFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pos_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.copied_)*/ 0u
} {}
struct Ext4DaWriteEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaWriteEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaWriteEndFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaWriteEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaWriteEndFtraceEventDefaultTypeInternal _Ext4DaWriteEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.parent_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.datasync_)*/ 0
} {}
struct Ext4SyncFileEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4SyncFileEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4SyncFileEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4SyncFileEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4SyncFileEnterFtraceEventDefaultTypeInternal _Ext4SyncFileEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ret_)*/ 0
} {}
struct Ext4SyncFileExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4SyncFileExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4SyncFileExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4SyncFileExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4SyncFileExitFtraceEventDefaultTypeInternal _Ext4SyncFileExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.data_blocks_)*/ 0u

  , /*decltype(_impl_.meta_blocks_)*/ 0u
} {}
struct Ext4AllocDaBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4AllocDaBlocksFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4AllocDaBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4AllocDaBlocksFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4AllocDaBlocksFtraceEventDefaultTypeInternal _Ext4AllocDaBlocksFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.block_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.logical_)*/ 0u

  , /*decltype(_impl_.lleft_)*/ 0u

  , /*decltype(_impl_.lright_)*/ 0u

  , /*decltype(_impl_.goal_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pleft_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pright_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ 0u
} {}
struct Ext4AllocateBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4AllocateBlocksFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4AllocateBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4AllocateBlocksFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4AllocateBlocksFtraceEventDefaultTypeInternal _Ext4AllocateBlocksFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.dir_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.mode_)*/ 0u
} {}
struct Ext4AllocateInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4AllocateInodeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4AllocateInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4AllocateInodeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4AllocateInodeFtraceEventDefaultTypeInternal _Ext4AllocateInodeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.new_size_)*/ ::int64_t{0}
} {}
struct Ext4BeginOrderedTruncateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4BeginOrderedTruncateFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4BeginOrderedTruncateFtraceEventDefaultTypeInternal() {}
  union {
    Ext4BeginOrderedTruncateFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4BeginOrderedTruncateFtraceEventDefaultTypeInternal _Ext4BeginOrderedTruncateFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.offset_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ ::int64_t{0}
} {}
struct Ext4CollapseRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4CollapseRangeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4CollapseRangeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4CollapseRangeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4CollapseRangeFtraceEventDefaultTypeInternal _Ext4CollapseRangeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.i_blocks_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.freed_blocks_)*/ 0

  , /*decltype(_impl_.reserved_data_blocks_)*/ 0

  , /*decltype(_impl_.reserved_meta_blocks_)*/ 0

  , /*decltype(_impl_.allocated_meta_blocks_)*/ 0

  , /*decltype(_impl_.mode_)*/ 0u
} {}
struct Ext4DaReleaseSpaceFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaReleaseSpaceFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaReleaseSpaceFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaReleaseSpaceFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaReleaseSpaceFtraceEventDefaultTypeInternal _Ext4DaReleaseSpaceFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.i_blocks_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.reserved_data_blocks_)*/ 0

  , /*decltype(_impl_.reserved_meta_blocks_)*/ 0

  , /*decltype(_impl_.mode_)*/ 0u

  , /*decltype(_impl_.md_needed_)*/ 0
} {}
struct Ext4DaReserveSpaceFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaReserveSpaceFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaReserveSpaceFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaReserveSpaceFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaReserveSpaceFtraceEventDefaultTypeInternal _Ext4DaReserveSpaceFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.i_blocks_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.used_blocks_)*/ 0

  , /*decltype(_impl_.reserved_data_blocks_)*/ 0

  , /*decltype(_impl_.reserved_meta_blocks_)*/ 0

  , /*decltype(_impl_.allocated_meta_blocks_)*/ 0

  , /*decltype(_impl_.quota_claim_)*/ 0

  , /*decltype(_impl_.mode_)*/ 0u
} {}
struct Ext4DaUpdateReserveSpaceFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaUpdateReserveSpaceFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaUpdateReserveSpaceFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaUpdateReserveSpaceFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaUpdateReserveSpaceFtraceEventDefaultTypeInternal _Ext4DaUpdateReserveSpaceFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.first_page_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nr_to_write_)*/ ::int64_t{0}

  , /*decltype(_impl_.b_blocknr_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.sync_mode_)*/ 0

  , /*decltype(_impl_.b_size_)*/ 0u

  , /*decltype(_impl_.b_state_)*/ 0u

  , /*decltype(_impl_.io_done_)*/ 0

  , /*decltype(_impl_.pages_written_)*/ 0
} {}
struct Ext4DaWritePagesFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaWritePagesFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaWritePagesFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaWritePagesFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaWritePagesFtraceEventDefaultTypeInternal _Ext4DaWritePagesFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.flags_)*/ 0u
} {}
struct Ext4DaWritePagesExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaWritePagesExtentFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaWritePagesExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaWritePagesExtentFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaWritePagesExtentFtraceEventDefaultTypeInternal _Ext4DaWritePagesExtentFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pos_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.rw_)*/ 0
} {}
struct Ext4DirectIOEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DirectIOEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DirectIOEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DirectIOEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DirectIOEnterFtraceEventDefaultTypeInternal _Ext4DirectIOEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pos_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.rw_)*/ 0

  , /*decltype(_impl_.ret_)*/ 0
} {}
struct Ext4DirectIOExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DirectIOExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DirectIOExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DirectIOExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DirectIOExitFtraceEventDefaultTypeInternal _Ext4DirectIOExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.blk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.count_)*/ ::uint64_t{0u}
} {}
struct Ext4DiscardBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DiscardBlocksFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DiscardBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DiscardBlocksFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DiscardBlocksFtraceEventDefaultTypeInternal _Ext4DiscardBlocksFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.needed_)*/ 0u
} {}
struct Ext4DiscardPreallocationsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DiscardPreallocationsFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DiscardPreallocationsFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DiscardPreallocationsFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DiscardPreallocationsFtraceEventDefaultTypeInternal _Ext4DiscardPreallocationsFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.drop_)*/ 0
} {}
struct Ext4DropInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DropInodeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DropInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DropInodeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DropInodeFtraceEventDefaultTypeInternal _Ext4DropInodeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.status_)*/ 0u
} {}
struct Ext4EsCacheExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsCacheExtentFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsCacheExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsCacheExtentFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsCacheExtentFtraceEventDefaultTypeInternal _Ext4EsCacheExtentFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u
} {}
struct Ext4EsFindDelayedExtentRangeEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsFindDelayedExtentRangeEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsFindDelayedExtentRangeEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsFindDelayedExtentRangeEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsFindDelayedExtentRangeEnterFtraceEventDefaultTypeInternal _Ext4EsFindDelayedExtentRangeEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.status_)*/ ::uint64_t{0u}
} {}
struct Ext4EsFindDelayedExtentRangeExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsFindDelayedExtentRangeExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsFindDelayedExtentRangeExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsFindDelayedExtentRangeExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsFindDelayedExtentRangeExitFtraceEventDefaultTypeInternal _Ext4EsFindDelayedExtentRangeExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.status_)*/ ::uint64_t{0u}
} {}
struct Ext4EsInsertExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsInsertExtentFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsInsertExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsInsertExtentFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsInsertExtentFtraceEventDefaultTypeInternal _Ext4EsInsertExtentFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u
} {}
struct Ext4EsLookupExtentEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsLookupExtentEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsLookupExtentEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsLookupExtentEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsLookupExtentEnterFtraceEventDefaultTypeInternal _Ext4EsLookupExtentEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.status_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.found_)*/ 0
} {}
struct Ext4EsLookupExtentExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsLookupExtentExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsLookupExtentExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsLookupExtentExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsLookupExtentExitFtraceEventDefaultTypeInternal _Ext4EsLookupExtentExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ ::int64_t{0}
} {}
struct Ext4EsRemoveExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsRemoveExtentFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsRemoveExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsRemoveExtentFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsRemoveExtentFtraceEventDefaultTypeInternal _Ext4EsRemoveExtentFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.scan_time_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nr_shrunk_)*/ 0

  , /*decltype(_impl_.nr_skipped_)*/ 0

  , /*decltype(_impl_.retried_)*/ 0
} {}
struct Ext4EsShrinkFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsShrinkFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsShrinkFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsShrinkFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsShrinkFtraceEventDefaultTypeInternal _Ext4EsShrinkFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nr_to_scan_)*/ 0

  , /*decltype(_impl_.cache_cnt_)*/ 0
} {}
struct Ext4EsShrinkCountFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsShrinkCountFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsShrinkCountFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsShrinkCountFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsShrinkCountFtraceEventDefaultTypeInternal _Ext4EsShrinkCountFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nr_to_scan_)*/ 0

  , /*decltype(_impl_.cache_cnt_)*/ 0
} {}
struct Ext4EsShrinkScanEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsShrinkScanEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsShrinkScanEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsShrinkScanEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsShrinkScanEnterFtraceEventDefaultTypeInternal _Ext4EsShrinkScanEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nr_shrunk_)*/ 0

  , /*decltype(_impl_.cache_cnt_)*/ 0
} {}
struct Ext4EsShrinkScanExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsShrinkScanExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsShrinkScanExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsShrinkScanExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsShrinkScanExitFtraceEventDefaultTypeInternal _Ext4EsShrinkScanExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nlink_)*/ 0
} {}
struct Ext4EvictInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EvictInodeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EvictInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EvictInodeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EvictInodeFtraceEventDefaultTypeInternal _Ext4EvictInodeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.m_lblk_)*/ 0u

  , /*decltype(_impl_.m_len_)*/ 0u

  , /*decltype(_impl_.u_lblk_)*/ 0u

  , /*decltype(_impl_.u_len_)*/ 0u

  , /*decltype(_impl_.u_pblk_)*/ ::uint64_t{0u}
} {}
struct Ext4ExtConvertToInitializedEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtConvertToInitializedEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtConvertToInitializedEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtConvertToInitializedEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtConvertToInitializedEnterFtraceEventDefaultTypeInternal _Ext4ExtConvertToInitializedEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.m_lblk_)*/ 0u

  , /*decltype(_impl_.m_len_)*/ 0u

  , /*decltype(_impl_.u_lblk_)*/ 0u

  , /*decltype(_impl_.u_len_)*/ 0u

  , /*decltype(_impl_.u_pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.i_lblk_)*/ 0u

  , /*decltype(_impl_.i_len_)*/ 0u

  , /*decltype(_impl_.i_pblk_)*/ ::uint64_t{0u}
} {}
struct Ext4ExtConvertToInitializedFastpathFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtConvertToInitializedFastpathFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtConvertToInitializedFastpathFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtConvertToInitializedFastpathFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtConvertToInitializedFastpathFtraceEventDefaultTypeInternal _Ext4ExtConvertToInitializedFastpathFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ 0

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.allocated_)*/ 0u

  , /*decltype(_impl_.newblk_)*/ ::uint64_t{0u}
} {}
struct Ext4ExtHandleUnwrittenExtentsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtHandleUnwrittenExtentsFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtHandleUnwrittenExtentsFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtHandleUnwrittenExtentsFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtHandleUnwrittenExtentsFtraceEventDefaultTypeInternal _Ext4ExtHandleUnwrittenExtentsFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.ret_)*/ 0
} {}
struct Ext4ExtInCacheFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtInCacheFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtInCacheFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtInCacheFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtInCacheFtraceEventDefaultTypeInternal _Ext4ExtInCacheFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u
} {}
struct Ext4ExtLoadExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtLoadExtentFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtLoadExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtLoadExtentFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtLoadExtentFtraceEventDefaultTypeInternal _Ext4ExtLoadExtentFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.flags_)*/ 0u
} {}
struct Ext4ExtMapBlocksEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtMapBlocksEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtMapBlocksEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtMapBlocksEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtMapBlocksEnterFtraceEventDefaultTypeInternal _Ext4ExtMapBlocksEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ 0u

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.mflags_)*/ 0u

  , /*decltype(_impl_.ret_)*/ 0
} {}
struct Ext4ExtMapBlocksExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtMapBlocksExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtMapBlocksExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtMapBlocksExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtMapBlocksExitFtraceEventDefaultTypeInternal _Ext4ExtMapBlocksExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.start_)*/ ::uint64_t{0u}
} {}
struct Ext4ExtPutInCacheFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtPutInCacheFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtPutInCacheFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtPutInCacheFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtPutInCacheFtraceEventDefaultTypeInternal _Ext4ExtPutInCacheFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.start_)*/ 0u

  , /*decltype(_impl_.end_)*/ 0u

  , /*decltype(_impl_.depth_)*/ 0
} {}
struct Ext4ExtRemoveSpaceFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtRemoveSpaceFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtRemoveSpaceFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtRemoveSpaceFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtRemoveSpaceFtraceEventDefaultTypeInternal _Ext4ExtRemoveSpaceFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.start_)*/ 0u

  , /*decltype(_impl_.end_)*/ 0u

  , /*decltype(_impl_.partial_)*/ ::int64_t{0}

  , /*decltype(_impl_.depth_)*/ 0

  , /*decltype(_impl_.eh_entries_)*/ 0u

  , /*decltype(_impl_.pc_pclu_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pc_lblk_)*/ 0u

  , /*decltype(_impl_.pc_state_)*/ 0
} {}
struct Ext4ExtRemoveSpaceDoneFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtRemoveSpaceDoneFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtRemoveSpaceDoneFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtRemoveSpaceDoneFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtRemoveSpaceDoneFtraceEventDefaultTypeInternal _Ext4ExtRemoveSpaceDoneFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}
} {}
struct Ext4ExtRmIdxFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtRmIdxFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtRmIdxFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtRmIdxFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtRmIdxFtraceEventDefaultTypeInternal _Ext4ExtRmIdxFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.partial_)*/ ::int64_t{0}

  , /*decltype(_impl_.start_)*/ 0u

  , /*decltype(_impl_.ee_lblk_)*/ 0u

  , /*decltype(_impl_.ee_pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ee_len_)*/ 0

  , /*decltype(_impl_.pc_lblk_)*/ 0u

  , /*decltype(_impl_.pc_pclu_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pc_state_)*/ 0
} {}
struct Ext4ExtRmLeafFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtRmLeafFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtRmLeafFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtRmLeafFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtRmLeafFtraceEventDefaultTypeInternal _Ext4ExtRmLeafFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u
} {}
struct Ext4ExtShowExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtShowExtentFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtShowExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtShowExtentFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtShowExtentFtraceEventDefaultTypeInternal _Ext4ExtShowExtentFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.offset_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ ::int64_t{0}

  , /*decltype(_impl_.pos_)*/ ::int64_t{0}

  , /*decltype(_impl_.mode_)*/ 0
} {}
struct Ext4FallocateEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FallocateEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FallocateEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FallocateEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FallocateEnterFtraceEventDefaultTypeInternal _Ext4FallocateEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pos_)*/ ::int64_t{0}

  , /*decltype(_impl_.blocks_)*/ 0u

  , /*decltype(_impl_.ret_)*/ 0
} {}
struct Ext4FallocateExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FallocateExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FallocateExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FallocateExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FallocateExitFtraceEventDefaultTypeInternal _Ext4FallocateExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.from_)*/ 0u

  , /*decltype(_impl_.to_)*/ 0u

  , /*decltype(_impl_.reverse_)*/ 0

  , /*decltype(_impl_.found_)*/ 0

  , /*decltype(_impl_.found_blk_)*/ 0u
} {}
struct Ext4FindDelallocRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FindDelallocRangeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FindDelallocRangeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FindDelallocRangeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FindDelallocRangeFtraceEventDefaultTypeInternal _Ext4FindDelallocRangeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.block_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.is_metadata_)*/ 0

  , /*decltype(_impl_.mode_)*/ 0u
} {}
struct Ext4ForgetFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ForgetFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ForgetFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ForgetFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ForgetFtraceEventDefaultTypeInternal _Ext4ForgetFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.block_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.count_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ 0

  , /*decltype(_impl_.mode_)*/ 0u
} {}
struct Ext4FreeBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FreeBlocksFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FreeBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FreeBlocksFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FreeBlocksFtraceEventDefaultTypeInternal _Ext4FreeBlocksFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.uid_)*/ 0u

  , /*decltype(_impl_.gid_)*/ 0u

  , /*decltype(_impl_.blocks_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.mode_)*/ 0u
} {}
struct Ext4FreeInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FreeInodeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FreeInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FreeInodeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FreeInodeFtraceEventDefaultTypeInternal _Ext4FreeInodeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ 0u

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.ret_)*/ 0
} {}
struct Ext4GetImpliedClusterAllocExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4GetImpliedClusterAllocExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4GetImpliedClusterAllocExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4GetImpliedClusterAllocExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4GetImpliedClusterAllocExitFtraceEventDefaultTypeInternal _Ext4GetImpliedClusterAllocExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u
} {}
struct Ext4GetReservedClusterAllocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4GetReservedClusterAllocFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4GetReservedClusterAllocFtraceEventDefaultTypeInternal() {}
  union {
    Ext4GetReservedClusterAllocFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4GetReservedClusterAllocFtraceEventDefaultTypeInternal _Ext4GetReservedClusterAllocFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.flags_)*/ 0u
} {}
struct Ext4IndMapBlocksEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4IndMapBlocksEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4IndMapBlocksEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4IndMapBlocksEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4IndMapBlocksEnterFtraceEventDefaultTypeInternal _Ext4IndMapBlocksEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ 0u

  , /*decltype(_impl_.lblk_)*/ 0u

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.mflags_)*/ 0u

  , /*decltype(_impl_.ret_)*/ 0
} {}
struct Ext4IndMapBlocksExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4IndMapBlocksExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4IndMapBlocksExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4IndMapBlocksExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4IndMapBlocksExitFtraceEventDefaultTypeInternal _Ext4IndMapBlocksExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.offset_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ ::int64_t{0}
} {}
struct Ext4InsertRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4InsertRangeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4InsertRangeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4InsertRangeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4InsertRangeFtraceEventDefaultTypeInternal _Ext4InsertRangeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.index_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.offset_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.length_)*/ 0u
} {}
struct Ext4InvalidatepageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4InvalidatepageFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4InvalidatepageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4InvalidatepageFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4InvalidatepageFtraceEventDefaultTypeInternal _Ext4InvalidatepageFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.blocks_)*/ 0

  , /*decltype(_impl_.rsv_blocks_)*/ 0

  , /*decltype(_impl_.nblocks_)*/ 0

  , /*decltype(_impl_.revoke_creds_)*/ 0
} {}
struct Ext4JournalStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4JournalStartFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4JournalStartFtraceEventDefaultTypeInternal() {}
  union {
    Ext4JournalStartFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4JournalStartFtraceEventDefaultTypeInternal _Ext4JournalStartFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.blocks_)*/ 0
} {}
struct Ext4JournalStartReservedFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4JournalStartReservedFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4JournalStartReservedFtraceEventDefaultTypeInternal() {}
  union {
    Ext4JournalStartReservedFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4JournalStartReservedFtraceEventDefaultTypeInternal _Ext4JournalStartReservedFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.index_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.offset_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.length_)*/ 0u
} {}
struct Ext4JournalledInvalidatepageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4JournalledInvalidatepageFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4JournalledInvalidatepageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4JournalledInvalidatepageFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4JournalledInvalidatepageFtraceEventDefaultTypeInternal _Ext4JournalledInvalidatepageFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pos_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.copied_)*/ 0u
} {}
struct Ext4JournalledWriteEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4JournalledWriteEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4JournalledWriteEndFtraceEventDefaultTypeInternal() {}
  union {
    Ext4JournalledWriteEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4JournalledWriteEndFtraceEventDefaultTypeInternal _Ext4JournalledWriteEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}
} {}
struct Ext4LoadInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4LoadInodeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4LoadInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4LoadInodeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4LoadInodeFtraceEventDefaultTypeInternal _Ext4LoadInodeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.group_)*/ 0u
} {}
struct Ext4LoadInodeBitmapFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4LoadInodeBitmapFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4LoadInodeBitmapFtraceEventDefaultTypeInternal() {}
  union {
    Ext4LoadInodeBitmapFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4LoadInodeBitmapFtraceEventDefaultTypeInternal _Ext4LoadInodeBitmapFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ip_)*/ ::uint64_t{0u}
} {}
struct Ext4MarkInodeDirtyFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MarkInodeDirtyFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MarkInodeDirtyFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MarkInodeDirtyFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MarkInodeDirtyFtraceEventDefaultTypeInternal _Ext4MarkInodeDirtyFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.group_)*/ 0u
} {}
struct Ext4MbBitmapLoadFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbBitmapLoadFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbBitmapLoadFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbBitmapLoadFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbBitmapLoadFtraceEventDefaultTypeInternal _Ext4MbBitmapLoadFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.group_)*/ 0u
} {}
struct Ext4MbBuddyBitmapLoadFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbBuddyBitmapLoadFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbBuddyBitmapLoadFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbBuddyBitmapLoadFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbBuddyBitmapLoadFtraceEventDefaultTypeInternal _Ext4MbBuddyBitmapLoadFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.needed_)*/ 0
} {}
struct Ext4MbDiscardPreallocationsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbDiscardPreallocationsFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbDiscardPreallocationsFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbDiscardPreallocationsFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbDiscardPreallocationsFtraceEventDefaultTypeInternal _Ext4MbDiscardPreallocationsFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pa_pstart_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pa_lstart_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pa_len_)*/ 0u
} {}
struct Ext4MbNewGroupPaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbNewGroupPaFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbNewGroupPaFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbNewGroupPaFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbNewGroupPaFtraceEventDefaultTypeInternal _Ext4MbNewGroupPaFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pa_pstart_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pa_lstart_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pa_len_)*/ 0u
} {}
struct Ext4MbNewInodePaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbNewInodePaFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbNewInodePaFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbNewInodePaFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbNewInodePaFtraceEventDefaultTypeInternal _Ext4MbNewInodePaFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pa_pstart_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pa_len_)*/ 0u
} {}
struct Ext4MbReleaseGroupPaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbReleaseGroupPaFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbReleaseGroupPaFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbReleaseGroupPaFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbReleaseGroupPaFtraceEventDefaultTypeInternal _Ext4MbReleaseGroupPaFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.block_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.count_)*/ 0u
} {}
struct Ext4MbReleaseInodePaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbReleaseInodePaFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbReleaseInodePaFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbReleaseInodePaFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbReleaseInodePaFtraceEventDefaultTypeInternal _Ext4MbReleaseInodePaFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.orig_logical_)*/ 0u

  , /*decltype(_impl_.orig_start_)*/ 0

  , /*decltype(_impl_.orig_group_)*/ 0u

  , /*decltype(_impl_.orig_len_)*/ 0

  , /*decltype(_impl_.goal_logical_)*/ 0u

  , /*decltype(_impl_.goal_start_)*/ 0

  , /*decltype(_impl_.goal_group_)*/ 0u

  , /*decltype(_impl_.goal_len_)*/ 0

  , /*decltype(_impl_.result_logical_)*/ 0u

  , /*decltype(_impl_.result_start_)*/ 0

  , /*decltype(_impl_.result_group_)*/ 0u

  , /*decltype(_impl_.result_len_)*/ 0

  , /*decltype(_impl_.found_)*/ 0u

  , /*decltype(_impl_.groups_)*/ 0u

  , /*decltype(_impl_.buddy_)*/ 0u

  , /*decltype(_impl_.flags_)*/ 0u

  , /*decltype(_impl_.tail_)*/ 0u

  , /*decltype(_impl_.cr_)*/ 0u
} {}
struct Ext4MballocAllocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MballocAllocFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MballocAllocFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MballocAllocFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MballocAllocFtraceEventDefaultTypeInternal _Ext4MballocAllocFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.result_start_)*/ 0

  , /*decltype(_impl_.result_group_)*/ 0u

  , /*decltype(_impl_.result_len_)*/ 0
} {}
struct Ext4MballocDiscardFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MballocDiscardFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MballocDiscardFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MballocDiscardFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MballocDiscardFtraceEventDefaultTypeInternal _Ext4MballocDiscardFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.result_start_)*/ 0

  , /*decltype(_impl_.result_group_)*/ 0u

  , /*decltype(_impl_.result_len_)*/ 0
} {}
struct Ext4MballocFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MballocFreeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MballocFreeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MballocFreeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MballocFreeFtraceEventDefaultTypeInternal _Ext4MballocFreeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.orig_logical_)*/ 0u

  , /*decltype(_impl_.orig_start_)*/ 0

  , /*decltype(_impl_.orig_group_)*/ 0u

  , /*decltype(_impl_.orig_len_)*/ 0

  , /*decltype(_impl_.result_logical_)*/ 0u

  , /*decltype(_impl_.result_start_)*/ 0

  , /*decltype(_impl_.result_group_)*/ 0u

  , /*decltype(_impl_.result_len_)*/ 0
} {}
struct Ext4MballocPreallocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MballocPreallocFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MballocPreallocFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MballocPreallocFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MballocPreallocFtraceEventDefaultTypeInternal _Ext4MballocPreallocFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.orig_ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.uid_)*/ 0u

  , /*decltype(_impl_.gid_)*/ 0u

  , /*decltype(_impl_.mode_)*/ 0u
} {}
struct Ext4OtherInodeUpdateTimeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4OtherInodeUpdateTimeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4OtherInodeUpdateTimeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4OtherInodeUpdateTimeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4OtherInodeUpdateTimeFtraceEventDefaultTypeInternal _Ext4OtherInodeUpdateTimeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.offset_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ ::int64_t{0}

  , /*decltype(_impl_.mode_)*/ 0
} {}
struct Ext4PunchHoleFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4PunchHoleFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4PunchHoleFtraceEventDefaultTypeInternal() {}
  union {
    Ext4PunchHoleFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4PunchHoleFtraceEventDefaultTypeInternal _Ext4PunchHoleFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.group_)*/ 0u

  , /*decltype(_impl_.prefetch_)*/ 0u
} {}
struct Ext4ReadBlockBitmapLoadFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ReadBlockBitmapLoadFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ReadBlockBitmapLoadFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ReadBlockBitmapLoadFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ReadBlockBitmapLoadFtraceEventDefaultTypeInternal _Ext4ReadBlockBitmapLoadFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.index_)*/ ::uint64_t{0u}
} {}
struct Ext4ReadpageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ReadpageFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ReadpageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ReadpageFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ReadpageFtraceEventDefaultTypeInternal _Ext4ReadpageFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.index_)*/ ::uint64_t{0u}
} {}
struct Ext4ReleasepageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ReleasepageFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ReleasepageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ReleasepageFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ReleasepageFtraceEventDefaultTypeInternal _Ext4ReleasepageFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.from_)*/ 0u

  , /*decltype(_impl_.to_)*/ 0u

  , /*decltype(_impl_.partial_)*/ ::int64_t{0}

  , /*decltype(_impl_.ee_pblk_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ee_lblk_)*/ 0u

  , /*decltype(_impl_.ee_len_)*/ 0u

  , /*decltype(_impl_.pc_pclu_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pc_lblk_)*/ 0u

  , /*decltype(_impl_.pc_state_)*/ 0
} {}
struct Ext4RemoveBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4RemoveBlocksFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4RemoveBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4RemoveBlocksFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4RemoveBlocksFtraceEventDefaultTypeInternal _Ext4RemoveBlocksFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.logical_)*/ 0u

  , /*decltype(_impl_.lleft_)*/ 0u

  , /*decltype(_impl_.lright_)*/ 0u

  , /*decltype(_impl_.goal_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pleft_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pright_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.flags_)*/ 0u
} {}
struct Ext4RequestBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4RequestBlocksFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4RequestBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4RequestBlocksFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4RequestBlocksFtraceEventDefaultTypeInternal _Ext4RequestBlocksFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.dir_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.mode_)*/ 0u
} {}
struct Ext4RequestInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4RequestInodeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4RequestInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4RequestInodeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4RequestInodeFtraceEventDefaultTypeInternal _Ext4RequestInodeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.wait_)*/ 0
} {}
struct Ext4SyncFsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4SyncFsFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4SyncFsFtraceEventDefaultTypeInternal() {}
  union {
    Ext4SyncFsFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4SyncFsFtraceEventDefaultTypeInternal _Ext4SyncFsFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_major_)*/ 0

  , /*decltype(_impl_.dev_minor_)*/ 0

  , /*decltype(_impl_.group_)*/ 0u

  , /*decltype(_impl_.start_)*/ 0

  , /*decltype(_impl_.len_)*/ 0
} {}
struct Ext4TrimAllFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4TrimAllFreeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4TrimAllFreeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4TrimAllFreeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4TrimAllFreeFtraceEventDefaultTypeInternal _Ext4TrimAllFreeFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_major_)*/ 0

  , /*decltype(_impl_.dev_minor_)*/ 0

  , /*decltype(_impl_.group_)*/ 0u

  , /*decltype(_impl_.start_)*/ 0

  , /*decltype(_impl_.len_)*/ 0
} {}
struct Ext4TrimExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4TrimExtentFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4TrimExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4TrimExtentFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4TrimExtentFtraceEventDefaultTypeInternal _Ext4TrimExtentFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.blocks_)*/ ::uint64_t{0u}
} {}
struct Ext4TruncateEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4TruncateEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4TruncateEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4TruncateEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4TruncateEnterFtraceEventDefaultTypeInternal _Ext4TruncateEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.blocks_)*/ ::uint64_t{0u}
} {}
struct Ext4TruncateExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4TruncateExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4TruncateExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4TruncateExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4TruncateExitFtraceEventDefaultTypeInternal _Ext4TruncateExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.parent_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.size_)*/ ::int64_t{0}
} {}
struct Ext4UnlinkEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4UnlinkEnterFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4UnlinkEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4UnlinkEnterFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4UnlinkEnterFtraceEventDefaultTypeInternal _Ext4UnlinkEnterFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ret_)*/ 0
} {}
struct Ext4UnlinkExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4UnlinkExitFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4UnlinkExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4UnlinkExitFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4UnlinkExitFtraceEventDefaultTypeInternal _Ext4UnlinkExitFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pos_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.flags_)*/ 0u
} {}
struct Ext4WriteBeginFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WriteBeginFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WriteBeginFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WriteBeginFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WriteBeginFtraceEventDefaultTypeInternal _Ext4WriteBeginFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.pos_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ 0u

  , /*decltype(_impl_.copied_)*/ 0u
} {}
struct Ext4WriteEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WriteEndFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WriteEndFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WriteEndFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WriteEndFtraceEventDefaultTypeInternal _Ext4WriteEndFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.index_)*/ ::uint64_t{0u}
} {}
struct Ext4WritepageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WritepageFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WritepageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WritepageFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WritepageFtraceEventDefaultTypeInternal _Ext4WritepageFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.nr_to_write_)*/ ::int64_t{0}

  , /*decltype(_impl_.pages_skipped_)*/ ::int64_t{0}

  , /*decltype(_impl_.range_start_)*/ ::int64_t{0}

  , /*decltype(_impl_.range_end_)*/ ::int64_t{0}

  , /*decltype(_impl_.writeback_index_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.sync_mode_)*/ 0

  , /*decltype(_impl_.for_kupdate_)*/ 0u

  , /*decltype(_impl_.range_cyclic_)*/ 0u
} {}
struct Ext4WritepagesFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WritepagesFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WritepagesFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WritepagesFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WritepagesFtraceEventDefaultTypeInternal _Ext4WritepagesFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ret_)*/ 0

  , /*decltype(_impl_.pages_written_)*/ 0

  , /*decltype(_impl_.pages_skipped_)*/ ::int64_t{0}

  , /*decltype(_impl_.writeback_index_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.sync_mode_)*/ 0
} {}
struct Ext4WritepagesResultFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WritepagesResultFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WritepagesResultFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WritepagesResultFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WritepagesResultFtraceEventDefaultTypeInternal _Ext4WritepagesResultFtraceEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.ino_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.offset_)*/ ::int64_t{0}

  , /*decltype(_impl_.len_)*/ ::int64_t{0}

  , /*decltype(_impl_.mode_)*/ 0
} {}
struct Ext4ZeroRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ZeroRangeFtraceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ZeroRangeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ZeroRangeFtraceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ZeroRangeFtraceEventDefaultTypeInternal _Ext4ZeroRangeFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
static ::_pb::Metadata file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[95];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto = nullptr;
const ::uint32_t TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteBeginFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteBeginFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteBeginFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteBeginFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteBeginFtraceEvent, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteBeginFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteBeginFtraceEvent, _impl_.flags_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteEndFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteEndFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteEndFtraceEvent, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteEndFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWriteEndFtraceEvent, _impl_.copied_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileEnterFtraceEvent, _impl_.parent_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileEnterFtraceEvent, _impl_.datasync_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileExitFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFileExitFtraceEvent, _impl_.ret_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocDaBlocksFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocDaBlocksFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocDaBlocksFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocDaBlocksFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocDaBlocksFtraceEvent, _impl_.data_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocDaBlocksFtraceEvent, _impl_.meta_blocks_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.block_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.logical_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.lleft_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.lright_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.goal_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.pleft_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.pright_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateBlocksFtraceEvent, _impl_.flags_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateInodeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateInodeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateInodeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateInodeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateInodeFtraceEvent, _impl_.dir_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4AllocateInodeFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent, _impl_.new_size_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4CollapseRangeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4CollapseRangeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4CollapseRangeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4CollapseRangeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4CollapseRangeFtraceEvent, _impl_.offset_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4CollapseRangeFtraceEvent, _impl_.len_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _impl_.i_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _impl_.freed_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _impl_.reserved_data_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _impl_.reserved_meta_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _impl_.allocated_meta_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent, _impl_.i_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent, _impl_.reserved_data_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent, _impl_.reserved_meta_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent, _impl_.mode_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent, _impl_.md_needed_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.i_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.used_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.reserved_data_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.reserved_meta_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.allocated_meta_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.quota_claim_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.first_page_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.nr_to_write_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.sync_mode_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.b_blocknr_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.b_size_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.b_state_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.io_done_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesFtraceEvent, _impl_.pages_written_),
    0,
    1,
    2,
    3,
    5,
    4,
    6,
    7,
    8,
    9,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent, _impl_.flags_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOEnterFtraceEvent, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOEnterFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOEnterFtraceEvent, _impl_.rw_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOExitFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOExitFtraceEvent, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOExitFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOExitFtraceEvent, _impl_.rw_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DirectIOExitFtraceEvent, _impl_.ret_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardBlocksFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardBlocksFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardBlocksFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardBlocksFtraceEvent, _impl_.blk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardBlocksFtraceEvent, _impl_.count_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent, _impl_.needed_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DropInodeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DropInodeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DropInodeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DropInodeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4DropInodeFtraceEvent, _impl_.drop_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsCacheExtentFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsCacheExtentFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsCacheExtentFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsCacheExtentFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsCacheExtentFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsCacheExtentFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsCacheExtentFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsCacheExtentFtraceEvent, _impl_.status_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent, _impl_.lblk_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_.status_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsInsertExtentFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsInsertExtentFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsInsertExtentFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsInsertExtentFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsInsertExtentFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsInsertExtentFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsInsertExtentFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsInsertExtentFtraceEvent, _impl_.status_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent, _impl_.lblk_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent, _impl_.status_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent, _impl_.found_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsRemoveExtentFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsRemoveExtentFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsRemoveExtentFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsRemoveExtentFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsRemoveExtentFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsRemoveExtentFtraceEvent, _impl_.len_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkFtraceEvent, _impl_.nr_shrunk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkFtraceEvent, _impl_.scan_time_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkFtraceEvent, _impl_.nr_skipped_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkFtraceEvent, _impl_.retried_),
    0,
    2,
    1,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkCountFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkCountFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkCountFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkCountFtraceEvent, _impl_.nr_to_scan_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkCountFtraceEvent, _impl_.cache_cnt_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent, _impl_.nr_to_scan_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent, _impl_.cache_cnt_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent, _impl_.nr_shrunk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent, _impl_.cache_cnt_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EvictInodeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EvictInodeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EvictInodeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EvictInodeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4EvictInodeFtraceEvent, _impl_.nlink_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_.m_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_.m_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_.u_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_.u_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_.u_pblk_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.m_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.m_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.u_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.u_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.u_pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.i_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.i_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.i_pblk_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.allocated_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.newblk_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtInCacheFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtInCacheFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtInCacheFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtInCacheFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtInCacheFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtInCacheFtraceEvent, _impl_.ret_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtLoadExtentFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtLoadExtentFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtLoadExtentFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtLoadExtentFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtLoadExtentFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtLoadExtentFtraceEvent, _impl_.lblk_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent, _impl_.flags_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _impl_.mflags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent, _impl_.ret_),
    0,
    1,
    3,
    2,
    4,
    5,
    6,
    7,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtPutInCacheFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtPutInCacheFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtPutInCacheFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtPutInCacheFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtPutInCacheFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtPutInCacheFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtPutInCacheFtraceEvent, _impl_.start_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent, _impl_.end_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent, _impl_.depth_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.end_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.depth_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.partial_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.eh_entries_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.pc_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.pc_pclu_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.pc_state_),
    0,
    1,
    2,
    3,
    5,
    4,
    6,
    8,
    7,
    9,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmIdxFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmIdxFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmIdxFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmIdxFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmIdxFtraceEvent, _impl_.pblk_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.partial_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.ee_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.ee_pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.ee_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.pc_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.pc_pclu_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtRmLeafFtraceEvent, _impl_.pc_state_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtShowExtentFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtShowExtentFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtShowExtentFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtShowExtentFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtShowExtentFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtShowExtentFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ExtShowExtentFtraceEvent, _impl_.len_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateEnterFtraceEvent, _impl_.offset_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateEnterFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateEnterFtraceEvent, _impl_.mode_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateEnterFtraceEvent, _impl_.pos_),
    0,
    1,
    2,
    3,
    5,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateExitFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateExitFtraceEvent, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateExitFtraceEvent, _impl_.blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FallocateExitFtraceEvent, _impl_.ret_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent, _impl_.from_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent, _impl_.to_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent, _impl_.reverse_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent, _impl_.found_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent, _impl_.found_blk_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ForgetFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ForgetFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ForgetFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ForgetFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ForgetFtraceEvent, _impl_.block_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ForgetFtraceEvent, _impl_.is_metadata_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ForgetFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeBlocksFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeBlocksFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeBlocksFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeBlocksFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeBlocksFtraceEvent, _impl_.block_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeBlocksFtraceEvent, _impl_.count_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeBlocksFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeBlocksFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeInodeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeInodeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeInodeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeInodeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeInodeFtraceEvent, _impl_.uid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeInodeFtraceEvent, _impl_.gid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeInodeFtraceEvent, _impl_.blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4FreeInodeFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_.ret_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent, _impl_.len_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent, _impl_.flags_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _impl_.pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _impl_.lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _impl_.mflags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent, _impl_.ret_),
    0,
    1,
    3,
    2,
    4,
    5,
    6,
    7,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InsertRangeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InsertRangeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InsertRangeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InsertRangeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InsertRangeFtraceEvent, _impl_.offset_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InsertRangeFtraceEvent, _impl_.len_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InvalidatepageFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InvalidatepageFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InvalidatepageFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InvalidatepageFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InvalidatepageFtraceEvent, _impl_.index_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InvalidatepageFtraceEvent, _impl_.offset_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4InvalidatepageFtraceEvent, _impl_.length_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartFtraceEvent, _impl_.ip_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartFtraceEvent, _impl_.blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartFtraceEvent, _impl_.rsv_blocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartFtraceEvent, _impl_.nblocks_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartFtraceEvent, _impl_.revoke_creds_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartReservedFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartReservedFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartReservedFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartReservedFtraceEvent, _impl_.ip_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalStartReservedFtraceEvent, _impl_.blocks_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent, _impl_.index_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent, _impl_.offset_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent, _impl_.length_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledWriteEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledWriteEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledWriteEndFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledWriteEndFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledWriteEndFtraceEvent, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledWriteEndFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4JournalledWriteEndFtraceEvent, _impl_.copied_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4LoadInodeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4LoadInodeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4LoadInodeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4LoadInodeFtraceEvent, _impl_.ino_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent, _impl_.group_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent, _impl_.ip_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbBitmapLoadFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbBitmapLoadFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbBitmapLoadFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbBitmapLoadFtraceEvent, _impl_.group_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent, _impl_.group_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent, _impl_.needed_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewGroupPaFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewGroupPaFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewGroupPaFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewGroupPaFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewGroupPaFtraceEvent, _impl_.pa_pstart_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewGroupPaFtraceEvent, _impl_.pa_lstart_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewGroupPaFtraceEvent, _impl_.pa_len_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewInodePaFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewInodePaFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewInodePaFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewInodePaFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewInodePaFtraceEvent, _impl_.pa_pstart_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewInodePaFtraceEvent, _impl_.pa_lstart_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbNewInodePaFtraceEvent, _impl_.pa_len_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent, _impl_.pa_pstart_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent, _impl_.pa_len_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent, _impl_.block_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent, _impl_.count_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.orig_logical_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.orig_start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.orig_group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.orig_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.goal_logical_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.goal_start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.goal_group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.goal_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.result_logical_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.result_start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.result_group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.result_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.found_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.groups_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.buddy_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.tail_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocAllocFtraceEvent, _impl_.cr_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocDiscardFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocDiscardFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocDiscardFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocDiscardFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocDiscardFtraceEvent, _impl_.result_start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocDiscardFtraceEvent, _impl_.result_group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocDiscardFtraceEvent, _impl_.result_len_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocFreeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocFreeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocFreeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocFreeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocFreeFtraceEvent, _impl_.result_start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocFreeFtraceEvent, _impl_.result_group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocFreeFtraceEvent, _impl_.result_len_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.orig_logical_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.orig_start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.orig_group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.orig_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.result_logical_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.result_start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.result_group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4MballocPreallocFtraceEvent, _impl_.result_len_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent, _impl_.orig_ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent, _impl_.uid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent, _impl_.gid_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4PunchHoleFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4PunchHoleFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4PunchHoleFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4PunchHoleFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4PunchHoleFtraceEvent, _impl_.offset_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4PunchHoleFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4PunchHoleFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent, _impl_.group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent, _impl_.prefetch_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadpageFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadpageFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadpageFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadpageFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReadpageFtraceEvent, _impl_.index_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReleasepageFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReleasepageFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReleasepageFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReleasepageFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ReleasepageFtraceEvent, _impl_.index_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.from_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.to_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.partial_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.ee_pblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.ee_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.ee_len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.pc_lblk_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.pc_pclu_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RemoveBlocksFtraceEvent, _impl_.pc_state_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    9,
    8,
    10,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.logical_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.lleft_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.lright_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.goal_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.pleft_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.pright_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestBlocksFtraceEvent, _impl_.flags_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestInodeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestInodeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestInodeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestInodeFtraceEvent, _impl_.dir_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4RequestInodeFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFsFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFsFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFsFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4SyncFsFtraceEvent, _impl_.wait_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimAllFreeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimAllFreeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimAllFreeFtraceEvent, _impl_.dev_major_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimAllFreeFtraceEvent, _impl_.dev_minor_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimAllFreeFtraceEvent, _impl_.group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimAllFreeFtraceEvent, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimAllFreeFtraceEvent, _impl_.len_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimExtentFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimExtentFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimExtentFtraceEvent, _impl_.dev_major_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimExtentFtraceEvent, _impl_.dev_minor_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimExtentFtraceEvent, _impl_.group_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimExtentFtraceEvent, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TrimExtentFtraceEvent, _impl_.len_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateEnterFtraceEvent, _impl_.blocks_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateExitFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4TruncateExitFtraceEvent, _impl_.blocks_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkEnterFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkEnterFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkEnterFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkEnterFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkEnterFtraceEvent, _impl_.parent_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkEnterFtraceEvent, _impl_.size_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkExitFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkExitFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkExitFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkExitFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4UnlinkExitFtraceEvent, _impl_.ret_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteBeginFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteBeginFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteBeginFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteBeginFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteBeginFtraceEvent, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteBeginFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteBeginFtraceEvent, _impl_.flags_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteEndFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteEndFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteEndFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteEndFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteEndFtraceEvent, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteEndFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WriteEndFtraceEvent, _impl_.copied_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepageFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepageFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepageFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepageFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepageFtraceEvent, _impl_.index_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.nr_to_write_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.pages_skipped_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.range_start_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.range_end_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.writeback_index_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.sync_mode_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.for_kupdate_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesFtraceEvent, _impl_.range_cyclic_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesResultFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesResultFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesResultFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesResultFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesResultFtraceEvent, _impl_.ret_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesResultFtraceEvent, _impl_.pages_written_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesResultFtraceEvent, _impl_.pages_skipped_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesResultFtraceEvent, _impl_.writeback_index_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4WritepagesResultFtraceEvent, _impl_.sync_mode_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ZeroRangeFtraceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ZeroRangeFtraceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ZeroRangeFtraceEvent, _impl_.dev_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ZeroRangeFtraceEvent, _impl_.ino_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ZeroRangeFtraceEvent, _impl_.offset_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ZeroRangeFtraceEvent, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::perfetto::protos::Ext4ZeroRangeFtraceEvent, _impl_.mode_),
    0,
    1,
    2,
    3,
    4,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 13, -1, sizeof(::perfetto::protos::Ext4DaWriteBeginFtraceEvent)},
        { 18, 31, -1, sizeof(::perfetto::protos::Ext4DaWriteEndFtraceEvent)},
        { 36, 48, -1, sizeof(::perfetto::protos::Ext4SyncFileEnterFtraceEvent)},
        { 52, 63, -1, sizeof(::perfetto::protos::Ext4SyncFileExitFtraceEvent)},
        { 66, 78, -1, sizeof(::perfetto::protos::Ext4AllocDaBlocksFtraceEvent)},
        { 82, 101, -1, sizeof(::perfetto::protos::Ext4AllocateBlocksFtraceEvent)},
        { 112, 124, -1, sizeof(::perfetto::protos::Ext4AllocateInodeFtraceEvent)},
        { 128, 139, -1, sizeof(::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent)},
        { 142, 154, -1, sizeof(::perfetto::protos::Ext4CollapseRangeFtraceEvent)},
        { 158, 174, -1, sizeof(::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent)},
        { 182, 197, -1, sizeof(::perfetto::protos::Ext4DaReserveSpaceFtraceEvent)},
        { 204, 221, -1, sizeof(::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent)},
        { 230, 248, -1, sizeof(::perfetto::protos::Ext4DaWritePagesFtraceEvent)},
        { 258, 271, -1, sizeof(::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent)},
        { 276, 289, -1, sizeof(::perfetto::protos::Ext4DirectIOEnterFtraceEvent)},
        { 294, 308, -1, sizeof(::perfetto::protos::Ext4DirectIOExitFtraceEvent)},
        { 314, 325, -1, sizeof(::perfetto::protos::Ext4DiscardBlocksFtraceEvent)},
        { 328, 340, -1, sizeof(::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent)},
        { 344, 355, -1, sizeof(::perfetto::protos::Ext4DropInodeFtraceEvent)},
        { 358, 372, -1, sizeof(::perfetto::protos::Ext4EsCacheExtentFtraceEvent)},
        { 378, 389, -1, sizeof(::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent)},
        { 392, 406, -1, sizeof(::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent)},
        { 412, 426, -1, sizeof(::perfetto::protos::Ext4EsInsertExtentFtraceEvent)},
        { 432, 443, -1, sizeof(::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent)},
        { 446, 461, -1, sizeof(::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent)},
        { 468, 480, -1, sizeof(::perfetto::protos::Ext4EsRemoveExtentFtraceEvent)},
        { 484, 497, -1, sizeof(::perfetto::protos::Ext4EsShrinkFtraceEvent)},
        { 502, 513, -1, sizeof(::perfetto::protos::Ext4EsShrinkCountFtraceEvent)},
        { 516, 527, -1, sizeof(::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent)},
        { 530, 541, -1, sizeof(::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent)},
        { 544, 555, -1, sizeof(::perfetto::protos::Ext4EvictInodeFtraceEvent)},
        { 558, 573, -1, sizeof(::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent)},
        { 580, 598, -1, sizeof(::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent)},
        { 608, 624, -1, sizeof(::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent)},
        { 632, 644, -1, sizeof(::perfetto::protos::Ext4ExtInCacheFtraceEvent)},
        { 648, 660, -1, sizeof(::perfetto::protos::Ext4ExtLoadExtentFtraceEvent)},
        { 664, 677, -1, sizeof(::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent)},
        { 682, 698, -1, sizeof(::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent)},
        { 706, 719, -1, sizeof(::perfetto::protos::Ext4ExtPutInCacheFtraceEvent)},
        { 724, 737, -1, sizeof(::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent)},
        { 742, 760, -1, sizeof(::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent)},
        { 770, 781, -1, sizeof(::perfetto::protos::Ext4ExtRmIdxFtraceEvent)},
        { 784, 802, -1, sizeof(::perfetto::protos::Ext4ExtRmLeafFtraceEvent)},
        { 812, 825, -1, sizeof(::perfetto::protos::Ext4ExtShowExtentFtraceEvent)},
        { 830, 844, -1, sizeof(::perfetto::protos::Ext4FallocateEnterFtraceEvent)},
        { 850, 863, -1, sizeof(::perfetto::protos::Ext4FallocateExitFtraceEvent)},
        { 868, 883, -1, sizeof(::perfetto::protos::Ext4FindDelallocRangeFtraceEvent)},
        { 890, 903, -1, sizeof(::perfetto::protos::Ext4ForgetFtraceEvent)},
        { 908, 922, -1, sizeof(::perfetto::protos::Ext4FreeBlocksFtraceEvent)},
        { 928, 942, -1, sizeof(::perfetto::protos::Ext4FreeInodeFtraceEvent)},
        { 948, 962, -1, sizeof(::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent)},
        { 968, 980, -1, sizeof(::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent)},
        { 984, 997, -1, sizeof(::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent)},
        { 1002, 1018, -1, sizeof(::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent)},
        { 1026, 1038, -1, sizeof(::perfetto::protos::Ext4InsertRangeFtraceEvent)},
        { 1042, 1055, -1, sizeof(::perfetto::protos::Ext4InvalidatepageFtraceEvent)},
        { 1060, 1074, -1, sizeof(::perfetto::protos::Ext4JournalStartFtraceEvent)},
        { 1080, 1091, -1, sizeof(::perfetto::protos::Ext4JournalStartReservedFtraceEvent)},
        { 1094, 1107, -1, sizeof(::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent)},
        { 1112, 1125, -1, sizeof(::perfetto::protos::Ext4JournalledWriteEndFtraceEvent)},
        { 1130, 1140, -1, sizeof(::perfetto::protos::Ext4LoadInodeFtraceEvent)},
        { 1142, 1152, -1, sizeof(::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent)},
        { 1154, 1165, -1, sizeof(::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent)},
        { 1168, 1178, -1, sizeof(::perfetto::protos::Ext4MbBitmapLoadFtraceEvent)},
        { 1180, 1190, -1, sizeof(::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent)},
        { 1192, 1202, -1, sizeof(::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent)},
        { 1204, 1217, -1, sizeof(::perfetto::protos::Ext4MbNewGroupPaFtraceEvent)},
        { 1222, 1235, -1, sizeof(::perfetto::protos::Ext4MbNewInodePaFtraceEvent)},
        { 1240, 1251, -1, sizeof(::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent)},
        { 1254, 1266, -1, sizeof(::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent)},
        { 1270, 1298, -1, sizeof(::perfetto::protos::Ext4MballocAllocFtraceEvent)},
        { 1318, 1331, -1, sizeof(::perfetto::protos::Ext4MballocDiscardFtraceEvent)},
        { 1336, 1349, -1, sizeof(::perfetto::protos::Ext4MballocFreeFtraceEvent)},
        { 1354, 1372, -1, sizeof(::perfetto::protos::Ext4MballocPreallocFtraceEvent)},
        { 1382, 1396, -1, sizeof(::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent)},
        { 1402, 1415, -1, sizeof(::perfetto::protos::Ext4PunchHoleFtraceEvent)},
        { 1420, 1431, -1, sizeof(::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent)},
        { 1434, 1445, -1, sizeof(::perfetto::protos::Ext4ReadpageFtraceEvent)},
        { 1448, 1459, -1, sizeof(::perfetto::protos::Ext4ReleasepageFtraceEvent)},
        { 1462, 1481, -1, sizeof(::perfetto::protos::Ext4RemoveBlocksFtraceEvent)},
        { 1492, 1510, -1, sizeof(::perfetto::protos::Ext4RequestBlocksFtraceEvent)},
        { 1520, 1531, -1, sizeof(::perfetto::protos::Ext4RequestInodeFtraceEvent)},
        { 1534, 1544, -1, sizeof(::perfetto::protos::Ext4SyncFsFtraceEvent)},
        { 1546, 1559, -1, sizeof(::perfetto::protos::Ext4TrimAllFreeFtraceEvent)},
        { 1564, 1577, -1, sizeof(::perfetto::protos::Ext4TrimExtentFtraceEvent)},
        { 1582, 1593, -1, sizeof(::perfetto::protos::Ext4TruncateEnterFtraceEvent)},
        { 1596, 1607, -1, sizeof(::perfetto::protos::Ext4TruncateExitFtraceEvent)},
        { 1610, 1622, -1, sizeof(::perfetto::protos::Ext4UnlinkEnterFtraceEvent)},
        { 1626, 1637, -1, sizeof(::perfetto::protos::Ext4UnlinkExitFtraceEvent)},
        { 1640, 1653, -1, sizeof(::perfetto::protos::Ext4WriteBeginFtraceEvent)},
        { 1658, 1671, -1, sizeof(::perfetto::protos::Ext4WriteEndFtraceEvent)},
        { 1676, 1687, -1, sizeof(::perfetto::protos::Ext4WritepageFtraceEvent)},
        { 1690, 1708, -1, sizeof(::perfetto::protos::Ext4WritepagesFtraceEvent)},
        { 1718, 1733, -1, sizeof(::perfetto::protos::Ext4WritepagesResultFtraceEvent)},
        { 1740, 1753, -1, sizeof(::perfetto::protos::Ext4ZeroRangeFtraceEvent)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::perfetto::protos::_Ext4DaWriteBeginFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DaWriteEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4SyncFileEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4SyncFileExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4AllocDaBlocksFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4AllocateBlocksFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4AllocateInodeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4BeginOrderedTruncateFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4CollapseRangeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DaReleaseSpaceFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DaReserveSpaceFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DaUpdateReserveSpaceFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DaWritePagesFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DaWritePagesExtentFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DirectIOEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DirectIOExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DiscardBlocksFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DiscardPreallocationsFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4DropInodeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsCacheExtentFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsFindDelayedExtentRangeEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsFindDelayedExtentRangeExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsInsertExtentFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsLookupExtentEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsLookupExtentExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsRemoveExtentFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsShrinkFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsShrinkCountFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsShrinkScanEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EsShrinkScanExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4EvictInodeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtConvertToInitializedEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtConvertToInitializedFastpathFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtHandleUnwrittenExtentsFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtInCacheFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtLoadExtentFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtMapBlocksEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtMapBlocksExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtPutInCacheFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtRemoveSpaceFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtRemoveSpaceDoneFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtRmIdxFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtRmLeafFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ExtShowExtentFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4FallocateEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4FallocateExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4FindDelallocRangeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ForgetFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4FreeBlocksFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4FreeInodeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4GetImpliedClusterAllocExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4GetReservedClusterAllocFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4IndMapBlocksEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4IndMapBlocksExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4InsertRangeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4InvalidatepageFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4JournalStartFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4JournalStartReservedFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4JournalledInvalidatepageFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4JournalledWriteEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4LoadInodeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4LoadInodeBitmapFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MarkInodeDirtyFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MbBitmapLoadFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MbBuddyBitmapLoadFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MbDiscardPreallocationsFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MbNewGroupPaFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MbNewInodePaFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MbReleaseGroupPaFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MbReleaseInodePaFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MballocAllocFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MballocDiscardFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MballocFreeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4MballocPreallocFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4OtherInodeUpdateTimeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4PunchHoleFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ReadBlockBitmapLoadFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ReadpageFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ReleasepageFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4RemoveBlocksFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4RequestBlocksFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4RequestInodeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4SyncFsFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4TrimAllFreeFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4TrimExtentFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4TruncateEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4TruncateExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4UnlinkEnterFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4UnlinkExitFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4WriteBeginFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4WriteEndFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4WritepageFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4WritepagesFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4WritepagesResultFtraceEvent_default_instance_._instance,
    &::perfetto::protos::_Ext4ZeroRangeFtraceEvent_default_instance_._instance,
};
const char descriptor_table_protodef_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\'protos/perfetto/trace/ftrace/ext4.prot"
    "o\022\017perfetto.protos\"`\n\033Ext4DaWriteBeginFt"
    "raceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\013\n\003p"
    "os\030\003 \001(\003\022\013\n\003len\030\004 \001(\r\022\r\n\005flags\030\005 \001(\r\"_\n\031"
    "Ext4DaWriteEndFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013"
    "\n\003ino\030\002 \001(\004\022\013\n\003pos\030\003 \001(\003\022\013\n\003len\030\004 \001(\r\022\016\n"
    "\006copied\030\005 \001(\r\"Z\n\034Ext4SyncFileEnterFtrace"
    "Event\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\016\n\006paren"
    "t\030\003 \001(\004\022\020\n\010datasync\030\004 \001(\005\"D\n\033Ext4SyncFil"
    "eExitFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001"
    "(\004\022\013\n\003ret\030\003 \001(\005\"b\n\034Ext4AllocDaBlocksFtra"
    "ceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\023\n\013dat"
    "a_blocks\030\003 \001(\r\022\023\n\013meta_blocks\030\004 \001(\r\"\301\001\n\035"
    "Ext4AllocateBlocksFtraceEvent\022\013\n\003dev\030\001 \001"
    "(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005block\030\003 \001(\004\022\013\n\003len\030\004 "
    "\001(\r\022\017\n\007logical\030\005 \001(\r\022\r\n\005lleft\030\006 \001(\r\022\016\n\006l"
    "right\030\007 \001(\r\022\014\n\004goal\030\010 \001(\004\022\r\n\005pleft\030\t \001(\004"
    "\022\016\n\006pright\030\n \001(\004\022\r\n\005flags\030\013 \001(\r\"S\n\034Ext4A"
    "llocateInodeFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003"
    "ino\030\002 \001(\004\022\013\n\003dir\030\003 \001(\004\022\014\n\004mode\030\004 \001(\r\"Q\n#"
    "Ext4BeginOrderedTruncateFtraceEvent\022\013\n\003d"
    "ev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\020\n\010new_size\030\003 \001(\003\""
    "U\n\034Ext4CollapseRangeFtraceEvent\022\013\n\003dev\030\001"
    " \001(\004\022\013\n\003ino\030\002 \001(\004\022\016\n\006offset\030\003 \001(\003\022\013\n\003len"
    "\030\004 \001(\003\"\312\001\n\035Ext4DaReleaseSpaceFtraceEvent"
    "\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\020\n\010i_blocks\030\003"
    " \001(\004\022\024\n\014freed_blocks\030\004 \001(\005\022\034\n\024reserved_d"
    "ata_blocks\030\005 \001(\005\022\034\n\024reserved_meta_blocks"
    "\030\006 \001(\005\022\035\n\025allocated_meta_blocks\030\007 \001(\005\022\014\n"
    "\004mode\030\010 \001(\r\"\250\001\n\035Ext4DaReserveSpaceFtrace"
    "Event\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\020\n\010i_blo"
    "cks\030\003 \001(\004\022\034\n\024reserved_data_blocks\030\004 \001(\005\022"
    "\034\n\024reserved_meta_blocks\030\005 \001(\005\022\014\n\004mode\030\006 "
    "\001(\r\022\021\n\tmd_needed\030\007 \001(\005\"\344\001\n#Ext4DaUpdateR"
    "eserveSpaceFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003i"
    "no\030\002 \001(\004\022\020\n\010i_blocks\030\003 \001(\004\022\023\n\013used_block"
    "s\030\004 \001(\005\022\034\n\024reserved_data_blocks\030\005 \001(\005\022\034\n"
    "\024reserved_meta_blocks\030\006 \001(\005\022\035\n\025allocated"
    "_meta_blocks\030\007 \001(\005\022\023\n\013quota_claim\030\010 \001(\005\022"
    "\014\n\004mode\030\t \001(\r\"\317\001\n\033Ext4DaWritePagesFtrace"
    "Event\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\022\n\nfirst"
    "_page\030\003 \001(\004\022\023\n\013nr_to_write\030\004 \001(\003\022\021\n\tsync"
    "_mode\030\005 \001(\005\022\021\n\tb_blocknr\030\006 \001(\004\022\016\n\006b_size"
    "\030\007 \001(\r\022\017\n\007b_state\030\010 \001(\r\022\017\n\007io_done\030\t \001(\005"
    "\022\025\n\rpages_written\030\n \001(\005\"g\n!Ext4DaWritePa"
    "gesExtentFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino"
    "\030\002 \001(\004\022\014\n\004lblk\030\003 \001(\004\022\013\n\003len\030\004 \001(\r\022\r\n\005fla"
    "gs\030\005 \001(\r\"^\n\034Ext4DirectIOEnterFtraceEvent"
    "\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\013\n\003pos\030\003 \001(\003\022"
    "\013\n\003len\030\004 \001(\004\022\n\n\002rw\030\005 \001(\005\"j\n\033Ext4DirectIO"
    "ExitFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001("
    "\004\022\013\n\003pos\030\003 \001(\003\022\013\n\003len\030\004 \001(\004\022\n\n\002rw\030\005 \001(\005\022"
    "\013\n\003ret\030\006 \001(\005\"G\n\034Ext4DiscardBlocksFtraceE"
    "vent\022\013\n\003dev\030\001 \001(\004\022\013\n\003blk\030\002 \001(\004\022\r\n\005count\030"
    "\003 \001(\004\"]\n$Ext4DiscardPreallocationsFtrace"
    "Event\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\013\n\003len\030\003"
    " \001(\r\022\016\n\006needed\030\004 \001(\r\"B\n\030Ext4DropInodeFtr"
    "aceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\014\n\004dr"
    "op\030\003 \001(\005\"q\n\034Ext4EsCacheExtentFtraceEvent"
    "\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\014\n\004lblk\030\003 \001(\r"
    "\022\013\n\003len\030\004 \001(\r\022\014\n\004pblk\030\005 \001(\004\022\016\n\006status\030\006 "
    "\001(\r\"V\n,Ext4EsFindDelayedExtentRangeEnter"
    "FtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\014\n"
    "\004lblk\030\003 \001(\r\"\200\001\n+Ext4EsFindDelayedExtentR"
    "angeExitFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030"
    "\002 \001(\004\022\014\n\004lblk\030\003 \001(\r\022\013\n\003len\030\004 \001(\r\022\014\n\004pblk"
    "\030\005 \001(\004\022\016\n\006status\030\006 \001(\004\"r\n\035Ext4EsInsertEx"
    "tentFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001("
    "\004\022\014\n\004lblk\030\003 \001(\r\022\013\n\003len\030\004 \001(\r\022\014\n\004pblk\030\005 \001"
    "(\004\022\016\n\006status\030\006 \001(\004\"L\n\"Ext4EsLookupExtent"
    "EnterFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001"
    "(\004\022\014\n\004lblk\030\003 \001(\r\"\205\001\n!Ext4EsLookupExtentE"
    "xitFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004"
    "\022\014\n\004lblk\030\003 \001(\r\022\013\n\003len\030\004 \001(\r\022\014\n\004pblk\030\005 \001("
    "\004\022\016\n\006status\030\006 \001(\004\022\r\n\005found\030\007 \001(\005\"T\n\035Ext4"
    "EsRemoveExtentFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013"
    "\n\003ino\030\002 \001(\004\022\014\n\004lblk\030\003 \001(\003\022\013\n\003len\030\004 \001(\003\"q"
    "\n\027Ext4EsShrinkFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\021"
    "\n\tnr_shrunk\030\002 \001(\005\022\021\n\tscan_time\030\003 \001(\004\022\022\n\n"
    "nr_skipped\030\004 \001(\005\022\017\n\007retried\030\005 \001(\005\"R\n\034Ext"
    "4EsShrinkCountFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\022"
    "\n\nnr_to_scan\030\002 \001(\005\022\021\n\tcache_cnt\030\003 \001(\005\"V\n"
    " Ext4EsShrinkScanEnterFtraceEvent\022\013\n\003dev"
    "\030\001 \001(\004\022\022\n\nnr_to_scan\030\002 \001(\005\022\021\n\tcache_cnt\030"
    "\003 \001(\005\"T\n\037Ext4EsShrinkScanExitFtraceEvent"
    "\022\013\n\003dev\030\001 \001(\004\022\021\n\tnr_shrunk\030\002 \001(\005\022\021\n\tcach"
    "e_cnt\030\003 \001(\005\"D\n\031Ext4EvictInodeFtraceEvent"
    "\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005nlink\030\003 \001("
    "\005\"\225\001\n+Ext4ExtConvertToInitializedEnterFt"
    "raceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\016\n\006m"
    "_lblk\030\003 \001(\r\022\r\n\005m_len\030\004 \001(\r\022\016\n\006u_lblk\030\005 \001"
    "(\r\022\r\n\005u_len\030\006 \001(\r\022\016\n\006u_pblk\030\007 \001(\004\"\307\001\n.Ex"
    "t4ExtConvertToInitializedFastpathFtraceE"
    "vent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\016\n\006m_lblk"
    "\030\003 \001(\r\022\r\n\005m_len\030\004 \001(\r\022\016\n\006u_lblk\030\005 \001(\r\022\r\n"
    "\005u_len\030\006 \001(\r\022\016\n\006u_pblk\030\007 \001(\004\022\016\n\006i_lblk\030\010"
    " \001(\r\022\r\n\005i_len\030\t \001(\r\022\016\n\006i_pblk\030\n \001(\004\"\237\001\n("
    "Ext4ExtHandleUnwrittenExtentsFtraceEvent"
    "\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005flags\030\003 \001("
    "\005\022\014\n\004lblk\030\004 \001(\r\022\014\n\004pblk\030\005 \001(\004\022\013\n\003len\030\006 \001"
    "(\r\022\021\n\tallocated\030\007 \001(\r\022\016\n\006newblk\030\010 \001(\004\"P\n"
    "\031Ext4ExtInCacheFtraceEvent\022\013\n\003dev\030\001 \001(\004\022"
    "\013\n\003ino\030\002 \001(\004\022\014\n\004lblk\030\003 \001(\r\022\013\n\003ret\030\004 \001(\005\""
    "T\n\034Ext4ExtLoadExtentFtraceEvent\022\013\n\003dev\030\001"
    " \001(\004\022\013\n\003ino\030\002 \001(\004\022\014\n\004pblk\030\003 \001(\004\022\014\n\004lblk\030"
    "\004 \001(\r\"f\n Ext4ExtMapBlocksEnterFtraceEven"
    "t\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\014\n\004lblk\030\003 \001("
    "\r\022\013\n\003len\030\004 \001(\r\022\r\n\005flags\030\005 \001(\r\"\220\001\n\037Ext4Ex"
    "tMapBlocksExitFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013"
    "\n\003ino\030\002 \001(\004\022\r\n\005flags\030\003 \001(\r\022\014\n\004pblk\030\004 \001(\004"
    "\022\014\n\004lblk\030\005 \001(\r\022\013\n\003len\030\006 \001(\r\022\016\n\006mflags\030\007 "
    "\001(\r\022\013\n\003ret\030\010 \001(\005\"b\n\034Ext4ExtPutInCacheFtr"
    "aceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\014\n\004lb"
    "lk\030\003 \001(\r\022\013\n\003len\030\004 \001(\r\022\r\n\005start\030\005 \001(\004\"d\n\035"
    "Ext4ExtRemoveSpaceFtraceEvent\022\013\n\003dev\030\001 \001"
    "(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005start\030\003 \001(\r\022\013\n\003end\030\004 "
    "\001(\r\022\r\n\005depth\030\005 \001(\005\"\301\001\n!Ext4ExtRemoveSpac"
    "eDoneFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001"
    "(\004\022\r\n\005start\030\003 \001(\r\022\013\n\003end\030\004 \001(\r\022\r\n\005depth\030"
    "\005 \001(\005\022\017\n\007partial\030\006 \001(\003\022\022\n\neh_entries\030\007 \001"
    "(\r\022\017\n\007pc_lblk\030\010 \001(\r\022\017\n\007pc_pclu\030\t \001(\004\022\020\n\010"
    "pc_state\030\n \001(\005\"A\n\027Ext4ExtRmIdxFtraceEven"
    "t\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\014\n\004pblk\030\003 \001("
    "\004\"\272\001\n\030Ext4ExtRmLeafFtraceEvent\022\013\n\003dev\030\001 "
    "\001(\004\022\013\n\003ino\030\002 \001(\004\022\017\n\007partial\030\003 \001(\003\022\r\n\005sta"
    "rt\030\004 \001(\r\022\017\n\007ee_lblk\030\005 \001(\r\022\017\n\007ee_pblk\030\006 \001"
    "(\004\022\016\n\006ee_len\030\007 \001(\005\022\017\n\007pc_lblk\030\010 \001(\r\022\017\n\007p"
    "c_pclu\030\t \001(\004\022\020\n\010pc_state\030\n \001(\005\"a\n\034Ext4Ex"
    "tShowExtentFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003i"
    "no\030\002 \001(\004\022\014\n\004pblk\030\003 \001(\004\022\014\n\004lblk\030\004 \001(\r\022\013\n\003"
    "len\030\005 \001(\r\"q\n\035Ext4FallocateEnterFtraceEve"
    "nt\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\016\n\006offset\030\003"
    " \001(\003\022\013\n\003len\030\004 \001(\003\022\014\n\004mode\030\005 \001(\005\022\013\n\003pos\030\006"
    " \001(\003\"b\n\034Ext4FallocateExitFtraceEvent\022\013\n\003"
    "dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\013\n\003pos\030\003 \001(\003\022\016\n\006b"
    "locks\030\004 \001(\r\022\013\n\003ret\030\005 \001(\005\"\211\001\n Ext4FindDel"
    "allocRangeFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003in"
    "o\030\002 \001(\004\022\014\n\004from\030\003 \001(\r\022\n\n\002to\030\004 \001(\r\022\017\n\007rev"
    "erse\030\005 \001(\005\022\r\n\005found\030\006 \001(\005\022\021\n\tfound_blk\030\007"
    " \001(\r\"c\n\025Ext4ForgetFtraceEvent\022\013\n\003dev\030\001 \001"
    "(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005block\030\003 \001(\004\022\023\n\013is_met"
    "adata\030\004 \001(\005\022\014\n\004mode\030\005 \001(\r\"p\n\031Ext4FreeBlo"
    "cksFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004"
    "\022\r\n\005block\030\003 \001(\004\022\r\n\005count\030\004 \001(\004\022\r\n\005flags\030"
    "\005 \001(\005\022\014\n\004mode\030\006 \001(\r\"l\n\030Ext4FreeInodeFtra"
    "ceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\013\n\003uid"
    "\030\003 \001(\r\022\013\n\003gid\030\004 \001(\r\022\016\n\006blocks\030\005 \001(\004\022\014\n\004m"
    "ode\030\006 \001(\r\"}\n)Ext4GetImpliedClusterAllocE"
    "xitFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\r\n\005flags\030\002 \001"
    "(\r\022\014\n\004lblk\030\003 \001(\r\022\014\n\004pblk\030\004 \001(\004\022\013\n\003len\030\005 "
    "\001(\r\022\013\n\003ret\030\006 \001(\005\"]\n&Ext4GetReservedClust"
    "erAllocFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002"
    " \001(\004\022\014\n\004lblk\030\003 \001(\r\022\013\n\003len\030\004 \001(\r\"f\n Ext4I"
    "ndMapBlocksEnterFtraceEvent\022\013\n\003dev\030\001 \001(\004"
    "\022\013\n\003ino\030\002 \001(\004\022\014\n\004lblk\030\003 \001(\r\022\013\n\003len\030\004 \001(\r"
    "\022\r\n\005flags\030\005 \001(\r\"\220\001\n\037Ext4IndMapBlocksExit"
    "FtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\r\n"
    "\005flags\030\003 \001(\r\022\014\n\004pblk\030\004 \001(\004\022\014\n\004lblk\030\005 \001(\r"
    "\022\013\n\003len\030\006 \001(\r\022\016\n\006mflags\030\007 \001(\r\022\013\n\003ret\030\010 \001"
    "(\005\"S\n\032Ext4InsertRangeFtraceEvent\022\013\n\003dev\030"
    "\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\016\n\006offset\030\003 \001(\003\022\013\n\003le"
    "n\030\004 \001(\003\"h\n\035Ext4InvalidatepageFtraceEvent"
    "\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005index\030\003 \001("
    "\004\022\016\n\006offset\030\004 \001(\004\022\016\n\006length\030\005 \001(\r\"\201\001\n\033Ex"
    "t4JournalStartFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\n"
    "\n\002ip\030\002 \001(\004\022\016\n\006blocks\030\003 \001(\005\022\022\n\nrsv_blocks"
    "\030\004 \001(\005\022\017\n\007nblocks\030\005 \001(\005\022\024\n\014revoke_creds\030"
    "\006 \001(\005\"N\n#Ext4JournalStartReservedFtraceE"
    "vent\022\013\n\003dev\030\001 \001(\004\022\n\n\002ip\030\002 \001(\004\022\016\n\006blocks\030"
    "\003 \001(\005\"r\n\'Ext4JournalledInvalidatepageFtr"
    "aceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005in"
    "dex\030\003 \001(\004\022\016\n\006offset\030\004 \001(\004\022\016\n\006length\030\005 \001("
    "\r\"g\n!Ext4JournalledWriteEndFtraceEvent\022\013"
    "\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\013\n\003pos\030\003 \001(\003\022\013\n"
    "\003len\030\004 \001(\r\022\016\n\006copied\030\005 \001(\r\"4\n\030Ext4LoadIn"
    "odeFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004"
    "\"<\n\036Ext4LoadInodeBitmapFtraceEvent\022\013\n\003de"
    "v\030\001 \001(\004\022\r\n\005group\030\002 \001(\r\"E\n\035Ext4MarkInodeD"
    "irtyFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001("
    "\004\022\n\n\002ip\030\003 \001(\004\"9\n\033Ext4MbBitmapLoadFtraceE"
    "vent\022\013\n\003dev\030\001 \001(\004\022\r\n\005group\030\002 \001(\r\">\n Ext4"
    "MbBuddyBitmapLoadFtraceEvent\022\013\n\003dev\030\001 \001("
    "\004\022\r\n\005group\030\002 \001(\r\"E\n&Ext4MbDiscardPreallo"
    "cationsFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\016\n\006neede"
    "d\030\002 \001(\005\"m\n\033Ext4MbNewGroupPaFtraceEvent\022\013"
    "\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\021\n\tpa_pstart\030\003 "
    "\001(\004\022\021\n\tpa_lstart\030\004 \001(\004\022\016\n\006pa_len\030\005 \001(\r\"m"
    "\n\033Ext4MbNewInodePaFtraceEvent\022\013\n\003dev\030\001 \001"
    "(\004\022\013\n\003ino\030\002 \001(\004\022\021\n\tpa_pstart\030\003 \001(\004\022\021\n\tpa"
    "_lstart\030\004 \001(\004\022\016\n\006pa_len\030\005 \001(\r\"Q\n\037Ext4MbR"
    "eleaseGroupPaFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\021\n"
    "\tpa_pstart\030\002 \001(\004\022\016\n\006pa_len\030\003 \001(\r\"Y\n\037Ext4"
    "MbReleaseInodePaFtraceEvent\022\013\n\003dev\030\001 \001(\004"
    "\022\013\n\003ino\030\002 \001(\004\022\r\n\005block\030\003 \001(\004\022\r\n\005count\030\004 "
    "\001(\r\"\206\003\n\033Ext4MballocAllocFtraceEvent\022\013\n\003d"
    "ev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\024\n\014orig_logical\030\003 "
    "\001(\r\022\022\n\norig_start\030\004 \001(\005\022\022\n\norig_group\030\005 "
    "\001(\r\022\020\n\010orig_len\030\006 \001(\005\022\024\n\014goal_logical\030\007 "
    "\001(\r\022\022\n\ngoal_start\030\010 \001(\005\022\022\n\ngoal_group\030\t "
    "\001(\r\022\020\n\010goal_len\030\n \001(\005\022\026\n\016result_logical\030"
    "\013 \001(\r\022\024\n\014result_start\030\014 \001(\005\022\024\n\014result_gr"
    "oup\030\r \001(\r\022\022\n\nresult_len\030\016 \001(\005\022\r\n\005found\030\017"
    " \001(\r\022\016\n\006groups\030\020 \001(\r\022\r\n\005buddy\030\021 \001(\r\022\r\n\005f"
    "lags\030\022 \001(\r\022\014\n\004tail\030\023 \001(\r\022\n\n\002cr\030\024 \001(\r\"y\n\035"
    "Ext4MballocDiscardFtraceEvent\022\013\n\003dev\030\001 \001"
    "(\004\022\013\n\003ino\030\002 \001(\004\022\024\n\014result_start\030\003 \001(\005\022\024\n"
    "\014result_group\030\004 \001(\r\022\022\n\nresult_len\030\005 \001(\005\""
    "v\n\032Ext4MballocFreeFtraceEvent\022\013\n\003dev\030\001 \001"
    "(\004\022\013\n\003ino\030\002 \001(\004\022\024\n\014result_start\030\003 \001(\005\022\024\n"
    "\014result_group\030\004 \001(\r\022\022\n\nresult_len\030\005 \001(\005\""
    "\342\001\n\036Ext4MballocPreallocFtraceEvent\022\013\n\003de"
    "v\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\024\n\014orig_logical\030\003 \001"
    "(\r\022\022\n\norig_start\030\004 \001(\005\022\022\n\norig_group\030\005 \001"
    "(\r\022\020\n\010orig_len\030\006 \001(\005\022\026\n\016result_logical\030\007"
    " \001(\r\022\024\n\014result_start\030\010 \001(\005\022\024\n\014result_gro"
    "up\030\t \001(\r\022\022\n\nresult_len\030\n \001(\005\"y\n#Ext4Othe"
    "rInodeUpdateTimeFtraceEvent\022\013\n\003dev\030\001 \001(\004"
    "\022\013\n\003ino\030\002 \001(\004\022\020\n\010orig_ino\030\003 \001(\004\022\013\n\003uid\030\004"
    " \001(\r\022\013\n\003gid\030\005 \001(\r\022\014\n\004mode\030\006 \001(\r\"_\n\030Ext4P"
    "unchHoleFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030"
    "\002 \001(\004\022\016\n\006offset\030\003 \001(\003\022\013\n\003len\030\004 \001(\003\022\014\n\004mo"
    "de\030\005 \001(\005\"R\n\"Ext4ReadBlockBitmapLoadFtrac"
    "eEvent\022\013\n\003dev\030\001 \001(\004\022\r\n\005group\030\002 \001(\r\022\020\n\010pr"
    "efetch\030\003 \001(\r\"B\n\027Ext4ReadpageFtraceEvent\022"
    "\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005index\030\003 \001(\004"
    "\"E\n\032Ext4ReleasepageFtraceEvent\022\013\n\003dev\030\001 "
    "\001(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005index\030\003 \001(\004\"\310\001\n\033Ext4"
    "RemoveBlocksFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003"
    "ino\030\002 \001(\004\022\014\n\004from\030\003 \001(\r\022\n\n\002to\030\004 \001(\r\022\017\n\007p"
    "artial\030\005 \001(\003\022\017\n\007ee_pblk\030\006 \001(\004\022\017\n\007ee_lblk"
    "\030\007 \001(\r\022\016\n\006ee_len\030\010 \001(\r\022\017\n\007pc_lblk\030\t \001(\r\022"
    "\017\n\007pc_pclu\030\n \001(\004\022\020\n\010pc_state\030\013 \001(\005\"\261\001\n\034E"
    "xt4RequestBlocksFtraceEvent\022\013\n\003dev\030\001 \001(\004"
    "\022\013\n\003ino\030\002 \001(\004\022\013\n\003len\030\003 \001(\r\022\017\n\007logical\030\004 "
    "\001(\r\022\r\n\005lleft\030\005 \001(\r\022\016\n\006lright\030\006 \001(\r\022\014\n\004go"
    "al\030\007 \001(\004\022\r\n\005pleft\030\010 \001(\004\022\016\n\006pright\030\t \001(\004\022"
    "\r\n\005flags\030\n \001(\r\"E\n\033Ext4RequestInodeFtrace"
    "Event\022\013\n\003dev\030\001 \001(\004\022\013\n\003dir\030\002 \001(\004\022\014\n\004mode\030"
    "\003 \001(\r\"2\n\025Ext4SyncFsFtraceEvent\022\013\n\003dev\030\001 "
    "\001(\004\022\014\n\004wait\030\002 \001(\005\"m\n\032Ext4TrimAllFreeFtra"
    "ceEvent\022\021\n\tdev_major\030\001 \001(\005\022\021\n\tdev_minor\030"
    "\002 \001(\005\022\r\n\005group\030\003 \001(\r\022\r\n\005start\030\004 \001(\005\022\013\n\003l"
    "en\030\005 \001(\005\"l\n\031Ext4TrimExtentFtraceEvent\022\021\n"
    "\tdev_major\030\001 \001(\005\022\021\n\tdev_minor\030\002 \001(\005\022\r\n\005g"
    "roup\030\003 \001(\r\022\r\n\005start\030\004 \001(\005\022\013\n\003len\030\005 \001(\005\"H"
    "\n\034Ext4TruncateEnterFtraceEvent\022\013\n\003dev\030\001 "
    "\001(\004\022\013\n\003ino\030\002 \001(\004\022\016\n\006blocks\030\003 \001(\004\"G\n\033Ext4"
    "TruncateExitFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003"
    "ino\030\002 \001(\004\022\016\n\006blocks\030\003 \001(\004\"T\n\032Ext4UnlinkE"
    "nterFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001("
    "\004\022\016\n\006parent\030\003 \001(\004\022\014\n\004size\030\004 \001(\003\"B\n\031Ext4U"
    "nlinkExitFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino"
    "\030\002 \001(\004\022\013\n\003ret\030\003 \001(\005\"^\n\031Ext4WriteBeginFtr"
    "aceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\013\n\003po"
    "s\030\003 \001(\003\022\013\n\003len\030\004 \001(\r\022\r\n\005flags\030\005 \001(\r\"]\n\027E"
    "xt4WriteEndFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003i"
    "no\030\002 \001(\004\022\013\n\003pos\030\003 \001(\003\022\013\n\003len\030\004 \001(\r\022\016\n\006co"
    "pied\030\005 \001(\r\"C\n\030Ext4WritepageFtraceEvent\022\013"
    "\n\003dev\030\001 \001(\004\022\013\n\003ino\030\002 \001(\004\022\r\n\005index\030\003 \001(\004\""
    "\340\001\n\031Ext4WritepagesFtraceEvent\022\013\n\003dev\030\001 \001"
    "(\004\022\013\n\003ino\030\002 \001(\004\022\023\n\013nr_to_write\030\003 \001(\003\022\025\n\r"
    "pages_skipped\030\004 \001(\003\022\023\n\013range_start\030\005 \001(\003"
    "\022\021\n\trange_end\030\006 \001(\003\022\027\n\017writeback_index\030\007"
    " \001(\004\022\021\n\tsync_mode\030\010 \001(\005\022\023\n\013for_kupdate\030\t"
    " \001(\r\022\024\n\014range_cyclic\030\n \001(\r\"\242\001\n\037Ext4Write"
    "pagesResultFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003i"
    "no\030\002 \001(\004\022\013\n\003ret\030\003 \001(\005\022\025\n\rpages_written\030\004"
    " \001(\005\022\025\n\rpages_skipped\030\005 \001(\003\022\027\n\017writeback"
    "_index\030\006 \001(\004\022\021\n\tsync_mode\030\007 \001(\005\"_\n\030Ext4Z"
    "eroRangeFtraceEvent\022\013\n\003dev\030\001 \001(\004\022\013\n\003ino\030"
    "\002 \001(\004\022\016\n\006offset\030\003 \001(\003\022\013\n\003len\030\004 \001(\003\022\014\n\004mo"
    "de\030\005 \001(\005"
};
static ::absl::once_flag descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto = {
    false,
    false,
    10848,
    descriptor_table_protodef_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto,
    "protos/perfetto/trace/ftrace/ext4.proto",
    &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
    nullptr,
    0,
    95,
    schemas,
    file_default_instances,
    TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto::offsets,
    file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto,
    file_level_enum_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto,
    file_level_service_descriptors_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter() {
  return &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto(&descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto);
namespace perfetto {
namespace protos {
// ===================================================================

class Ext4DaWriteBeginFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWriteBeginFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DaWriteBeginFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
}
Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent(const Ext4DaWriteBeginFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
}

inline void Ext4DaWriteBeginFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pos_) { ::int64_t{0} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.flags_) { 0u }

  };
}

Ext4DaWriteBeginFtraceEvent::~Ext4DaWriteBeginFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaWriteBeginFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaWriteBeginFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DaWriteBeginFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DaWriteBeginFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DaWriteBeginFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  return target;
}

::size_t Ext4DaWriteBeginFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DaWriteBeginFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DaWriteBeginFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DaWriteBeginFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DaWriteBeginFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DaWriteBeginFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DaWriteBeginFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DaWriteBeginFtraceEvent::CopyFrom(const Ext4DaWriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWriteBeginFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWriteBeginFtraceEvent::InternalSwap(Ext4DaWriteBeginFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaWriteBeginFtraceEvent, _impl_.flags_)
      + sizeof(Ext4DaWriteBeginFtraceEvent::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaWriteBeginFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DaWriteBeginFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[0]);
}
// ===================================================================

class Ext4DaWriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWriteEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DaWriteEndFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaWriteEndFtraceEvent)
}
Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent(const Ext4DaWriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWriteEndFtraceEvent)
}

inline void Ext4DaWriteEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pos_) { ::int64_t{0} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.copied_) { 0u }

  };
}

Ext4DaWriteEndFtraceEvent::~Ext4DaWriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaWriteEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaWriteEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DaWriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.copied_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.copied_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DaWriteEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          _impl_.copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DaWriteEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_copied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  return target;
}

::size_t Ext4DaWriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_copied());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DaWriteEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DaWriteEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DaWriteEndFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DaWriteEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DaWriteEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DaWriteEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.copied_ = from._impl_.copied_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DaWriteEndFtraceEvent::CopyFrom(const Ext4DaWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWriteEndFtraceEvent::InternalSwap(Ext4DaWriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaWriteEndFtraceEvent, _impl_.copied_)
      + sizeof(Ext4DaWriteEndFtraceEvent::_impl_.copied_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaWriteEndFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DaWriteEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[1]);
}
// ===================================================================

class Ext4SyncFileEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4SyncFileEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4SyncFileEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_datasync(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
}
Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent(const Ext4SyncFileEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
}

inline void Ext4SyncFileEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.parent_) { ::uint64_t{0u} }

    , decltype(_impl_.datasync_) { 0 }

  };
}

Ext4SyncFileEnterFtraceEvent::~Ext4SyncFileEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4SyncFileEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4SyncFileEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4SyncFileEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.datasync_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.datasync_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4SyncFileEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_parent(&has_bits);
          _impl_.parent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 datasync = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_datasync(&has_bits);
          _impl_.datasync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4SyncFileEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 parent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_parent(), target);
  }

  // optional int32 datasync = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_datasync(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  return target;
}

::size_t Ext4SyncFileEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 parent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_parent());
    }

    // optional int32 datasync = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_datasync());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4SyncFileEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4SyncFileEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4SyncFileEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4SyncFileEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4SyncFileEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4SyncFileEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.parent_ = from._impl_.parent_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.datasync_ = from._impl_.datasync_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4SyncFileEnterFtraceEvent::CopyFrom(const Ext4SyncFileEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4SyncFileEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4SyncFileEnterFtraceEvent::InternalSwap(Ext4SyncFileEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4SyncFileEnterFtraceEvent, _impl_.datasync_)
      + sizeof(Ext4SyncFileEnterFtraceEvent::_impl_.datasync_)
      - PROTOBUF_FIELD_OFFSET(Ext4SyncFileEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4SyncFileEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[2]);
}
// ===================================================================

class Ext4SyncFileExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4SyncFileExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4SyncFileExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4SyncFileExitFtraceEvent)
}
Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent(const Ext4SyncFileExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4SyncFileExitFtraceEvent)
}

inline void Ext4SyncFileExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.ret_) { 0 }

  };
}

Ext4SyncFileExitFtraceEvent::~Ext4SyncFileExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4SyncFileExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4SyncFileExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4SyncFileExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4SyncFileExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4SyncFileExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  return target;
}

::size_t Ext4SyncFileExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4SyncFileExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4SyncFileExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4SyncFileExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4SyncFileExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4SyncFileExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4SyncFileExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4SyncFileExitFtraceEvent::CopyFrom(const Ext4SyncFileExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4SyncFileExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4SyncFileExitFtraceEvent::InternalSwap(Ext4SyncFileExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4SyncFileExitFtraceEvent, _impl_.ret_)
      + sizeof(Ext4SyncFileExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4SyncFileExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4SyncFileExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[3]);
}
// ===================================================================

class Ext4AllocDaBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4AllocDaBlocksFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4AllocDaBlocksFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
}
Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent(const Ext4AllocDaBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
}

inline void Ext4AllocDaBlocksFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.data_blocks_) { 0u }

    , decltype(_impl_.meta_blocks_) { 0u }

  };
}

Ext4AllocDaBlocksFtraceEvent::~Ext4AllocDaBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4AllocDaBlocksFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4AllocDaBlocksFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4AllocDaBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.meta_blocks_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.meta_blocks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4AllocDaBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 data_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_data_blocks(&has_bits);
          _impl_.data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 meta_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_meta_blocks(&has_bits);
          _impl_.meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4AllocDaBlocksFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 data_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_data_blocks(), target);
  }

  // optional uint32 meta_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_meta_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  return target;
}

::size_t Ext4AllocDaBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 data_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_data_blocks());
    }

    // optional uint32 meta_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_meta_blocks());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4AllocDaBlocksFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4AllocDaBlocksFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4AllocDaBlocksFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4AllocDaBlocksFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4AllocDaBlocksFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4AllocDaBlocksFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.data_blocks_ = from._impl_.data_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.meta_blocks_ = from._impl_.meta_blocks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4AllocDaBlocksFtraceEvent::CopyFrom(const Ext4AllocDaBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4AllocDaBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4AllocDaBlocksFtraceEvent::InternalSwap(Ext4AllocDaBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4AllocDaBlocksFtraceEvent, _impl_.meta_blocks_)
      + sizeof(Ext4AllocDaBlocksFtraceEvent::_impl_.meta_blocks_)
      - PROTOBUF_FIELD_OFFSET(Ext4AllocDaBlocksFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4AllocDaBlocksFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[4]);
}
// ===================================================================

class Ext4AllocateBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4AllocateBlocksFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4AllocateBlocksFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lleft(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lright(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_goal(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pleft(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pright(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
}
Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent(const Ext4AllocateBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
}

inline void Ext4AllocateBlocksFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.block_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.logical_) { 0u }

    , decltype(_impl_.lleft_) { 0u }

    , decltype(_impl_.lright_) { 0u }

    , decltype(_impl_.goal_) { ::uint64_t{0u} }

    , decltype(_impl_.pleft_) { ::uint64_t{0u} }

    , decltype(_impl_.pright_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { 0u }

  };
}

Ext4AllocateBlocksFtraceEvent::~Ext4AllocateBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4AllocateBlocksFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4AllocateBlocksFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4AllocateBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.goal_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.goal_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.pleft_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.pleft_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4AllocateBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          _impl_.block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 logical = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_logical(&has_bits);
          _impl_.logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lleft = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_lleft(&has_bits);
          _impl_.lleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lright = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_lright(&has_bits);
          _impl_.lright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 goal = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_goal(&has_bits);
          _impl_.goal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pleft = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_pleft(&has_bits);
          _impl_.pleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pright = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_pright(&has_bits);
          _impl_.pright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4AllocateBlocksFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_block(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 logical = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_logical(), target);
  }

  // optional uint32 lleft = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_lleft(), target);
  }

  // optional uint32 lright = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_lright(), target);
  }

  // optional uint64 goal = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_goal(), target);
  }

  // optional uint64 pleft = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        9, this->_internal_pleft(), target);
  }

  // optional uint64 pright = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        10, this->_internal_pright(), target);
  }

  // optional uint32 flags = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  return target;
}

::size_t Ext4AllocateBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_block());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 logical = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_logical());
    }

    // optional uint32 lleft = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lleft());
    }

    // optional uint32 lright = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lright());
    }

    // optional uint64 goal = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_goal());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint64 pleft = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pleft());
    }

    // optional uint64 pright = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pright());
    }

    // optional uint32 flags = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4AllocateBlocksFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4AllocateBlocksFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4AllocateBlocksFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4AllocateBlocksFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4AllocateBlocksFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4AllocateBlocksFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.block_ = from._impl_.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.logical_ = from._impl_.logical_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.lleft_ = from._impl_.lleft_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.lright_ = from._impl_.lright_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.goal_ = from._impl_.goal_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.pleft_ = from._impl_.pleft_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pright_ = from._impl_.pright_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4AllocateBlocksFtraceEvent::CopyFrom(const Ext4AllocateBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4AllocateBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4AllocateBlocksFtraceEvent::InternalSwap(Ext4AllocateBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4AllocateBlocksFtraceEvent, _impl_.flags_)
      + sizeof(Ext4AllocateBlocksFtraceEvent::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4AllocateBlocksFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4AllocateBlocksFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[5]);
}
// ===================================================================

class Ext4AllocateInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4AllocateInodeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4AllocateInodeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4AllocateInodeFtraceEvent)
}
Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent(const Ext4AllocateInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4AllocateInodeFtraceEvent)
}

inline void Ext4AllocateInodeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.dir_) { ::uint64_t{0u} }

    , decltype(_impl_.mode_) { 0u }

  };
}

Ext4AllocateInodeFtraceEvent::~Ext4AllocateInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4AllocateInodeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4AllocateInodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4AllocateInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4AllocateInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 dir = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_dir(&has_bits);
          _impl_.dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4AllocateInodeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 dir = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_dir(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  return target;
}

::size_t Ext4AllocateInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 dir = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dir());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4AllocateInodeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4AllocateInodeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4AllocateInodeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4AllocateInodeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4AllocateInodeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4AllocateInodeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.dir_ = from._impl_.dir_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4AllocateInodeFtraceEvent::CopyFrom(const Ext4AllocateInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4AllocateInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4AllocateInodeFtraceEvent::InternalSwap(Ext4AllocateInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4AllocateInodeFtraceEvent, _impl_.mode_)
      + sizeof(Ext4AllocateInodeFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4AllocateInodeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4AllocateInodeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[6]);
}
// ===================================================================

class Ext4BeginOrderedTruncateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4BeginOrderedTruncateFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4BeginOrderedTruncateFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
}
Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent(const Ext4BeginOrderedTruncateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
}

inline void Ext4BeginOrderedTruncateFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.new_size_) { ::int64_t{0} }

  };
}

Ext4BeginOrderedTruncateFtraceEvent::~Ext4BeginOrderedTruncateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4BeginOrderedTruncateFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4BeginOrderedTruncateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4BeginOrderedTruncateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.new_size_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.new_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4BeginOrderedTruncateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 new_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_new_size(&has_bits);
          _impl_.new_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4BeginOrderedTruncateFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 new_size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_new_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  return target;
}

::size_t Ext4BeginOrderedTruncateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 new_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_new_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4BeginOrderedTruncateFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4BeginOrderedTruncateFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4BeginOrderedTruncateFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4BeginOrderedTruncateFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4BeginOrderedTruncateFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4BeginOrderedTruncateFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_size_ = from._impl_.new_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4BeginOrderedTruncateFtraceEvent::CopyFrom(const Ext4BeginOrderedTruncateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4BeginOrderedTruncateFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4BeginOrderedTruncateFtraceEvent::InternalSwap(Ext4BeginOrderedTruncateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4BeginOrderedTruncateFtraceEvent, _impl_.new_size_)
      + sizeof(Ext4BeginOrderedTruncateFtraceEvent::_impl_.new_size_)
      - PROTOBUF_FIELD_OFFSET(Ext4BeginOrderedTruncateFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4BeginOrderedTruncateFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[7]);
}
// ===================================================================

class Ext4CollapseRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4CollapseRangeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4CollapseRangeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4CollapseRangeFtraceEvent)
}
Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent(const Ext4CollapseRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4CollapseRangeFtraceEvent)
}

inline void Ext4CollapseRangeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.offset_) { ::int64_t{0} }

    , decltype(_impl_.len_) { ::int64_t{0} }

  };
}

Ext4CollapseRangeFtraceEvent::~Ext4CollapseRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4CollapseRangeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4CollapseRangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4CollapseRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4CollapseRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4CollapseRangeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  return target;
}

::size_t Ext4CollapseRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4CollapseRangeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4CollapseRangeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4CollapseRangeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4CollapseRangeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4CollapseRangeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4CollapseRangeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4CollapseRangeFtraceEvent::CopyFrom(const Ext4CollapseRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4CollapseRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4CollapseRangeFtraceEvent::InternalSwap(Ext4CollapseRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4CollapseRangeFtraceEvent, _impl_.len_)
      + sizeof(Ext4CollapseRangeFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(Ext4CollapseRangeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4CollapseRangeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[8]);
}
// ===================================================================

class Ext4DaReleaseSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaReleaseSpaceFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DaReleaseSpaceFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_freed_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reserved_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reserved_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_allocated_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
}
Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent(const Ext4DaReleaseSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
}

inline void Ext4DaReleaseSpaceFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.i_blocks_) { ::uint64_t{0u} }

    , decltype(_impl_.freed_blocks_) { 0 }

    , decltype(_impl_.reserved_data_blocks_) { 0 }

    , decltype(_impl_.reserved_meta_blocks_) { 0 }

    , decltype(_impl_.allocated_meta_blocks_) { 0 }

    , decltype(_impl_.mode_) { 0u }

  };
}

Ext4DaReleaseSpaceFtraceEvent::~Ext4DaReleaseSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaReleaseSpaceFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaReleaseSpaceFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DaReleaseSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DaReleaseSpaceFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 i_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_i_blocks(&has_bits);
          _impl_.i_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 freed_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_freed_blocks(&has_bits);
          _impl_.freed_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 reserved_data_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_reserved_data_blocks(&has_bits);
          _impl_.reserved_data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 reserved_meta_blocks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_reserved_meta_blocks(&has_bits);
          _impl_.reserved_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 allocated_meta_blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_allocated_meta_blocks(&has_bits);
          _impl_.allocated_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DaReleaseSpaceFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 i_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_i_blocks(), target);
  }

  // optional int32 freed_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_freed_blocks(), target);
  }

  // optional int32 reserved_data_blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_reserved_data_blocks(), target);
  }

  // optional int32 reserved_meta_blocks = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_reserved_meta_blocks(), target);
  }

  // optional int32 allocated_meta_blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_allocated_meta_blocks(), target);
  }

  // optional uint32 mode = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  return target;
}

::size_t Ext4DaReleaseSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 i_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_i_blocks());
    }

    // optional int32 freed_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_freed_blocks());
    }

    // optional int32 reserved_data_blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_reserved_data_blocks());
    }

    // optional int32 reserved_meta_blocks = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_reserved_meta_blocks());
    }

    // optional int32 allocated_meta_blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_allocated_meta_blocks());
    }

    // optional uint32 mode = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DaReleaseSpaceFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DaReleaseSpaceFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DaReleaseSpaceFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DaReleaseSpaceFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DaReleaseSpaceFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DaReleaseSpaceFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.i_blocks_ = from._impl_.i_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.freed_blocks_ = from._impl_.freed_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.reserved_data_blocks_ = from._impl_.reserved_data_blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.reserved_meta_blocks_ = from._impl_.reserved_meta_blocks_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.allocated_meta_blocks_ = from._impl_.allocated_meta_blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DaReleaseSpaceFtraceEvent::CopyFrom(const Ext4DaReleaseSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaReleaseSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaReleaseSpaceFtraceEvent::InternalSwap(Ext4DaReleaseSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaReleaseSpaceFtraceEvent, _impl_.mode_)
      + sizeof(Ext4DaReleaseSpaceFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaReleaseSpaceFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DaReleaseSpaceFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[9]);
}
// ===================================================================

class Ext4DaReserveSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaReserveSpaceFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DaReserveSpaceFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_reserved_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reserved_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_md_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
}
Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent(const Ext4DaReserveSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
}

inline void Ext4DaReserveSpaceFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.i_blocks_) { ::uint64_t{0u} }

    , decltype(_impl_.reserved_data_blocks_) { 0 }

    , decltype(_impl_.reserved_meta_blocks_) { 0 }

    , decltype(_impl_.mode_) { 0u }

    , decltype(_impl_.md_needed_) { 0 }

  };
}

Ext4DaReserveSpaceFtraceEvent::~Ext4DaReserveSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaReserveSpaceFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaReserveSpaceFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DaReserveSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.md_needed_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.md_needed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DaReserveSpaceFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 i_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_i_blocks(&has_bits);
          _impl_.i_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 reserved_data_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_reserved_data_blocks(&has_bits);
          _impl_.reserved_data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 reserved_meta_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_reserved_meta_blocks(&has_bits);
          _impl_.reserved_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 md_needed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_md_needed(&has_bits);
          _impl_.md_needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DaReserveSpaceFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 i_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_i_blocks(), target);
  }

  // optional int32 reserved_data_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_reserved_data_blocks(), target);
  }

  // optional int32 reserved_meta_blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_reserved_meta_blocks(), target);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_mode(), target);
  }

  // optional int32 md_needed = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_md_needed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  return target;
}

::size_t Ext4DaReserveSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 i_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_i_blocks());
    }

    // optional int32 reserved_data_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_reserved_data_blocks());
    }

    // optional int32 reserved_meta_blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_reserved_meta_blocks());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mode());
    }

    // optional int32 md_needed = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_md_needed());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DaReserveSpaceFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DaReserveSpaceFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DaReserveSpaceFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DaReserveSpaceFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DaReserveSpaceFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DaReserveSpaceFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.i_blocks_ = from._impl_.i_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.reserved_data_blocks_ = from._impl_.reserved_data_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.reserved_meta_blocks_ = from._impl_.reserved_meta_blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.md_needed_ = from._impl_.md_needed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DaReserveSpaceFtraceEvent::CopyFrom(const Ext4DaReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaReserveSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaReserveSpaceFtraceEvent::InternalSwap(Ext4DaReserveSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaReserveSpaceFtraceEvent, _impl_.md_needed_)
      + sizeof(Ext4DaReserveSpaceFtraceEvent::_impl_.md_needed_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaReserveSpaceFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DaReserveSpaceFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[10]);
}
// ===================================================================

class Ext4DaUpdateReserveSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaUpdateReserveSpaceFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DaUpdateReserveSpaceFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_used_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reserved_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reserved_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_allocated_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_quota_claim(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
}
Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent(const Ext4DaUpdateReserveSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
}

inline void Ext4DaUpdateReserveSpaceFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.i_blocks_) { ::uint64_t{0u} }

    , decltype(_impl_.used_blocks_) { 0 }

    , decltype(_impl_.reserved_data_blocks_) { 0 }

    , decltype(_impl_.reserved_meta_blocks_) { 0 }

    , decltype(_impl_.allocated_meta_blocks_) { 0 }

    , decltype(_impl_.quota_claim_) { 0 }

    , decltype(_impl_.mode_) { 0u }

  };
}

Ext4DaUpdateReserveSpaceFtraceEvent::~Ext4DaUpdateReserveSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaUpdateReserveSpaceFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaUpdateReserveSpaceFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DaUpdateReserveSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.quota_claim_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.quota_claim_));
  }
  _impl_.mode_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DaUpdateReserveSpaceFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 i_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_i_blocks(&has_bits);
          _impl_.i_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 used_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_used_blocks(&has_bits);
          _impl_.used_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 reserved_data_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_reserved_data_blocks(&has_bits);
          _impl_.reserved_data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 reserved_meta_blocks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_reserved_meta_blocks(&has_bits);
          _impl_.reserved_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 allocated_meta_blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_allocated_meta_blocks(&has_bits);
          _impl_.allocated_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 quota_claim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_quota_claim(&has_bits);
          _impl_.quota_claim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mode = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DaUpdateReserveSpaceFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 i_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_i_blocks(), target);
  }

  // optional int32 used_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_used_blocks(), target);
  }

  // optional int32 reserved_data_blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_reserved_data_blocks(), target);
  }

  // optional int32 reserved_meta_blocks = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_reserved_meta_blocks(), target);
  }

  // optional int32 allocated_meta_blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_allocated_meta_blocks(), target);
  }

  // optional int32 quota_claim = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_quota_claim(), target);
  }

  // optional uint32 mode = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  return target;
}

::size_t Ext4DaUpdateReserveSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 i_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_i_blocks());
    }

    // optional int32 used_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_used_blocks());
    }

    // optional int32 reserved_data_blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_reserved_data_blocks());
    }

    // optional int32 reserved_meta_blocks = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_reserved_meta_blocks());
    }

    // optional int32 allocated_meta_blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_allocated_meta_blocks());
    }

    // optional int32 quota_claim = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_quota_claim());
    }

  }
  // optional uint32 mode = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DaUpdateReserveSpaceFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DaUpdateReserveSpaceFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DaUpdateReserveSpaceFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DaUpdateReserveSpaceFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DaUpdateReserveSpaceFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DaUpdateReserveSpaceFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.i_blocks_ = from._impl_.i_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.used_blocks_ = from._impl_.used_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.reserved_data_blocks_ = from._impl_.reserved_data_blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.reserved_meta_blocks_ = from._impl_.reserved_meta_blocks_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.allocated_meta_blocks_ = from._impl_.allocated_meta_blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.quota_claim_ = from._impl_.quota_claim_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DaUpdateReserveSpaceFtraceEvent::CopyFrom(const Ext4DaUpdateReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaUpdateReserveSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaUpdateReserveSpaceFtraceEvent::InternalSwap(Ext4DaUpdateReserveSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.mode_)
      + sizeof(Ext4DaUpdateReserveSpaceFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaUpdateReserveSpaceFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DaUpdateReserveSpaceFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[11]);
}
// ===================================================================

class Ext4DaWritePagesFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWritePagesFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_first_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nr_to_write(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sync_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_b_blocknr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_b_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_b_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_io_done(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pages_written(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaWritePagesFtraceEvent)
}
Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent(const Ext4DaWritePagesFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWritePagesFtraceEvent)
}

inline void Ext4DaWritePagesFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.first_page_) { ::uint64_t{0u} }

    , decltype(_impl_.nr_to_write_) { ::int64_t{0} }

    , decltype(_impl_.b_blocknr_) { ::uint64_t{0u} }

    , decltype(_impl_.sync_mode_) { 0 }

    , decltype(_impl_.b_size_) { 0u }

    , decltype(_impl_.b_state_) { 0u }

    , decltype(_impl_.io_done_) { 0 }

    , decltype(_impl_.pages_written_) { 0 }

  };
}

Ext4DaWritePagesFtraceEvent::~Ext4DaWritePagesFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaWritePagesFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaWritePagesFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DaWritePagesFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.b_state_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.b_state_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.io_done_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pages_written_) -
        reinterpret_cast<char*>(&_impl_.io_done_)) + sizeof(_impl_.pages_written_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DaWritePagesFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 first_page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_first_page(&has_bits);
          _impl_.first_page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 nr_to_write = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_nr_to_write(&has_bits);
          _impl_.nr_to_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 sync_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_sync_mode(&has_bits);
          _impl_.sync_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 b_blocknr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_b_blocknr(&has_bits);
          _impl_.b_blocknr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 b_size = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_b_size(&has_bits);
          _impl_.b_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 b_state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_b_state(&has_bits);
          _impl_.b_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 io_done = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_io_done(&has_bits);
          _impl_.io_done_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pages_written = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_pages_written(&has_bits);
          _impl_.pages_written_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DaWritePagesFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 first_page = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_first_page(), target);
  }

  // optional int64 nr_to_write = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_nr_to_write(), target);
  }

  // optional int32 sync_mode = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_sync_mode(), target);
  }

  // optional uint64 b_blocknr = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_b_blocknr(), target);
  }

  // optional uint32 b_size = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_b_size(), target);
  }

  // optional uint32 b_state = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_b_state(), target);
  }

  // optional int32 io_done = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_io_done(), target);
  }

  // optional int32 pages_written = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_pages_written(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  return target;
}

::size_t Ext4DaWritePagesFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 first_page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_first_page());
    }

    // optional int64 nr_to_write = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_nr_to_write());
    }

    // optional uint64 b_blocknr = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_b_blocknr());
    }

    // optional int32 sync_mode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_sync_mode());
    }

    // optional uint32 b_size = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_b_size());
    }

    // optional uint32 b_state = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_b_state());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 io_done = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_io_done());
    }

    // optional int32 pages_written = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pages_written());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DaWritePagesFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DaWritePagesFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DaWritePagesFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DaWritePagesFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DaWritePagesFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DaWritePagesFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.first_page_ = from._impl_.first_page_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.nr_to_write_ = from._impl_.nr_to_write_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.b_blocknr_ = from._impl_.b_blocknr_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sync_mode_ = from._impl_.sync_mode_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.b_size_ = from._impl_.b_size_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.b_state_ = from._impl_.b_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.io_done_ = from._impl_.io_done_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pages_written_ = from._impl_.pages_written_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DaWritePagesFtraceEvent::CopyFrom(const Ext4DaWritePagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWritePagesFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWritePagesFtraceEvent::InternalSwap(Ext4DaWritePagesFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesFtraceEvent, _impl_.pages_written_)
      + sizeof(Ext4DaWritePagesFtraceEvent::_impl_.pages_written_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DaWritePagesFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[12]);
}
// ===================================================================

class Ext4DaWritePagesExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWritePagesExtentFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesExtentFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
}
Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent(const Ext4DaWritePagesExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
}

inline void Ext4DaWritePagesExtentFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.flags_) { 0u }

  };
}

Ext4DaWritePagesExtentFtraceEvent::~Ext4DaWritePagesExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaWritePagesExtentFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaWritePagesExtentFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DaWritePagesExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DaWritePagesExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DaWritePagesExtentFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  return target;
}

::size_t Ext4DaWritePagesExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DaWritePagesExtentFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DaWritePagesExtentFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DaWritePagesExtentFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DaWritePagesExtentFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DaWritePagesExtentFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DaWritePagesExtentFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DaWritePagesExtentFtraceEvent::CopyFrom(const Ext4DaWritePagesExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWritePagesExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWritePagesExtentFtraceEvent::InternalSwap(Ext4DaWritePagesExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesExtentFtraceEvent, _impl_.flags_)
      + sizeof(Ext4DaWritePagesExtentFtraceEvent::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesExtentFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DaWritePagesExtentFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[13]);
}
// ===================================================================

class Ext4DirectIOEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DirectIOEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DirectIOEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rw(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
}
Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent(const Ext4DirectIOEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
}

inline void Ext4DirectIOEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pos_) { ::int64_t{0} }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

    , decltype(_impl_.rw_) { 0 }

  };
}

Ext4DirectIOEnterFtraceEvent::~Ext4DirectIOEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DirectIOEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DirectIOEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DirectIOEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.rw_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.rw_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DirectIOEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 rw = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_rw(&has_bits);
          _impl_.rw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DirectIOEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_pos(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_len(), target);
  }

  // optional int32 rw = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_rw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  return target;
}

::size_t Ext4DirectIOEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pos());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

    // optional int32 rw = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_rw());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DirectIOEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DirectIOEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DirectIOEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DirectIOEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DirectIOEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DirectIOEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rw_ = from._impl_.rw_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DirectIOEnterFtraceEvent::CopyFrom(const Ext4DirectIOEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DirectIOEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DirectIOEnterFtraceEvent::InternalSwap(Ext4DirectIOEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DirectIOEnterFtraceEvent, _impl_.rw_)
      + sizeof(Ext4DirectIOEnterFtraceEvent::_impl_.rw_)
      - PROTOBUF_FIELD_OFFSET(Ext4DirectIOEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DirectIOEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[14]);
}
// ===================================================================

class Ext4DirectIOExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DirectIOExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DirectIOExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rw(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DirectIOExitFtraceEvent)
}
Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent(const Ext4DirectIOExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DirectIOExitFtraceEvent)
}

inline void Ext4DirectIOExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pos_) { ::int64_t{0} }

    , decltype(_impl_.len_) { ::uint64_t{0u} }

    , decltype(_impl_.rw_) { 0 }

    , decltype(_impl_.ret_) { 0 }

  };
}

Ext4DirectIOExitFtraceEvent::~Ext4DirectIOExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DirectIOExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DirectIOExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DirectIOExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DirectIOExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 rw = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_rw(&has_bits);
          _impl_.rw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DirectIOExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_pos(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_len(), target);
  }

  // optional int32 rw = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_rw(), target);
  }

  // optional int32 ret = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  return target;
}

::size_t Ext4DirectIOExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pos());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

    // optional int32 rw = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_rw());
    }

    // optional int32 ret = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DirectIOExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DirectIOExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DirectIOExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DirectIOExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DirectIOExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DirectIOExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rw_ = from._impl_.rw_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DirectIOExitFtraceEvent::CopyFrom(const Ext4DirectIOExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DirectIOExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DirectIOExitFtraceEvent::InternalSwap(Ext4DirectIOExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DirectIOExitFtraceEvent, _impl_.ret_)
      + sizeof(Ext4DirectIOExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4DirectIOExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DirectIOExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[15]);
}
// ===================================================================

class Ext4DiscardBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DiscardBlocksFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DiscardBlocksFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
}
Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent(const Ext4DiscardBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
}

inline void Ext4DiscardBlocksFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.blk_) { ::uint64_t{0u} }

    , decltype(_impl_.count_) { ::uint64_t{0u} }

  };
}

Ext4DiscardBlocksFtraceEvent::~Ext4DiscardBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DiscardBlocksFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DiscardBlocksFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DiscardBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DiscardBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 blk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_blk(&has_bits);
          _impl_.blk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DiscardBlocksFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 blk = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_blk(), target);
  }

  // optional uint64 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  return target;
}

::size_t Ext4DiscardBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 blk = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_blk());
    }

    // optional uint64 count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DiscardBlocksFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DiscardBlocksFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DiscardBlocksFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DiscardBlocksFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DiscardBlocksFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DiscardBlocksFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.blk_ = from._impl_.blk_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DiscardBlocksFtraceEvent::CopyFrom(const Ext4DiscardBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DiscardBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DiscardBlocksFtraceEvent::InternalSwap(Ext4DiscardBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DiscardBlocksFtraceEvent, _impl_.count_)
      + sizeof(Ext4DiscardBlocksFtraceEvent::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(Ext4DiscardBlocksFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DiscardBlocksFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[16]);
}
// ===================================================================

class Ext4DiscardPreallocationsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DiscardPreallocationsFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DiscardPreallocationsFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
}
Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent(const Ext4DiscardPreallocationsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
}

inline void Ext4DiscardPreallocationsFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.needed_) { 0u }

  };
}

Ext4DiscardPreallocationsFtraceEvent::~Ext4DiscardPreallocationsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DiscardPreallocationsFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DiscardPreallocationsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DiscardPreallocationsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.needed_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.needed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DiscardPreallocationsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 needed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_needed(&has_bits);
          _impl_.needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DiscardPreallocationsFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 len = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_len(), target);
  }

  // optional uint32 needed = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_needed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  return target;
}

::size_t Ext4DiscardPreallocationsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 len = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 needed = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_needed());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DiscardPreallocationsFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DiscardPreallocationsFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DiscardPreallocationsFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DiscardPreallocationsFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DiscardPreallocationsFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DiscardPreallocationsFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.needed_ = from._impl_.needed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DiscardPreallocationsFtraceEvent::CopyFrom(const Ext4DiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DiscardPreallocationsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DiscardPreallocationsFtraceEvent::InternalSwap(Ext4DiscardPreallocationsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DiscardPreallocationsFtraceEvent, _impl_.needed_)
      + sizeof(Ext4DiscardPreallocationsFtraceEvent::_impl_.needed_)
      - PROTOBUF_FIELD_OFFSET(Ext4DiscardPreallocationsFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DiscardPreallocationsFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[17]);
}
// ===================================================================

class Ext4DropInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DropInodeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4DropInodeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_drop(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DropInodeFtraceEvent)
}
Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent(const Ext4DropInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DropInodeFtraceEvent)
}

inline void Ext4DropInodeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.drop_) { 0 }

  };
}

Ext4DropInodeFtraceEvent::~Ext4DropInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DropInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DropInodeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DropInodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4DropInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.drop_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.drop_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4DropInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 drop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_drop(&has_bits);
          _impl_.drop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4DropInodeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int32 drop = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_drop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DropInodeFtraceEvent)
  return target;
}

::size_t Ext4DropInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int32 drop = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_drop());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4DropInodeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4DropInodeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4DropInodeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4DropInodeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4DropInodeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4DropInodeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.drop_ = from._impl_.drop_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4DropInodeFtraceEvent::CopyFrom(const Ext4DropInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DropInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DropInodeFtraceEvent::InternalSwap(Ext4DropInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DropInodeFtraceEvent, _impl_.drop_)
      + sizeof(Ext4DropInodeFtraceEvent::_impl_.drop_)
      - PROTOBUF_FIELD_OFFSET(Ext4DropInodeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4DropInodeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[18]);
}
// ===================================================================

class Ext4EsCacheExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsCacheExtentFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsCacheExtentFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
}
Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent(const Ext4EsCacheExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
}

inline void Ext4EsCacheExtentFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.status_) { 0u }

  };
}

Ext4EsCacheExtentFtraceEvent::~Ext4EsCacheExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsCacheExtentFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsCacheExtentFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsCacheExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.status_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsCacheExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsCacheExtentFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_pblk(), target);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  return target;
}

::size_t Ext4EsCacheExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint32 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsCacheExtentFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsCacheExtentFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsCacheExtentFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsCacheExtentFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsCacheExtentFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsCacheExtentFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsCacheExtentFtraceEvent::CopyFrom(const Ext4EsCacheExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsCacheExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsCacheExtentFtraceEvent::InternalSwap(Ext4EsCacheExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsCacheExtentFtraceEvent, _impl_.status_)
      + sizeof(Ext4EsCacheExtentFtraceEvent::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsCacheExtentFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsCacheExtentFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[19]);
}
// ===================================================================

class Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsFindDelayedExtentRangeEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
}
Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
}

inline void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

  };
}

Ext4EsFindDelayedExtentRangeEnterFtraceEvent::~Ext4EsFindDelayedExtentRangeEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.lblk_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.lblk_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  return target;
}

::size_t Ext4EsFindDelayedExtentRangeEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsFindDelayedExtentRangeEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsFindDelayedExtentRangeEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsFindDelayedExtentRangeEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsFindDelayedExtentRangeEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::CopyFrom(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsFindDelayedExtentRangeEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::InternalSwap(Ext4EsFindDelayedExtentRangeEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeEnterFtraceEvent, _impl_.lblk_)
      + sizeof(Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_impl_.lblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsFindDelayedExtentRangeEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[20]);
}
// ===================================================================

class Ext4EsFindDelayedExtentRangeExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsFindDelayedExtentRangeExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
}
Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
}

inline void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.status_) { ::uint64_t{0u} }

  };
}

Ext4EsFindDelayedExtentRangeExitFtraceEvent::~Ext4EsFindDelayedExtentRangeExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.status_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsFindDelayedExtentRangeExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsFindDelayedExtentRangeExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_pblk(), target);
  }

  // optional uint64 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  return target;
}

::size_t Ext4EsFindDelayedExtentRangeExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint64 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsFindDelayedExtentRangeExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsFindDelayedExtentRangeExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsFindDelayedExtentRangeExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsFindDelayedExtentRangeExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsFindDelayedExtentRangeExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsFindDelayedExtentRangeExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::CopyFrom(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsFindDelayedExtentRangeExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::InternalSwap(Ext4EsFindDelayedExtentRangeExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_.status_)
      + sizeof(Ext4EsFindDelayedExtentRangeExitFtraceEvent::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsFindDelayedExtentRangeExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[21]);
}
// ===================================================================

class Ext4EsInsertExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsInsertExtentFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsInsertExtentFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
}
Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent(const Ext4EsInsertExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
}

inline void Ext4EsInsertExtentFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.status_) { ::uint64_t{0u} }

  };
}

Ext4EsInsertExtentFtraceEvent::~Ext4EsInsertExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsInsertExtentFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsInsertExtentFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsInsertExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.status_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsInsertExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsInsertExtentFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_pblk(), target);
  }

  // optional uint64 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  return target;
}

::size_t Ext4EsInsertExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint64 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsInsertExtentFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsInsertExtentFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsInsertExtentFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsInsertExtentFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsInsertExtentFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsInsertExtentFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsInsertExtentFtraceEvent::CopyFrom(const Ext4EsInsertExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsInsertExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsInsertExtentFtraceEvent::InternalSwap(Ext4EsInsertExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsInsertExtentFtraceEvent, _impl_.status_)
      + sizeof(Ext4EsInsertExtentFtraceEvent::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsInsertExtentFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsInsertExtentFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[22]);
}
// ===================================================================

class Ext4EsLookupExtentEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsLookupExtentEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
}
Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent(const Ext4EsLookupExtentEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
}

inline void Ext4EsLookupExtentEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

  };
}

Ext4EsLookupExtentEnterFtraceEvent::~Ext4EsLookupExtentEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsLookupExtentEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsLookupExtentEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsLookupExtentEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.lblk_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.lblk_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsLookupExtentEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsLookupExtentEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  return target;
}

::size_t Ext4EsLookupExtentEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsLookupExtentEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsLookupExtentEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsLookupExtentEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsLookupExtentEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsLookupExtentEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsLookupExtentEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsLookupExtentEnterFtraceEvent::CopyFrom(const Ext4EsLookupExtentEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsLookupExtentEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsLookupExtentEnterFtraceEvent::InternalSwap(Ext4EsLookupExtentEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentEnterFtraceEvent, _impl_.lblk_)
      + sizeof(Ext4EsLookupExtentEnterFtraceEvent::_impl_.lblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsLookupExtentEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[23]);
}
// ===================================================================

class Ext4EsLookupExtentExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsLookupExtentExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
}
Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent(const Ext4EsLookupExtentExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
}

inline void Ext4EsLookupExtentExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.status_) { ::uint64_t{0u} }

    , decltype(_impl_.found_) { 0 }

  };
}

Ext4EsLookupExtentExitFtraceEvent::~Ext4EsLookupExtentExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsLookupExtentExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsLookupExtentExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsLookupExtentExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.found_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.found_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsLookupExtentExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 found = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_found(&has_bits);
          _impl_.found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsLookupExtentExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_pblk(), target);
  }

  // optional uint64 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_status(), target);
  }

  // optional int32 found = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_found(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  return target;
}

::size_t Ext4EsLookupExtentExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint64 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_status());
    }

    // optional int32 found = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_found());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsLookupExtentExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsLookupExtentExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsLookupExtentExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsLookupExtentExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsLookupExtentExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsLookupExtentExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.found_ = from._impl_.found_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsLookupExtentExitFtraceEvent::CopyFrom(const Ext4EsLookupExtentExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsLookupExtentExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsLookupExtentExitFtraceEvent::InternalSwap(Ext4EsLookupExtentExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentExitFtraceEvent, _impl_.found_)
      + sizeof(Ext4EsLookupExtentExitFtraceEvent::_impl_.found_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsLookupExtentExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[24]);
}
// ===================================================================

class Ext4EsRemoveExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsRemoveExtentFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsRemoveExtentFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
}
Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent(const Ext4EsRemoveExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
}

inline void Ext4EsRemoveExtentFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { ::int64_t{0} }

    , decltype(_impl_.len_) { ::int64_t{0} }

  };
}

Ext4EsRemoveExtentFtraceEvent::~Ext4EsRemoveExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsRemoveExtentFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsRemoveExtentFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsRemoveExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsRemoveExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsRemoveExtentFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  return target;
}

::size_t Ext4EsRemoveExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_lblk());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsRemoveExtentFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsRemoveExtentFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsRemoveExtentFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsRemoveExtentFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsRemoveExtentFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsRemoveExtentFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsRemoveExtentFtraceEvent::CopyFrom(const Ext4EsRemoveExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsRemoveExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsRemoveExtentFtraceEvent::InternalSwap(Ext4EsRemoveExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsRemoveExtentFtraceEvent, _impl_.len_)
      + sizeof(Ext4EsRemoveExtentFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsRemoveExtentFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsRemoveExtentFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[25]);
}
// ===================================================================

class Ext4EsShrinkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsShrinkFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_shrunk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_scan_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nr_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_retried(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsShrinkFtraceEvent)
}
Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent(const Ext4EsShrinkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkFtraceEvent)
}

inline void Ext4EsShrinkFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.scan_time_) { ::uint64_t{0u} }

    , decltype(_impl_.nr_shrunk_) { 0 }

    , decltype(_impl_.nr_skipped_) { 0 }

    , decltype(_impl_.retried_) { 0 }

  };
}

Ext4EsShrinkFtraceEvent::~Ext4EsShrinkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsShrinkFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsShrinkFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsShrinkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.retried_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.retried_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsShrinkFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 nr_shrunk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_nr_shrunk(&has_bits);
          _impl_.nr_shrunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 scan_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_scan_time(&has_bits);
          _impl_.scan_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 nr_skipped = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_nr_skipped(&has_bits);
          _impl_.nr_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 retried = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_retried(&has_bits);
          _impl_.retried_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsShrinkFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional int32 nr_shrunk = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_nr_shrunk(), target);
  }

  // optional uint64 scan_time = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_scan_time(), target);
  }

  // optional int32 nr_skipped = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_nr_skipped(), target);
  }

  // optional int32 retried = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_retried(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsShrinkFtraceEvent)
  return target;
}

::size_t Ext4EsShrinkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 scan_time = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_scan_time());
    }

    // optional int32 nr_shrunk = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_nr_shrunk());
    }

    // optional int32 nr_skipped = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_nr_skipped());
    }

    // optional int32 retried = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_retried());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsShrinkFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsShrinkFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsShrinkFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsShrinkFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsShrinkFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsShrinkFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.scan_time_ = from._impl_.scan_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nr_shrunk_ = from._impl_.nr_shrunk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.nr_skipped_ = from._impl_.nr_skipped_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.retried_ = from._impl_.retried_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsShrinkFtraceEvent::CopyFrom(const Ext4EsShrinkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkFtraceEvent::InternalSwap(Ext4EsShrinkFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsShrinkFtraceEvent, _impl_.retried_)
      + sizeof(Ext4EsShrinkFtraceEvent::_impl_.retried_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsShrinkFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsShrinkFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[26]);
}
// ===================================================================

class Ext4EsShrinkCountFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkCountFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsShrinkCountFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_to_scan(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
}
Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent(const Ext4EsShrinkCountFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
}

inline void Ext4EsShrinkCountFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.nr_to_scan_) { 0 }

    , decltype(_impl_.cache_cnt_) { 0 }

  };
}

Ext4EsShrinkCountFtraceEvent::~Ext4EsShrinkCountFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsShrinkCountFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsShrinkCountFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsShrinkCountFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.cache_cnt_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.cache_cnt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsShrinkCountFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 nr_to_scan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_nr_to_scan(&has_bits);
          _impl_.nr_to_scan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 cache_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_cache_cnt(&has_bits);
          _impl_.cache_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsShrinkCountFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional int32 nr_to_scan = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_nr_to_scan(), target);
  }

  // optional int32 cache_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_cache_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  return target;
}

::size_t Ext4EsShrinkCountFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional int32 nr_to_scan = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_nr_to_scan());
    }

    // optional int32 cache_cnt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_cache_cnt());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsShrinkCountFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsShrinkCountFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsShrinkCountFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsShrinkCountFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsShrinkCountFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsShrinkCountFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nr_to_scan_ = from._impl_.nr_to_scan_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cache_cnt_ = from._impl_.cache_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsShrinkCountFtraceEvent::CopyFrom(const Ext4EsShrinkCountFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkCountFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkCountFtraceEvent::InternalSwap(Ext4EsShrinkCountFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsShrinkCountFtraceEvent, _impl_.cache_cnt_)
      + sizeof(Ext4EsShrinkCountFtraceEvent::_impl_.cache_cnt_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsShrinkCountFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsShrinkCountFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[27]);
}
// ===================================================================

class Ext4EsShrinkScanEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkScanEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_to_scan(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
}
Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent(const Ext4EsShrinkScanEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
}

inline void Ext4EsShrinkScanEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.nr_to_scan_) { 0 }

    , decltype(_impl_.cache_cnt_) { 0 }

  };
}

Ext4EsShrinkScanEnterFtraceEvent::~Ext4EsShrinkScanEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsShrinkScanEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsShrinkScanEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsShrinkScanEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.cache_cnt_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.cache_cnt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsShrinkScanEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 nr_to_scan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_nr_to_scan(&has_bits);
          _impl_.nr_to_scan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 cache_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_cache_cnt(&has_bits);
          _impl_.cache_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsShrinkScanEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional int32 nr_to_scan = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_nr_to_scan(), target);
  }

  // optional int32 cache_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_cache_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  return target;
}

::size_t Ext4EsShrinkScanEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional int32 nr_to_scan = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_nr_to_scan());
    }

    // optional int32 cache_cnt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_cache_cnt());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsShrinkScanEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsShrinkScanEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsShrinkScanEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsShrinkScanEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsShrinkScanEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsShrinkScanEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nr_to_scan_ = from._impl_.nr_to_scan_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cache_cnt_ = from._impl_.cache_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsShrinkScanEnterFtraceEvent::CopyFrom(const Ext4EsShrinkScanEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkScanEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkScanEnterFtraceEvent::InternalSwap(Ext4EsShrinkScanEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanEnterFtraceEvent, _impl_.cache_cnt_)
      + sizeof(Ext4EsShrinkScanEnterFtraceEvent::_impl_.cache_cnt_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsShrinkScanEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[28]);
}
// ===================================================================

class Ext4EsShrinkScanExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkScanExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_shrunk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
}
Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent(const Ext4EsShrinkScanExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
}

inline void Ext4EsShrinkScanExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.nr_shrunk_) { 0 }

    , decltype(_impl_.cache_cnt_) { 0 }

  };
}

Ext4EsShrinkScanExitFtraceEvent::~Ext4EsShrinkScanExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsShrinkScanExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsShrinkScanExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EsShrinkScanExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.cache_cnt_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.cache_cnt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EsShrinkScanExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 nr_shrunk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_nr_shrunk(&has_bits);
          _impl_.nr_shrunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 cache_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_cache_cnt(&has_bits);
          _impl_.cache_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EsShrinkScanExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional int32 nr_shrunk = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_nr_shrunk(), target);
  }

  // optional int32 cache_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_cache_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  return target;
}

::size_t Ext4EsShrinkScanExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional int32 nr_shrunk = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_nr_shrunk());
    }

    // optional int32 cache_cnt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_cache_cnt());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EsShrinkScanExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EsShrinkScanExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EsShrinkScanExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EsShrinkScanExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EsShrinkScanExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EsShrinkScanExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nr_shrunk_ = from._impl_.nr_shrunk_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cache_cnt_ = from._impl_.cache_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EsShrinkScanExitFtraceEvent::CopyFrom(const Ext4EsShrinkScanExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkScanExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkScanExitFtraceEvent::InternalSwap(Ext4EsShrinkScanExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanExitFtraceEvent, _impl_.cache_cnt_)
      + sizeof(Ext4EsShrinkScanExitFtraceEvent::_impl_.cache_cnt_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EsShrinkScanExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[29]);
}
// ===================================================================

class Ext4EvictInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EvictInodeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4EvictInodeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EvictInodeFtraceEvent)
}
Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent(const Ext4EvictInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EvictInodeFtraceEvent)
}

inline void Ext4EvictInodeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.nlink_) { 0 }

  };
}

Ext4EvictInodeFtraceEvent::~Ext4EvictInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EvictInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EvictInodeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EvictInodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4EvictInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.nlink_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.nlink_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4EvictInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 nlink = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_nlink(&has_bits);
          _impl_.nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4EvictInodeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int32 nlink = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_nlink(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EvictInodeFtraceEvent)
  return target;
}

::size_t Ext4EvictInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int32 nlink = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_nlink());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4EvictInodeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4EvictInodeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4EvictInodeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4EvictInodeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4EvictInodeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4EvictInodeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nlink_ = from._impl_.nlink_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4EvictInodeFtraceEvent::CopyFrom(const Ext4EvictInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EvictInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EvictInodeFtraceEvent::InternalSwap(Ext4EvictInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EvictInodeFtraceEvent, _impl_.nlink_)
      + sizeof(Ext4EvictInodeFtraceEvent::_impl_.nlink_)
      - PROTOBUF_FIELD_OFFSET(Ext4EvictInodeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4EvictInodeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[30]);
}
// ===================================================================

class Ext4ExtConvertToInitializedEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtConvertToInitializedEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_u_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_u_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_u_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
}
Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent(const Ext4ExtConvertToInitializedEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
}

inline void Ext4ExtConvertToInitializedEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.m_lblk_) { 0u }

    , decltype(_impl_.m_len_) { 0u }

    , decltype(_impl_.u_lblk_) { 0u }

    , decltype(_impl_.u_len_) { 0u }

    , decltype(_impl_.u_pblk_) { ::uint64_t{0u} }

  };
}

Ext4ExtConvertToInitializedEnterFtraceEvent::~Ext4ExtConvertToInitializedEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtConvertToInitializedEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.u_pblk_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.u_pblk_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtConvertToInitializedEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 m_lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_lblk(&has_bits);
          _impl_.m_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 m_len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_m_len(&has_bits);
          _impl_.m_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 u_lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_u_lblk(&has_bits);
          _impl_.u_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 u_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_u_len(&has_bits);
          _impl_.u_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 u_pblk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_u_pblk(&has_bits);
          _impl_.u_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtConvertToInitializedEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 m_lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_m_lblk(), target);
  }

  // optional uint32 m_len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_m_len(), target);
  }

  // optional uint32 u_lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_u_lblk(), target);
  }

  // optional uint32 u_len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_u_len(), target);
  }

  // optional uint64 u_pblk = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_u_pblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  return target;
}

::size_t Ext4ExtConvertToInitializedEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 m_lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_m_lblk());
    }

    // optional uint32 m_len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_m_len());
    }

    // optional uint32 u_lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_u_lblk());
    }

    // optional uint32 u_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_u_len());
    }

    // optional uint64 u_pblk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_u_pblk());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtConvertToInitializedEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtConvertToInitializedEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtConvertToInitializedEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtConvertToInitializedEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtConvertToInitializedEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtConvertToInitializedEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_lblk_ = from._impl_.m_lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_len_ = from._impl_.m_len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.u_lblk_ = from._impl_.u_lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.u_len_ = from._impl_.u_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.u_pblk_ = from._impl_.u_pblk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::CopyFrom(const Ext4ExtConvertToInitializedEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtConvertToInitializedEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::InternalSwap(Ext4ExtConvertToInitializedEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_.u_pblk_)
      + sizeof(Ext4ExtConvertToInitializedEnterFtraceEvent::_impl_.u_pblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtConvertToInitializedEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[31]);
}
// ===================================================================

class Ext4ExtConvertToInitializedFastpathFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtConvertToInitializedFastpathFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_u_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_u_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_u_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_i_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_i_len(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_i_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
}
Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent(const Ext4ExtConvertToInitializedFastpathFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
}

inline void Ext4ExtConvertToInitializedFastpathFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.m_lblk_) { 0u }

    , decltype(_impl_.m_len_) { 0u }

    , decltype(_impl_.u_lblk_) { 0u }

    , decltype(_impl_.u_len_) { 0u }

    , decltype(_impl_.u_pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.i_lblk_) { 0u }

    , decltype(_impl_.i_len_) { 0u }

    , decltype(_impl_.i_pblk_) { ::uint64_t{0u} }

  };
}

Ext4ExtConvertToInitializedFastpathFtraceEvent::~Ext4ExtConvertToInitializedFastpathFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtConvertToInitializedFastpathFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.i_lblk_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.i_lblk_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.i_len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.i_pblk_) -
        reinterpret_cast<char*>(&_impl_.i_len_)) + sizeof(_impl_.i_pblk_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtConvertToInitializedFastpathFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 m_lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_lblk(&has_bits);
          _impl_.m_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 m_len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_m_len(&has_bits);
          _impl_.m_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 u_lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_u_lblk(&has_bits);
          _impl_.u_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 u_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_u_len(&has_bits);
          _impl_.u_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 u_pblk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_u_pblk(&has_bits);
          _impl_.u_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 i_lblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_i_lblk(&has_bits);
          _impl_.i_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 i_len = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_i_len(&has_bits);
          _impl_.i_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 i_pblk = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_i_pblk(&has_bits);
          _impl_.i_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtConvertToInitializedFastpathFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 m_lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_m_lblk(), target);
  }

  // optional uint32 m_len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_m_len(), target);
  }

  // optional uint32 u_lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_u_lblk(), target);
  }

  // optional uint32 u_len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_u_len(), target);
  }

  // optional uint64 u_pblk = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_u_pblk(), target);
  }

  // optional uint32 i_lblk = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_i_lblk(), target);
  }

  // optional uint32 i_len = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_i_len(), target);
  }

  // optional uint64 i_pblk = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        10, this->_internal_i_pblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  return target;
}

::size_t Ext4ExtConvertToInitializedFastpathFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 m_lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_m_lblk());
    }

    // optional uint32 m_len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_m_len());
    }

    // optional uint32 u_lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_u_lblk());
    }

    // optional uint32 u_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_u_len());
    }

    // optional uint64 u_pblk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_u_pblk());
    }

    // optional uint32 i_lblk = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_i_lblk());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 i_len = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_i_len());
    }

    // optional uint64 i_pblk = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_i_pblk());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtConvertToInitializedFastpathFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtConvertToInitializedFastpathFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtConvertToInitializedFastpathFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtConvertToInitializedFastpathFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtConvertToInitializedFastpathFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtConvertToInitializedFastpathFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_lblk_ = from._impl_.m_lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_len_ = from._impl_.m_len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.u_lblk_ = from._impl_.u_lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.u_len_ = from._impl_.u_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.u_pblk_ = from._impl_.u_pblk_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.i_lblk_ = from._impl_.i_lblk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.i_len_ = from._impl_.i_len_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.i_pblk_ = from._impl_.i_pblk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::CopyFrom(const Ext4ExtConvertToInitializedFastpathFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtConvertToInitializedFastpathFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::InternalSwap(Ext4ExtConvertToInitializedFastpathFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.i_pblk_)
      + sizeof(Ext4ExtConvertToInitializedFastpathFtraceEvent::_impl_.i_pblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedFastpathFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtConvertToInitializedFastpathFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[32]);
}
// ===================================================================

class Ext4ExtHandleUnwrittenExtentsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtHandleUnwrittenExtentsFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_newblk(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
}
Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
}

inline void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { 0 }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.allocated_) { 0u }

    , decltype(_impl_.newblk_) { ::uint64_t{0u} }

  };
}

Ext4ExtHandleUnwrittenExtentsFtraceEvent::~Ext4ExtHandleUnwrittenExtentsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.newblk_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.newblk_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtHandleUnwrittenExtentsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 allocated = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_allocated(&has_bits);
          _impl_.allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 newblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_newblk(&has_bits);
          _impl_.newblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtHandleUnwrittenExtentsFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int32 flags = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_flags(), target);
  }

  // optional uint32 lblk = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_lblk(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_pblk(), target);
  }

  // optional uint32 len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_len(), target);
  }

  // optional uint32 allocated = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_allocated(), target);
  }

  // optional uint64 newblk = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_newblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  return target;
}

::size_t Ext4ExtHandleUnwrittenExtentsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int32 flags = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 lblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint32 len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 allocated = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_allocated());
    }

    // optional uint64 newblk = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_newblk());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtHandleUnwrittenExtentsFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtHandleUnwrittenExtentsFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtHandleUnwrittenExtentsFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtHandleUnwrittenExtentsFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtHandleUnwrittenExtentsFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtHandleUnwrittenExtentsFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.allocated_ = from._impl_.allocated_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.newblk_ = from._impl_.newblk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::CopyFrom(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtHandleUnwrittenExtentsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::InternalSwap(Ext4ExtHandleUnwrittenExtentsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.newblk_)
      + sizeof(Ext4ExtHandleUnwrittenExtentsFtraceEvent::_impl_.newblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtHandleUnwrittenExtentsFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtHandleUnwrittenExtentsFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[33]);
}
// ===================================================================

class Ext4ExtInCacheFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtInCacheFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtInCacheFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtInCacheFtraceEvent)
}
Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent(const Ext4ExtInCacheFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtInCacheFtraceEvent)
}

inline void Ext4ExtInCacheFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.ret_) { 0 }

  };
}

Ext4ExtInCacheFtraceEvent::~Ext4ExtInCacheFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtInCacheFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtInCacheFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtInCacheFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtInCacheFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtInCacheFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional int32 ret = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  return target;
}

::size_t Ext4ExtInCacheFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional int32 ret = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtInCacheFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtInCacheFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtInCacheFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtInCacheFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtInCacheFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtInCacheFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtInCacheFtraceEvent::CopyFrom(const Ext4ExtInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtInCacheFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtInCacheFtraceEvent::InternalSwap(Ext4ExtInCacheFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtInCacheFtraceEvent, _impl_.ret_)
      + sizeof(Ext4ExtInCacheFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtInCacheFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtInCacheFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[34]);
}
// ===================================================================

class Ext4ExtLoadExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtLoadExtentFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtLoadExtentFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
}
Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent(const Ext4ExtLoadExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
}

inline void Ext4ExtLoadExtentFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

  };
}

Ext4ExtLoadExtentFtraceEvent::~Ext4ExtLoadExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtLoadExtentFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtLoadExtentFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtLoadExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.lblk_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.lblk_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtLoadExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtLoadExtentFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 pblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_pblk(), target);
  }

  // optional uint32 lblk = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_lblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  return target;
}

::size_t Ext4ExtLoadExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 pblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint32 lblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtLoadExtentFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtLoadExtentFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtLoadExtentFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtLoadExtentFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtLoadExtentFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtLoadExtentFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtLoadExtentFtraceEvent::CopyFrom(const Ext4ExtLoadExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtLoadExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtLoadExtentFtraceEvent::InternalSwap(Ext4ExtLoadExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtLoadExtentFtraceEvent, _impl_.lblk_)
      + sizeof(Ext4ExtLoadExtentFtraceEvent::_impl_.lblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtLoadExtentFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtLoadExtentFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[35]);
}
// ===================================================================

class Ext4ExtMapBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtMapBlocksEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
}
Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent(const Ext4ExtMapBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
}

inline void Ext4ExtMapBlocksEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.flags_) { 0u }

  };
}

Ext4ExtMapBlocksEnterFtraceEvent::~Ext4ExtMapBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtMapBlocksEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtMapBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtMapBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtMapBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtMapBlocksEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  return target;
}

::size_t Ext4ExtMapBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtMapBlocksEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtMapBlocksEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtMapBlocksEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtMapBlocksEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtMapBlocksEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtMapBlocksEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtMapBlocksEnterFtraceEvent::CopyFrom(const Ext4ExtMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtMapBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtMapBlocksEnterFtraceEvent::InternalSwap(Ext4ExtMapBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksEnterFtraceEvent, _impl_.flags_)
      + sizeof(Ext4ExtMapBlocksEnterFtraceEvent::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtMapBlocksEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[36]);
}
// ===================================================================

class Ext4ExtMapBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtMapBlocksExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mflags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
}
Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent(const Ext4ExtMapBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
}

inline void Ext4ExtMapBlocksExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { 0u }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.mflags_) { 0u }

    , decltype(_impl_.ret_) { 0 }

  };
}

Ext4ExtMapBlocksExitFtraceEvent::~Ext4ExtMapBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtMapBlocksExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtMapBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtMapBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtMapBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mflags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_mflags(&has_bits);
          _impl_.mflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtMapBlocksExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_flags(), target);
  }

  // optional uint64 pblk = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_pblk(), target);
  }

  // optional uint32 lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_lblk(), target);
  }

  // optional uint32 len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_len(), target);
  }

  // optional uint32 mflags = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_mflags(), target);
  }

  // optional int32 ret = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  return target;
}

::size_t Ext4ExtMapBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 pblk = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 mflags = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mflags());
    }

    // optional int32 ret = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtMapBlocksExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtMapBlocksExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtMapBlocksExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtMapBlocksExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtMapBlocksExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtMapBlocksExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.mflags_ = from._impl_.mflags_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtMapBlocksExitFtraceEvent::CopyFrom(const Ext4ExtMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtMapBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtMapBlocksExitFtraceEvent::InternalSwap(Ext4ExtMapBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksExitFtraceEvent, _impl_.ret_)
      + sizeof(Ext4ExtMapBlocksExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtMapBlocksExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[37]);
}
// ===================================================================

class Ext4ExtPutInCacheFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtPutInCacheFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtPutInCacheFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
}
Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent(const Ext4ExtPutInCacheFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
}

inline void Ext4ExtPutInCacheFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.start_) { ::uint64_t{0u} }

  };
}

Ext4ExtPutInCacheFtraceEvent::~Ext4ExtPutInCacheFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtPutInCacheFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtPutInCacheFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtPutInCacheFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.start_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.start_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtPutInCacheFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 start = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtPutInCacheFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint64 start = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  return target;
}

::size_t Ext4ExtPutInCacheFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint64 start = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_start());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtPutInCacheFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtPutInCacheFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtPutInCacheFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtPutInCacheFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtPutInCacheFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtPutInCacheFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtPutInCacheFtraceEvent::CopyFrom(const Ext4ExtPutInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtPutInCacheFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtPutInCacheFtraceEvent::InternalSwap(Ext4ExtPutInCacheFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtPutInCacheFtraceEvent, _impl_.start_)
      + sizeof(Ext4ExtPutInCacheFtraceEvent::_impl_.start_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtPutInCacheFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtPutInCacheFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[38]);
}
// ===================================================================

class Ext4ExtRemoveSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRemoveSpaceFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
}
Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent(const Ext4ExtRemoveSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
}

inline void Ext4ExtRemoveSpaceFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.start_) { 0u }

    , decltype(_impl_.end_) { 0u }

    , decltype(_impl_.depth_) { 0 }

  };
}

Ext4ExtRemoveSpaceFtraceEvent::~Ext4ExtRemoveSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtRemoveSpaceFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtRemoveSpaceFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtRemoveSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.depth_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.depth_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtRemoveSpaceFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 depth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_depth(&has_bits);
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtRemoveSpaceFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_start(), target);
  }

  // optional uint32 end = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_end(), target);
  }

  // optional int32 depth = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_depth(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  return target;
}

::size_t Ext4ExtRemoveSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_start());
    }

    // optional uint32 end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_end());
    }

    // optional int32 depth = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_depth());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtRemoveSpaceFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtRemoveSpaceFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtRemoveSpaceFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtRemoveSpaceFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtRemoveSpaceFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtRemoveSpaceFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.depth_ = from._impl_.depth_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtRemoveSpaceFtraceEvent::CopyFrom(const Ext4ExtRemoveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRemoveSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRemoveSpaceFtraceEvent::InternalSwap(Ext4ExtRemoveSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceFtraceEvent, _impl_.depth_)
      + sizeof(Ext4ExtRemoveSpaceFtraceEvent::_impl_.depth_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtRemoveSpaceFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[39]);
}
// ===================================================================

class Ext4ExtRemoveSpaceDoneFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRemoveSpaceDoneFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_eh_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pc_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pc_pclu(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pc_state(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
}
Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent(const Ext4ExtRemoveSpaceDoneFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
}

inline void Ext4ExtRemoveSpaceDoneFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.start_) { 0u }

    , decltype(_impl_.end_) { 0u }

    , decltype(_impl_.partial_) { ::int64_t{0} }

    , decltype(_impl_.depth_) { 0 }

    , decltype(_impl_.eh_entries_) { 0u }

    , decltype(_impl_.pc_pclu_) { ::uint64_t{0u} }

    , decltype(_impl_.pc_lblk_) { 0u }

    , decltype(_impl_.pc_state_) { 0 }

  };
}

Ext4ExtRemoveSpaceDoneFtraceEvent::~Ext4ExtRemoveSpaceDoneFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtRemoveSpaceDoneFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pc_pclu_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.pc_pclu_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.pc_lblk_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pc_state_) -
        reinterpret_cast<char*>(&_impl_.pc_lblk_)) + sizeof(_impl_.pc_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtRemoveSpaceDoneFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 depth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_depth(&has_bits);
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 partial = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_partial(&has_bits);
          _impl_.partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 eh_entries = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_eh_entries(&has_bits);
          _impl_.eh_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pc_lblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_pc_lblk(&has_bits);
          _impl_.pc_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pc_pclu = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_pc_pclu(&has_bits);
          _impl_.pc_pclu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pc_state = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_pc_state(&has_bits);
          _impl_.pc_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtRemoveSpaceDoneFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_start(), target);
  }

  // optional uint32 end = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_end(), target);
  }

  // optional int32 depth = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_depth(), target);
  }

  // optional int64 partial = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_partial(), target);
  }

  // optional uint32 eh_entries = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_eh_entries(), target);
  }

  // optional uint32 pc_lblk = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_pc_lblk(), target);
  }

  // optional uint64 pc_pclu = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        9, this->_internal_pc_pclu(), target);
  }

  // optional int32 pc_state = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_pc_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  return target;
}

::size_t Ext4ExtRemoveSpaceDoneFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_start());
    }

    // optional uint32 end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_end());
    }

    // optional int64 partial = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_partial());
    }

    // optional int32 depth = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_depth());
    }

    // optional uint32 eh_entries = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_eh_entries());
    }

    // optional uint64 pc_pclu = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pc_pclu());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 pc_lblk = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pc_lblk());
    }

    // optional int32 pc_state = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pc_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtRemoveSpaceDoneFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtRemoveSpaceDoneFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtRemoveSpaceDoneFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtRemoveSpaceDoneFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtRemoveSpaceDoneFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtRemoveSpaceDoneFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.partial_ = from._impl_.partial_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.depth_ = from._impl_.depth_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.eh_entries_ = from._impl_.eh_entries_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.pc_pclu_ = from._impl_.pc_pclu_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.pc_lblk_ = from._impl_.pc_lblk_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pc_state_ = from._impl_.pc_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::CopyFrom(const Ext4ExtRemoveSpaceDoneFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRemoveSpaceDoneFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::InternalSwap(Ext4ExtRemoveSpaceDoneFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.pc_state_)
      + sizeof(Ext4ExtRemoveSpaceDoneFtraceEvent::_impl_.pc_state_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceDoneFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtRemoveSpaceDoneFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[40]);
}
// ===================================================================

class Ext4ExtRmIdxFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRmIdxFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtRmIdxFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
}
Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent(const Ext4ExtRmIdxFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
}

inline void Ext4ExtRmIdxFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

  };
}

Ext4ExtRmIdxFtraceEvent::~Ext4ExtRmIdxFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtRmIdxFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtRmIdxFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtRmIdxFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pblk_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.pblk_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtRmIdxFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtRmIdxFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 pblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_pblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  return target;
}

::size_t Ext4ExtRmIdxFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 pblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtRmIdxFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtRmIdxFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtRmIdxFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtRmIdxFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtRmIdxFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtRmIdxFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtRmIdxFtraceEvent::CopyFrom(const Ext4ExtRmIdxFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRmIdxFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRmIdxFtraceEvent::InternalSwap(Ext4ExtRmIdxFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtRmIdxFtraceEvent, _impl_.pblk_)
      + sizeof(Ext4ExtRmIdxFtraceEvent::_impl_.pblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtRmIdxFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtRmIdxFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[41]);
}
// ===================================================================

class Ext4ExtRmLeafFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRmLeafFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtRmLeafFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ee_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ee_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ee_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pc_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pc_pclu(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pc_state(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
}
Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent(const Ext4ExtRmLeafFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
}

inline void Ext4ExtRmLeafFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.partial_) { ::int64_t{0} }

    , decltype(_impl_.start_) { 0u }

    , decltype(_impl_.ee_lblk_) { 0u }

    , decltype(_impl_.ee_pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.ee_len_) { 0 }

    , decltype(_impl_.pc_lblk_) { 0u }

    , decltype(_impl_.pc_pclu_) { ::uint64_t{0u} }

    , decltype(_impl_.pc_state_) { 0 }

  };
}

Ext4ExtRmLeafFtraceEvent::~Ext4ExtRmLeafFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtRmLeafFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtRmLeafFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtRmLeafFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pc_lblk_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.pc_lblk_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.pc_pclu_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pc_state_) -
        reinterpret_cast<char*>(&_impl_.pc_pclu_)) + sizeof(_impl_.pc_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtRmLeafFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 partial = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_partial(&has_bits);
          _impl_.partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 ee_lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_ee_lblk(&has_bits);
          _impl_.ee_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ee_pblk = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_ee_pblk(&has_bits);
          _impl_.ee_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ee_len = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_ee_len(&has_bits);
          _impl_.ee_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pc_lblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_pc_lblk(&has_bits);
          _impl_.pc_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pc_pclu = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_pc_pclu(&has_bits);
          _impl_.pc_pclu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pc_state = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_pc_state(&has_bits);
          _impl_.pc_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtRmLeafFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 partial = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_partial(), target);
  }

  // optional uint32 start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_start(), target);
  }

  // optional uint32 ee_lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_ee_lblk(), target);
  }

  // optional uint64 ee_pblk = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_ee_pblk(), target);
  }

  // optional int32 ee_len = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_ee_len(), target);
  }

  // optional uint32 pc_lblk = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_pc_lblk(), target);
  }

  // optional uint64 pc_pclu = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        9, this->_internal_pc_pclu(), target);
  }

  // optional int32 pc_state = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_pc_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  return target;
}

::size_t Ext4ExtRmLeafFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 partial = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_partial());
    }

    // optional uint32 start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_start());
    }

    // optional uint32 ee_lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_ee_lblk());
    }

    // optional uint64 ee_pblk = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ee_pblk());
    }

    // optional int32 ee_len = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ee_len());
    }

    // optional uint32 pc_lblk = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pc_lblk());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint64 pc_pclu = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pc_pclu());
    }

    // optional int32 pc_state = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pc_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtRmLeafFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtRmLeafFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtRmLeafFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtRmLeafFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtRmLeafFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtRmLeafFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.partial_ = from._impl_.partial_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ee_lblk_ = from._impl_.ee_lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ee_pblk_ = from._impl_.ee_pblk_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ee_len_ = from._impl_.ee_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.pc_lblk_ = from._impl_.pc_lblk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.pc_pclu_ = from._impl_.pc_pclu_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pc_state_ = from._impl_.pc_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtRmLeafFtraceEvent::CopyFrom(const Ext4ExtRmLeafFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRmLeafFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRmLeafFtraceEvent::InternalSwap(Ext4ExtRmLeafFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtRmLeafFtraceEvent, _impl_.pc_state_)
      + sizeof(Ext4ExtRmLeafFtraceEvent::_impl_.pc_state_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtRmLeafFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtRmLeafFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[42]);
}
// ===================================================================

class Ext4ExtShowExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtShowExtentFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ExtShowExtentFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
}
Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent(const Ext4ExtShowExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
}

inline void Ext4ExtShowExtentFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

  };
}

Ext4ExtShowExtentFtraceEvent::~Ext4ExtShowExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtShowExtentFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtShowExtentFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ExtShowExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ExtShowExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ExtShowExtentFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 pblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_pblk(), target);
  }

  // optional uint32 lblk = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_lblk(), target);
  }

  // optional uint32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  return target;
}

::size_t Ext4ExtShowExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 pblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint32 lblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ExtShowExtentFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ExtShowExtentFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ExtShowExtentFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ExtShowExtentFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ExtShowExtentFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ExtShowExtentFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ExtShowExtentFtraceEvent::CopyFrom(const Ext4ExtShowExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtShowExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtShowExtentFtraceEvent::InternalSwap(Ext4ExtShowExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtShowExtentFtraceEvent, _impl_.len_)
      + sizeof(Ext4ExtShowExtentFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtShowExtentFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ExtShowExtentFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[43]);
}
// ===================================================================

class Ext4FallocateEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FallocateEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4FallocateEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FallocateEnterFtraceEvent)
}
Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent(const Ext4FallocateEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FallocateEnterFtraceEvent)
}

inline void Ext4FallocateEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.offset_) { ::int64_t{0} }

    , decltype(_impl_.len_) { ::int64_t{0} }

    , decltype(_impl_.pos_) { ::int64_t{0} }

    , decltype(_impl_.mode_) { 0 }

  };
}

Ext4FallocateEnterFtraceEvent::~Ext4FallocateEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FallocateEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FallocateEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4FallocateEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4FallocateEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pos = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4FallocateEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_len(), target);
  }

  // optional int32 mode = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_mode(), target);
  }

  // optional int64 pos = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_pos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  return target;
}

::size_t Ext4FallocateEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_len());
    }

    // optional int64 pos = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pos());
    }

    // optional int32 mode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4FallocateEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4FallocateEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4FallocateEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4FallocateEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4FallocateEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4FallocateEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4FallocateEnterFtraceEvent::CopyFrom(const Ext4FallocateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FallocateEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FallocateEnterFtraceEvent::InternalSwap(Ext4FallocateEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FallocateEnterFtraceEvent, _impl_.mode_)
      + sizeof(Ext4FallocateEnterFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4FallocateEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4FallocateEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[44]);
}
// ===================================================================

class Ext4FallocateExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FallocateExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4FallocateExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FallocateExitFtraceEvent)
}
Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent(const Ext4FallocateExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FallocateExitFtraceEvent)
}

inline void Ext4FallocateExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pos_) { ::int64_t{0} }

    , decltype(_impl_.blocks_) { 0u }

    , decltype(_impl_.ret_) { 0 }

  };
}

Ext4FallocateExitFtraceEvent::~Ext4FallocateExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FallocateExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FallocateExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FallocateExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4FallocateExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4FallocateExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4FallocateExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_pos(), target);
  }

  // optional uint32 blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_blocks(), target);
  }

  // optional int32 ret = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FallocateExitFtraceEvent)
  return target;
}

::size_t Ext4FallocateExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pos());
    }

    // optional uint32 blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_blocks());
    }

    // optional int32 ret = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4FallocateExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4FallocateExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4FallocateExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4FallocateExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4FallocateExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4FallocateExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4FallocateExitFtraceEvent::CopyFrom(const Ext4FallocateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FallocateExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FallocateExitFtraceEvent::InternalSwap(Ext4FallocateExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FallocateExitFtraceEvent, _impl_.ret_)
      + sizeof(Ext4FallocateExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4FallocateExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4FallocateExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[45]);
}
// ===================================================================

class Ext4FindDelallocRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FindDelallocRangeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4FindDelallocRangeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_to(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reverse(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_found_blk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
}
Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent(const Ext4FindDelallocRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
}

inline void Ext4FindDelallocRangeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.from_) { 0u }

    , decltype(_impl_.to_) { 0u }

    , decltype(_impl_.reverse_) { 0 }

    , decltype(_impl_.found_) { 0 }

    , decltype(_impl_.found_blk_) { 0u }

  };
}

Ext4FindDelallocRangeFtraceEvent::~Ext4FindDelallocRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FindDelallocRangeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FindDelallocRangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4FindDelallocRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.found_blk_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.found_blk_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4FindDelallocRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_from(&has_bits);
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 to = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_to(&has_bits);
          _impl_.to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 reverse = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_reverse(&has_bits);
          _impl_.reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 found = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_found(&has_bits);
          _impl_.found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 found_blk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_found_blk(&has_bits);
          _impl_.found_blk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4FindDelallocRangeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 from = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_from(), target);
  }

  // optional uint32 to = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_to(), target);
  }

  // optional int32 reverse = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_reverse(), target);
  }

  // optional int32 found = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_found(), target);
  }

  // optional uint32 found_blk = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_found_blk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  return target;
}

::size_t Ext4FindDelallocRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 from = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_from());
    }

    // optional uint32 to = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_to());
    }

    // optional int32 reverse = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_reverse());
    }

    // optional int32 found = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_found());
    }

    // optional uint32 found_blk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_found_blk());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4FindDelallocRangeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4FindDelallocRangeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4FindDelallocRangeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4FindDelallocRangeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4FindDelallocRangeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4FindDelallocRangeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.from_ = from._impl_.from_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.to_ = from._impl_.to_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.reverse_ = from._impl_.reverse_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.found_ = from._impl_.found_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.found_blk_ = from._impl_.found_blk_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4FindDelallocRangeFtraceEvent::CopyFrom(const Ext4FindDelallocRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FindDelallocRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FindDelallocRangeFtraceEvent::InternalSwap(Ext4FindDelallocRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FindDelallocRangeFtraceEvent, _impl_.found_blk_)
      + sizeof(Ext4FindDelallocRangeFtraceEvent::_impl_.found_blk_)
      - PROTOBUF_FIELD_OFFSET(Ext4FindDelallocRangeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4FindDelallocRangeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[46]);
}
// ===================================================================

class Ext4ForgetFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ForgetFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ForgetFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ForgetFtraceEvent)
}
Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent(const Ext4ForgetFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ForgetFtraceEvent)
}

inline void Ext4ForgetFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.block_) { ::uint64_t{0u} }

    , decltype(_impl_.is_metadata_) { 0 }

    , decltype(_impl_.mode_) { 0u }

  };
}

Ext4ForgetFtraceEvent::~Ext4ForgetFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ForgetFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ForgetFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ForgetFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ForgetFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ForgetFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ForgetFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          _impl_.block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 is_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_is_metadata(&has_bits);
          _impl_.is_metadata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ForgetFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ForgetFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_block(), target);
  }

  // optional int32 is_metadata = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_is_metadata(), target);
  }

  // optional uint32 mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ForgetFtraceEvent)
  return target;
}

::size_t Ext4ForgetFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ForgetFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_block());
    }

    // optional int32 is_metadata = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_is_metadata());
    }

    // optional uint32 mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ForgetFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ForgetFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ForgetFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ForgetFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ForgetFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ForgetFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ForgetFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.block_ = from._impl_.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_metadata_ = from._impl_.is_metadata_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ForgetFtraceEvent::CopyFrom(const Ext4ForgetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ForgetFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ForgetFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ForgetFtraceEvent::InternalSwap(Ext4ForgetFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ForgetFtraceEvent, _impl_.mode_)
      + sizeof(Ext4ForgetFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4ForgetFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ForgetFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[47]);
}
// ===================================================================

class Ext4FreeBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FreeBlocksFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4FreeBlocksFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FreeBlocksFtraceEvent)
}
Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent(const Ext4FreeBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FreeBlocksFtraceEvent)
}

inline void Ext4FreeBlocksFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.block_) { ::uint64_t{0u} }

    , decltype(_impl_.count_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { 0 }

    , decltype(_impl_.mode_) { 0u }

  };
}

Ext4FreeBlocksFtraceEvent::~Ext4FreeBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FreeBlocksFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FreeBlocksFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4FreeBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4FreeBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          _impl_.block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4FreeBlocksFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_block(), target);
  }

  // optional uint64 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_count(), target);
  }

  // optional int32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_flags(), target);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  return target;
}

::size_t Ext4FreeBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_block());
    }

    // optional uint64 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_count());
    }

    // optional int32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4FreeBlocksFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4FreeBlocksFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4FreeBlocksFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4FreeBlocksFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4FreeBlocksFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4FreeBlocksFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.block_ = from._impl_.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4FreeBlocksFtraceEvent::CopyFrom(const Ext4FreeBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FreeBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FreeBlocksFtraceEvent::InternalSwap(Ext4FreeBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FreeBlocksFtraceEvent, _impl_.mode_)
      + sizeof(Ext4FreeBlocksFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4FreeBlocksFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4FreeBlocksFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[48]);
}
// ===================================================================

class Ext4FreeInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FreeInodeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4FreeInodeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FreeInodeFtraceEvent)
}
Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent(const Ext4FreeInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FreeInodeFtraceEvent)
}

inline void Ext4FreeInodeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.uid_) { 0u }

    , decltype(_impl_.gid_) { 0u }

    , decltype(_impl_.blocks_) { ::uint64_t{0u} }

    , decltype(_impl_.mode_) { 0u }

  };
}

Ext4FreeInodeFtraceEvent::~Ext4FreeInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FreeInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FreeInodeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FreeInodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4FreeInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4FreeInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 uid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_uid(&has_bits);
          _impl_.uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 gid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_gid(&has_bits);
          _impl_.gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4FreeInodeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 uid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_uid(), target);
  }

  // optional uint32 gid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_gid(), target);
  }

  // optional uint64 blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_blocks(), target);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FreeInodeFtraceEvent)
  return target;
}

::size_t Ext4FreeInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 uid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_uid());
    }

    // optional uint32 gid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gid());
    }

    // optional uint64 blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_blocks());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4FreeInodeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4FreeInodeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4FreeInodeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4FreeInodeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4FreeInodeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4FreeInodeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.uid_ = from._impl_.uid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gid_ = from._impl_.gid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4FreeInodeFtraceEvent::CopyFrom(const Ext4FreeInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FreeInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FreeInodeFtraceEvent::InternalSwap(Ext4FreeInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FreeInodeFtraceEvent, _impl_.mode_)
      + sizeof(Ext4FreeInodeFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4FreeInodeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4FreeInodeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[49]);
}
// ===================================================================

class Ext4GetImpliedClusterAllocExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4GetImpliedClusterAllocExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
}
Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent(const Ext4GetImpliedClusterAllocExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
}

inline void Ext4GetImpliedClusterAllocExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { 0u }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.ret_) { 0 }

  };
}

Ext4GetImpliedClusterAllocExitFtraceEvent::~Ext4GetImpliedClusterAllocExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4GetImpliedClusterAllocExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4GetImpliedClusterAllocExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4GetImpliedClusterAllocExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_flags(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint64 pblk = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_pblk(), target);
  }

  // optional uint32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_len(), target);
  }

  // optional int32 ret = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  return target;
}

::size_t Ext4GetImpliedClusterAllocExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint64 pblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional int32 ret = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4GetImpliedClusterAllocExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4GetImpliedClusterAllocExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4GetImpliedClusterAllocExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4GetImpliedClusterAllocExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4GetImpliedClusterAllocExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4GetImpliedClusterAllocExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::CopyFrom(const Ext4GetImpliedClusterAllocExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4GetImpliedClusterAllocExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::InternalSwap(Ext4GetImpliedClusterAllocExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_.ret_)
      + sizeof(Ext4GetImpliedClusterAllocExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4GetImpliedClusterAllocExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4GetImpliedClusterAllocExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[50]);
}
// ===================================================================

class Ext4GetReservedClusterAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4GetReservedClusterAllocFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4GetReservedClusterAllocFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
}
Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent(const Ext4GetReservedClusterAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
}

inline void Ext4GetReservedClusterAllocFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

  };
}

Ext4GetReservedClusterAllocFtraceEvent::~Ext4GetReservedClusterAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4GetReservedClusterAllocFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4GetReservedClusterAllocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4GetReservedClusterAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4GetReservedClusterAllocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4GetReservedClusterAllocFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  return target;
}

::size_t Ext4GetReservedClusterAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4GetReservedClusterAllocFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4GetReservedClusterAllocFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4GetReservedClusterAllocFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4GetReservedClusterAllocFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4GetReservedClusterAllocFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4GetReservedClusterAllocFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4GetReservedClusterAllocFtraceEvent::CopyFrom(const Ext4GetReservedClusterAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4GetReservedClusterAllocFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4GetReservedClusterAllocFtraceEvent::InternalSwap(Ext4GetReservedClusterAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4GetReservedClusterAllocFtraceEvent, _impl_.len_)
      + sizeof(Ext4GetReservedClusterAllocFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(Ext4GetReservedClusterAllocFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4GetReservedClusterAllocFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[51]);
}
// ===================================================================

class Ext4IndMapBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4IndMapBlocksEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
}
Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent(const Ext4IndMapBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
}

inline void Ext4IndMapBlocksEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.flags_) { 0u }

  };
}

Ext4IndMapBlocksEnterFtraceEvent::~Ext4IndMapBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4IndMapBlocksEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4IndMapBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4IndMapBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4IndMapBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4IndMapBlocksEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  return target;
}

::size_t Ext4IndMapBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4IndMapBlocksEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4IndMapBlocksEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4IndMapBlocksEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4IndMapBlocksEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4IndMapBlocksEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4IndMapBlocksEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4IndMapBlocksEnterFtraceEvent::CopyFrom(const Ext4IndMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4IndMapBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4IndMapBlocksEnterFtraceEvent::InternalSwap(Ext4IndMapBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksEnterFtraceEvent, _impl_.flags_)
      + sizeof(Ext4IndMapBlocksEnterFtraceEvent::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4IndMapBlocksEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[52]);
}
// ===================================================================

class Ext4IndMapBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4IndMapBlocksExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mflags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
}
Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent(const Ext4IndMapBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
}

inline void Ext4IndMapBlocksExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { 0u }

    , decltype(_impl_.lblk_) { 0u }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.mflags_) { 0u }

    , decltype(_impl_.ret_) { 0 }

  };
}

Ext4IndMapBlocksExitFtraceEvent::~Ext4IndMapBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4IndMapBlocksExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4IndMapBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4IndMapBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4IndMapBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pblk(&has_bits);
          _impl_.pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_lblk(&has_bits);
          _impl_.lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mflags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_mflags(&has_bits);
          _impl_.mflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4IndMapBlocksExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_flags(), target);
  }

  // optional uint64 pblk = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_pblk(), target);
  }

  // optional uint32 lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_lblk(), target);
  }

  // optional uint32 len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_len(), target);
  }

  // optional uint32 mflags = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_mflags(), target);
  }

  // optional int32 ret = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  return target;
}

::size_t Ext4IndMapBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 pblk = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pblk());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lblk());
    }

    // optional uint32 len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 mflags = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mflags());
    }

    // optional int32 ret = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4IndMapBlocksExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4IndMapBlocksExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4IndMapBlocksExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4IndMapBlocksExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4IndMapBlocksExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4IndMapBlocksExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pblk_ = from._impl_.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.lblk_ = from._impl_.lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.mflags_ = from._impl_.mflags_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4IndMapBlocksExitFtraceEvent::CopyFrom(const Ext4IndMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4IndMapBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4IndMapBlocksExitFtraceEvent::InternalSwap(Ext4IndMapBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksExitFtraceEvent, _impl_.ret_)
      + sizeof(Ext4IndMapBlocksExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4IndMapBlocksExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[53]);
}
// ===================================================================

class Ext4InsertRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4InsertRangeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4InsertRangeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4InsertRangeFtraceEvent)
}
Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent(const Ext4InsertRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4InsertRangeFtraceEvent)
}

inline void Ext4InsertRangeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.offset_) { ::int64_t{0} }

    , decltype(_impl_.len_) { ::int64_t{0} }

  };
}

Ext4InsertRangeFtraceEvent::~Ext4InsertRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4InsertRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4InsertRangeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4InsertRangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4InsertRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4InsertRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4InsertRangeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4InsertRangeFtraceEvent)
  return target;
}

::size_t Ext4InsertRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4InsertRangeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4InsertRangeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4InsertRangeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4InsertRangeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4InsertRangeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4InsertRangeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4InsertRangeFtraceEvent::CopyFrom(const Ext4InsertRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4InsertRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4InsertRangeFtraceEvent::InternalSwap(Ext4InsertRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4InsertRangeFtraceEvent, _impl_.len_)
      + sizeof(Ext4InsertRangeFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(Ext4InsertRangeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4InsertRangeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[54]);
}
// ===================================================================

class Ext4InvalidatepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4InvalidatepageFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4InvalidatepageFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4InvalidatepageFtraceEvent)
}
Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent(const Ext4InvalidatepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4InvalidatepageFtraceEvent)
}

inline void Ext4InvalidatepageFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.index_) { ::uint64_t{0u} }

    , decltype(_impl_.offset_) { ::uint64_t{0u} }

    , decltype(_impl_.length_) { 0u }

  };
}

Ext4InvalidatepageFtraceEvent::~Ext4InvalidatepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4InvalidatepageFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4InvalidatepageFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4InvalidatepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.length_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4InvalidatepageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4InvalidatepageFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_index(), target);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_offset(), target);
  }

  // optional uint32 length = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  return target;
}

::size_t Ext4InvalidatepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_index());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_offset());
    }

    // optional uint32 length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4InvalidatepageFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4InvalidatepageFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4InvalidatepageFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4InvalidatepageFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4InvalidatepageFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4InvalidatepageFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4InvalidatepageFtraceEvent::CopyFrom(const Ext4InvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4InvalidatepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4InvalidatepageFtraceEvent::InternalSwap(Ext4InvalidatepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4InvalidatepageFtraceEvent, _impl_.length_)
      + sizeof(Ext4InvalidatepageFtraceEvent::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(Ext4InvalidatepageFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4InvalidatepageFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[55]);
}
// ===================================================================

class Ext4JournalStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalStartFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4JournalStartFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rsv_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nblocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_revoke_creds(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4JournalStartFtraceEvent)
}
Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent(const Ext4JournalStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalStartFtraceEvent)
}

inline void Ext4JournalStartFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ip_) { ::uint64_t{0u} }

    , decltype(_impl_.blocks_) { 0 }

    , decltype(_impl_.rsv_blocks_) { 0 }

    , decltype(_impl_.nblocks_) { 0 }

    , decltype(_impl_.revoke_creds_) { 0 }

  };
}

Ext4JournalStartFtraceEvent::~Ext4JournalStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4JournalStartFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4JournalStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4JournalStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.revoke_creds_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.revoke_creds_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4JournalStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 rsv_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_rsv_blocks(&has_bits);
          _impl_.rsv_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 nblocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_nblocks(&has_bits);
          _impl_.nblocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 revoke_creds = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_revoke_creds(&has_bits);
          _impl_.revoke_creds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4JournalStartFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ip = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ip(), target);
  }

  // optional int32 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_blocks(), target);
  }

  // optional int32 rsv_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_rsv_blocks(), target);
  }

  // optional int32 nblocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_nblocks(), target);
  }

  // optional int32 revoke_creds = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_revoke_creds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4JournalStartFtraceEvent)
  return target;
}

::size_t Ext4JournalStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ip());
    }

    // optional int32 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_blocks());
    }

    // optional int32 rsv_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_rsv_blocks());
    }

    // optional int32 nblocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_nblocks());
    }

    // optional int32 revoke_creds = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_revoke_creds());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4JournalStartFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4JournalStartFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4JournalStartFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4JournalStartFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4JournalStartFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4JournalStartFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ip_ = from._impl_.ip_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rsv_blocks_ = from._impl_.rsv_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.nblocks_ = from._impl_.nblocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.revoke_creds_ = from._impl_.revoke_creds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4JournalStartFtraceEvent::CopyFrom(const Ext4JournalStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalStartFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalStartFtraceEvent::InternalSwap(Ext4JournalStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4JournalStartFtraceEvent, _impl_.revoke_creds_)
      + sizeof(Ext4JournalStartFtraceEvent::_impl_.revoke_creds_)
      - PROTOBUF_FIELD_OFFSET(Ext4JournalStartFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4JournalStartFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[56]);
}
// ===================================================================

class Ext4JournalStartReservedFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalStartReservedFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4JournalStartReservedFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
}
Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent(const Ext4JournalStartReservedFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
}

inline void Ext4JournalStartReservedFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ip_) { ::uint64_t{0u} }

    , decltype(_impl_.blocks_) { 0 }

  };
}

Ext4JournalStartReservedFtraceEvent::~Ext4JournalStartReservedFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4JournalStartReservedFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4JournalStartReservedFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4JournalStartReservedFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.blocks_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blocks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4JournalStartReservedFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4JournalStartReservedFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ip = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ip(), target);
  }

  // optional int32 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  return target;
}

::size_t Ext4JournalStartReservedFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ip());
    }

    // optional int32 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_blocks());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4JournalStartReservedFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4JournalStartReservedFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4JournalStartReservedFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4JournalStartReservedFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4JournalStartReservedFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4JournalStartReservedFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ip_ = from._impl_.ip_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4JournalStartReservedFtraceEvent::CopyFrom(const Ext4JournalStartReservedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalStartReservedFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalStartReservedFtraceEvent::InternalSwap(Ext4JournalStartReservedFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4JournalStartReservedFtraceEvent, _impl_.blocks_)
      + sizeof(Ext4JournalStartReservedFtraceEvent::_impl_.blocks_)
      - PROTOBUF_FIELD_OFFSET(Ext4JournalStartReservedFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4JournalStartReservedFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[57]);
}
// ===================================================================

class Ext4JournalledInvalidatepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalledInvalidatepageFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4JournalledInvalidatepageFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
}
Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent(const Ext4JournalledInvalidatepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
}

inline void Ext4JournalledInvalidatepageFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.index_) { ::uint64_t{0u} }

    , decltype(_impl_.offset_) { ::uint64_t{0u} }

    , decltype(_impl_.length_) { 0u }

  };
}

Ext4JournalledInvalidatepageFtraceEvent::~Ext4JournalledInvalidatepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4JournalledInvalidatepageFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4JournalledInvalidatepageFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4JournalledInvalidatepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.length_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4JournalledInvalidatepageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4JournalledInvalidatepageFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_index(), target);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_offset(), target);
  }

  // optional uint32 length = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  return target;
}

::size_t Ext4JournalledInvalidatepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_index());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_offset());
    }

    // optional uint32 length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4JournalledInvalidatepageFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4JournalledInvalidatepageFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4JournalledInvalidatepageFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4JournalledInvalidatepageFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4JournalledInvalidatepageFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4JournalledInvalidatepageFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4JournalledInvalidatepageFtraceEvent::CopyFrom(const Ext4JournalledInvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalledInvalidatepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalledInvalidatepageFtraceEvent::InternalSwap(Ext4JournalledInvalidatepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4JournalledInvalidatepageFtraceEvent, _impl_.length_)
      + sizeof(Ext4JournalledInvalidatepageFtraceEvent::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(Ext4JournalledInvalidatepageFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4JournalledInvalidatepageFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[58]);
}
// ===================================================================

class Ext4JournalledWriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalledWriteEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4JournalledWriteEndFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
}
Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent(const Ext4JournalledWriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
}

inline void Ext4JournalledWriteEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pos_) { ::int64_t{0} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.copied_) { 0u }

  };
}

Ext4JournalledWriteEndFtraceEvent::~Ext4JournalledWriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4JournalledWriteEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4JournalledWriteEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4JournalledWriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.copied_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.copied_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4JournalledWriteEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          _impl_.copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4JournalledWriteEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_copied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  return target;
}

::size_t Ext4JournalledWriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_copied());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4JournalledWriteEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4JournalledWriteEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4JournalledWriteEndFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4JournalledWriteEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4JournalledWriteEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4JournalledWriteEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.copied_ = from._impl_.copied_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4JournalledWriteEndFtraceEvent::CopyFrom(const Ext4JournalledWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalledWriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalledWriteEndFtraceEvent::InternalSwap(Ext4JournalledWriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4JournalledWriteEndFtraceEvent, _impl_.copied_)
      + sizeof(Ext4JournalledWriteEndFtraceEvent::_impl_.copied_)
      - PROTOBUF_FIELD_OFFSET(Ext4JournalledWriteEndFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4JournalledWriteEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[59]);
}
// ===================================================================

class Ext4LoadInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4LoadInodeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4LoadInodeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4LoadInodeFtraceEvent)
}
Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent(const Ext4LoadInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4LoadInodeFtraceEvent)
}

inline void Ext4LoadInodeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

  };
}

Ext4LoadInodeFtraceEvent::~Ext4LoadInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4LoadInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4LoadInodeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4LoadInodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4LoadInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ino_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ino_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4LoadInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4LoadInodeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4LoadInodeFtraceEvent)
  return target;
}

::size_t Ext4LoadInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4LoadInodeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4LoadInodeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4LoadInodeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4LoadInodeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4LoadInodeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4LoadInodeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4LoadInodeFtraceEvent::CopyFrom(const Ext4LoadInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4LoadInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4LoadInodeFtraceEvent::InternalSwap(Ext4LoadInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4LoadInodeFtraceEvent, _impl_.ino_)
      + sizeof(Ext4LoadInodeFtraceEvent::_impl_.ino_)
      - PROTOBUF_FIELD_OFFSET(Ext4LoadInodeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4LoadInodeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[60]);
}
// ===================================================================

class Ext4LoadInodeBitmapFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4LoadInodeBitmapFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4LoadInodeBitmapFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
}
Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent(const Ext4LoadInodeBitmapFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
}

inline void Ext4LoadInodeBitmapFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.group_) { 0u }

  };
}

Ext4LoadInodeBitmapFtraceEvent::~Ext4LoadInodeBitmapFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4LoadInodeBitmapFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4LoadInodeBitmapFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4LoadInodeBitmapFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.group_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.group_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4LoadInodeBitmapFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          _impl_.group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4LoadInodeBitmapFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_group(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  return target;
}

::size_t Ext4LoadInodeBitmapFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_group());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4LoadInodeBitmapFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4LoadInodeBitmapFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4LoadInodeBitmapFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4LoadInodeBitmapFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4LoadInodeBitmapFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4LoadInodeBitmapFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_ = from._impl_.group_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4LoadInodeBitmapFtraceEvent::CopyFrom(const Ext4LoadInodeBitmapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4LoadInodeBitmapFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4LoadInodeBitmapFtraceEvent::InternalSwap(Ext4LoadInodeBitmapFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4LoadInodeBitmapFtraceEvent, _impl_.group_)
      + sizeof(Ext4LoadInodeBitmapFtraceEvent::_impl_.group_)
      - PROTOBUF_FIELD_OFFSET(Ext4LoadInodeBitmapFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4LoadInodeBitmapFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[61]);
}
// ===================================================================

class Ext4MarkInodeDirtyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MarkInodeDirtyFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MarkInodeDirtyFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
}
Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent(const Ext4MarkInodeDirtyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
}

inline void Ext4MarkInodeDirtyFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.ip_) { ::uint64_t{0u} }

  };
}

Ext4MarkInodeDirtyFtraceEvent::~Ext4MarkInodeDirtyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MarkInodeDirtyFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MarkInodeDirtyFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MarkInodeDirtyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ip_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ip_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MarkInodeDirtyFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MarkInodeDirtyFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 ip = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  return target;
}

::size_t Ext4MarkInodeDirtyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 ip = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ip());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MarkInodeDirtyFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MarkInodeDirtyFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MarkInodeDirtyFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MarkInodeDirtyFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MarkInodeDirtyFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MarkInodeDirtyFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ip_ = from._impl_.ip_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MarkInodeDirtyFtraceEvent::CopyFrom(const Ext4MarkInodeDirtyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MarkInodeDirtyFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MarkInodeDirtyFtraceEvent::InternalSwap(Ext4MarkInodeDirtyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MarkInodeDirtyFtraceEvent, _impl_.ip_)
      + sizeof(Ext4MarkInodeDirtyFtraceEvent::_impl_.ip_)
      - PROTOBUF_FIELD_OFFSET(Ext4MarkInodeDirtyFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MarkInodeDirtyFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[62]);
}
// ===================================================================

class Ext4MbBitmapLoadFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbBitmapLoadFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MbBitmapLoadFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
}
Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent(const Ext4MbBitmapLoadFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
}

inline void Ext4MbBitmapLoadFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.group_) { 0u }

  };
}

Ext4MbBitmapLoadFtraceEvent::~Ext4MbBitmapLoadFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbBitmapLoadFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbBitmapLoadFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MbBitmapLoadFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.group_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.group_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MbBitmapLoadFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          _impl_.group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MbBitmapLoadFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_group(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  return target;
}

::size_t Ext4MbBitmapLoadFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_group());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MbBitmapLoadFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MbBitmapLoadFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MbBitmapLoadFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MbBitmapLoadFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MbBitmapLoadFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MbBitmapLoadFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_ = from._impl_.group_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MbBitmapLoadFtraceEvent::CopyFrom(const Ext4MbBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbBitmapLoadFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbBitmapLoadFtraceEvent::InternalSwap(Ext4MbBitmapLoadFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbBitmapLoadFtraceEvent, _impl_.group_)
      + sizeof(Ext4MbBitmapLoadFtraceEvent::_impl_.group_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbBitmapLoadFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MbBitmapLoadFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[63]);
}
// ===================================================================

class Ext4MbBuddyBitmapLoadFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbBuddyBitmapLoadFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MbBuddyBitmapLoadFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
}
Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent(const Ext4MbBuddyBitmapLoadFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
}

inline void Ext4MbBuddyBitmapLoadFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.group_) { 0u }

  };
}

Ext4MbBuddyBitmapLoadFtraceEvent::~Ext4MbBuddyBitmapLoadFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbBuddyBitmapLoadFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbBuddyBitmapLoadFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MbBuddyBitmapLoadFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.group_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.group_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MbBuddyBitmapLoadFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          _impl_.group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MbBuddyBitmapLoadFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_group(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  return target;
}

::size_t Ext4MbBuddyBitmapLoadFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_group());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MbBuddyBitmapLoadFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MbBuddyBitmapLoadFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MbBuddyBitmapLoadFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MbBuddyBitmapLoadFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MbBuddyBitmapLoadFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MbBuddyBitmapLoadFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_ = from._impl_.group_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MbBuddyBitmapLoadFtraceEvent::CopyFrom(const Ext4MbBuddyBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbBuddyBitmapLoadFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbBuddyBitmapLoadFtraceEvent::InternalSwap(Ext4MbBuddyBitmapLoadFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbBuddyBitmapLoadFtraceEvent, _impl_.group_)
      + sizeof(Ext4MbBuddyBitmapLoadFtraceEvent::_impl_.group_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbBuddyBitmapLoadFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MbBuddyBitmapLoadFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[64]);
}
// ===================================================================

class Ext4MbDiscardPreallocationsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbDiscardPreallocationsFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MbDiscardPreallocationsFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
}
Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent(const Ext4MbDiscardPreallocationsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
}

inline void Ext4MbDiscardPreallocationsFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.needed_) { 0 }

  };
}

Ext4MbDiscardPreallocationsFtraceEvent::~Ext4MbDiscardPreallocationsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbDiscardPreallocationsFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbDiscardPreallocationsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MbDiscardPreallocationsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.needed_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.needed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MbDiscardPreallocationsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 needed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_needed(&has_bits);
          _impl_.needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MbDiscardPreallocationsFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional int32 needed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_needed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  return target;
}

::size_t Ext4MbDiscardPreallocationsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional int32 needed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_needed());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MbDiscardPreallocationsFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MbDiscardPreallocationsFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MbDiscardPreallocationsFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MbDiscardPreallocationsFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MbDiscardPreallocationsFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MbDiscardPreallocationsFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.needed_ = from._impl_.needed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MbDiscardPreallocationsFtraceEvent::CopyFrom(const Ext4MbDiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbDiscardPreallocationsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbDiscardPreallocationsFtraceEvent::InternalSwap(Ext4MbDiscardPreallocationsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbDiscardPreallocationsFtraceEvent, _impl_.needed_)
      + sizeof(Ext4MbDiscardPreallocationsFtraceEvent::_impl_.needed_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbDiscardPreallocationsFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MbDiscardPreallocationsFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[65]);
}
// ===================================================================

class Ext4MbNewGroupPaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbNewGroupPaFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MbNewGroupPaFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa_pstart(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pa_lstart(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pa_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
}
Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent(const Ext4MbNewGroupPaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
}

inline void Ext4MbNewGroupPaFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pa_pstart_) { ::uint64_t{0u} }

    , decltype(_impl_.pa_lstart_) { ::uint64_t{0u} }

    , decltype(_impl_.pa_len_) { 0u }

  };
}

Ext4MbNewGroupPaFtraceEvent::~Ext4MbNewGroupPaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbNewGroupPaFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbNewGroupPaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MbNewGroupPaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pa_len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.pa_len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MbNewGroupPaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pa_pstart = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pa_pstart(&has_bits);
          _impl_.pa_pstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pa_lstart = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pa_lstart(&has_bits);
          _impl_.pa_lstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pa_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_pa_len(&has_bits);
          _impl_.pa_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MbNewGroupPaFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 pa_pstart = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_pa_pstart(), target);
  }

  // optional uint64 pa_lstart = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_pa_lstart(), target);
  }

  // optional uint32 pa_len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_pa_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  return target;
}

::size_t Ext4MbNewGroupPaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 pa_pstart = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pa_pstart());
    }

    // optional uint64 pa_lstart = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pa_lstart());
    }

    // optional uint32 pa_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pa_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MbNewGroupPaFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MbNewGroupPaFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MbNewGroupPaFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MbNewGroupPaFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MbNewGroupPaFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MbNewGroupPaFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pa_pstart_ = from._impl_.pa_pstart_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pa_lstart_ = from._impl_.pa_lstart_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pa_len_ = from._impl_.pa_len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MbNewGroupPaFtraceEvent::CopyFrom(const Ext4MbNewGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbNewGroupPaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbNewGroupPaFtraceEvent::InternalSwap(Ext4MbNewGroupPaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbNewGroupPaFtraceEvent, _impl_.pa_len_)
      + sizeof(Ext4MbNewGroupPaFtraceEvent::_impl_.pa_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbNewGroupPaFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MbNewGroupPaFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[66]);
}
// ===================================================================

class Ext4MbNewInodePaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbNewInodePaFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MbNewInodePaFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa_pstart(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pa_lstart(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pa_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
}
Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent(const Ext4MbNewInodePaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
}

inline void Ext4MbNewInodePaFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pa_pstart_) { ::uint64_t{0u} }

    , decltype(_impl_.pa_lstart_) { ::uint64_t{0u} }

    , decltype(_impl_.pa_len_) { 0u }

  };
}

Ext4MbNewInodePaFtraceEvent::~Ext4MbNewInodePaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbNewInodePaFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbNewInodePaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MbNewInodePaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pa_len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.pa_len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MbNewInodePaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pa_pstart = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pa_pstart(&has_bits);
          _impl_.pa_pstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pa_lstart = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pa_lstart(&has_bits);
          _impl_.pa_lstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pa_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_pa_len(&has_bits);
          _impl_.pa_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MbNewInodePaFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 pa_pstart = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_pa_pstart(), target);
  }

  // optional uint64 pa_lstart = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_pa_lstart(), target);
  }

  // optional uint32 pa_len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_pa_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  return target;
}

::size_t Ext4MbNewInodePaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 pa_pstart = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pa_pstart());
    }

    // optional uint64 pa_lstart = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pa_lstart());
    }

    // optional uint32 pa_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pa_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MbNewInodePaFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MbNewInodePaFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MbNewInodePaFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MbNewInodePaFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MbNewInodePaFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MbNewInodePaFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pa_pstart_ = from._impl_.pa_pstart_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pa_lstart_ = from._impl_.pa_lstart_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pa_len_ = from._impl_.pa_len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MbNewInodePaFtraceEvent::CopyFrom(const Ext4MbNewInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbNewInodePaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbNewInodePaFtraceEvent::InternalSwap(Ext4MbNewInodePaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbNewInodePaFtraceEvent, _impl_.pa_len_)
      + sizeof(Ext4MbNewInodePaFtraceEvent::_impl_.pa_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbNewInodePaFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MbNewInodePaFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[67]);
}
// ===================================================================

class Ext4MbReleaseGroupPaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbReleaseGroupPaFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MbReleaseGroupPaFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pa_pstart(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa_len(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
}
Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent(const Ext4MbReleaseGroupPaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
}

inline void Ext4MbReleaseGroupPaFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.pa_pstart_) { ::uint64_t{0u} }

    , decltype(_impl_.pa_len_) { 0u }

  };
}

Ext4MbReleaseGroupPaFtraceEvent::~Ext4MbReleaseGroupPaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbReleaseGroupPaFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbReleaseGroupPaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MbReleaseGroupPaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pa_len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.pa_len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MbReleaseGroupPaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pa_pstart = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_pa_pstart(&has_bits);
          _impl_.pa_pstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pa_len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pa_len(&has_bits);
          _impl_.pa_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MbReleaseGroupPaFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 pa_pstart = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_pa_pstart(), target);
  }

  // optional uint32 pa_len = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_pa_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  return target;
}

::size_t Ext4MbReleaseGroupPaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 pa_pstart = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pa_pstart());
    }

    // optional uint32 pa_len = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pa_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MbReleaseGroupPaFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MbReleaseGroupPaFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MbReleaseGroupPaFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MbReleaseGroupPaFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MbReleaseGroupPaFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MbReleaseGroupPaFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pa_pstart_ = from._impl_.pa_pstart_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pa_len_ = from._impl_.pa_len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MbReleaseGroupPaFtraceEvent::CopyFrom(const Ext4MbReleaseGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbReleaseGroupPaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbReleaseGroupPaFtraceEvent::InternalSwap(Ext4MbReleaseGroupPaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbReleaseGroupPaFtraceEvent, _impl_.pa_len_)
      + sizeof(Ext4MbReleaseGroupPaFtraceEvent::_impl_.pa_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbReleaseGroupPaFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MbReleaseGroupPaFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[68]);
}
// ===================================================================

class Ext4MbReleaseInodePaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbReleaseInodePaFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MbReleaseInodePaFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
}
Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent(const Ext4MbReleaseInodePaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
}

inline void Ext4MbReleaseInodePaFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.block_) { ::uint64_t{0u} }

    , decltype(_impl_.count_) { 0u }

  };
}

Ext4MbReleaseInodePaFtraceEvent::~Ext4MbReleaseInodePaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbReleaseInodePaFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbReleaseInodePaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MbReleaseInodePaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MbReleaseInodePaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          _impl_.block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MbReleaseInodePaFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_block(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  return target;
}

::size_t Ext4MbReleaseInodePaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_block());
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MbReleaseInodePaFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MbReleaseInodePaFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MbReleaseInodePaFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MbReleaseInodePaFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MbReleaseInodePaFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MbReleaseInodePaFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.block_ = from._impl_.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MbReleaseInodePaFtraceEvent::CopyFrom(const Ext4MbReleaseInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbReleaseInodePaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbReleaseInodePaFtraceEvent::InternalSwap(Ext4MbReleaseInodePaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbReleaseInodePaFtraceEvent, _impl_.count_)
      + sizeof(Ext4MbReleaseInodePaFtraceEvent::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbReleaseInodePaFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MbReleaseInodePaFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[69]);
}
// ===================================================================

class Ext4MballocAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocAllocFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MballocAllocFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_orig_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_orig_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_orig_group(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_orig_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_goal_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_goal_start(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_goal_group(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_goal_len(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_result_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_groups(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_buddy(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_tail(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_cr(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
};

Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MballocAllocFtraceEvent)
}
Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent(const Ext4MballocAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocAllocFtraceEvent)
}

inline void Ext4MballocAllocFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.orig_logical_) { 0u }

    , decltype(_impl_.orig_start_) { 0 }

    , decltype(_impl_.orig_group_) { 0u }

    , decltype(_impl_.orig_len_) { 0 }

    , decltype(_impl_.goal_logical_) { 0u }

    , decltype(_impl_.goal_start_) { 0 }

    , decltype(_impl_.goal_group_) { 0u }

    , decltype(_impl_.goal_len_) { 0 }

    , decltype(_impl_.result_logical_) { 0u }

    , decltype(_impl_.result_start_) { 0 }

    , decltype(_impl_.result_group_) { 0u }

    , decltype(_impl_.result_len_) { 0 }

    , decltype(_impl_.found_) { 0u }

    , decltype(_impl_.groups_) { 0u }

    , decltype(_impl_.buddy_) { 0u }

    , decltype(_impl_.flags_) { 0u }

    , decltype(_impl_.tail_) { 0u }

    , decltype(_impl_.cr_) { 0u }

  };
}

Ext4MballocAllocFtraceEvent::~Ext4MballocAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocAllocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MballocAllocFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MballocAllocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MballocAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.goal_start_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.goal_start_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.goal_group_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.groups_) -
        reinterpret_cast<char*>(&_impl_.goal_group_)) + sizeof(_impl_.groups_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&_impl_.buddy_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.cr_) -
        reinterpret_cast<char*>(&_impl_.buddy_)) + sizeof(_impl_.cr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MballocAllocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 orig_logical = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_orig_logical(&has_bits);
          _impl_.orig_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 orig_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_orig_start(&has_bits);
          _impl_.orig_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 orig_group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_orig_group(&has_bits);
          _impl_.orig_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 orig_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_orig_len(&has_bits);
          _impl_.orig_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 goal_logical = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_goal_logical(&has_bits);
          _impl_.goal_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 goal_start = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_goal_start(&has_bits);
          _impl_.goal_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 goal_group = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_goal_group(&has_bits);
          _impl_.goal_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 goal_len = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_goal_len(&has_bits);
          _impl_.goal_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 result_logical = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_result_logical(&has_bits);
          _impl_.result_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 result_start = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _Internal::set_has_result_start(&has_bits);
          _impl_.result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 result_group = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _Internal::set_has_result_group(&has_bits);
          _impl_.result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 result_len = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _Internal::set_has_result_len(&has_bits);
          _impl_.result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 found = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _Internal::set_has_found(&has_bits);
          _impl_.found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 groups = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 128)) {
          _Internal::set_has_groups(&has_bits);
          _impl_.groups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 buddy = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          _Internal::set_has_buddy(&has_bits);
          _impl_.buddy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 tail = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          _Internal::set_has_tail(&has_bits);
          _impl_.tail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 cr = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          _Internal::set_has_cr(&has_bits);
          _impl_.cr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MballocAllocFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 orig_logical = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_orig_logical(), target);
  }

  // optional int32 orig_start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_orig_start(), target);
  }

  // optional uint32 orig_group = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_orig_group(), target);
  }

  // optional int32 orig_len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_orig_len(), target);
  }

  // optional uint32 goal_logical = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_goal_logical(), target);
  }

  // optional int32 goal_start = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_goal_start(), target);
  }

  // optional uint32 goal_group = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_goal_group(), target);
  }

  // optional int32 goal_len = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_goal_len(), target);
  }

  // optional uint32 result_logical = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this->_internal_result_logical(), target);
  }

  // optional int32 result_start = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_result_start(), target);
  }

  // optional uint32 result_group = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        13, this->_internal_result_group(), target);
  }

  // optional int32 result_len = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_result_len(), target);
  }

  // optional uint32 found = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        15, this->_internal_found(), target);
  }

  // optional uint32 groups = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        16, this->_internal_groups(), target);
  }

  // optional uint32 buddy = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        17, this->_internal_buddy(), target);
  }

  // optional uint32 flags = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        18, this->_internal_flags(), target);
  }

  // optional uint32 tail = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        19, this->_internal_tail(), target);
  }

  // optional uint32 cr = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        20, this->_internal_cr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MballocAllocFtraceEvent)
  return target;
}

::size_t Ext4MballocAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 orig_logical = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_orig_logical());
    }

    // optional int32 orig_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_orig_start());
    }

    // optional uint32 orig_group = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_orig_group());
    }

    // optional int32 orig_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_orig_len());
    }

    // optional uint32 goal_logical = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_goal_logical());
    }

    // optional int32 goal_start = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_goal_start());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 goal_group = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_goal_group());
    }

    // optional int32 goal_len = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_goal_len());
    }

    // optional uint32 result_logical = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_result_logical());
    }

    // optional int32 result_start = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_result_start());
    }

    // optional uint32 result_group = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_result_group());
    }

    // optional int32 result_len = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_result_len());
    }

    // optional uint32 found = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_found());
    }

    // optional uint32 groups = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_groups());
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional uint32 buddy = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_buddy());
    }

    // optional uint32 flags = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_flags());
    }

    // optional uint32 tail = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_tail());
    }

    // optional uint32 cr = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_cr());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MballocAllocFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MballocAllocFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MballocAllocFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MballocAllocFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MballocAllocFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MballocAllocFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.orig_logical_ = from._impl_.orig_logical_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.orig_start_ = from._impl_.orig_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.orig_group_ = from._impl_.orig_group_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.orig_len_ = from._impl_.orig_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.goal_logical_ = from._impl_.goal_logical_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.goal_start_ = from._impl_.goal_start_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.goal_group_ = from._impl_.goal_group_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.goal_len_ = from._impl_.goal_len_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.result_logical_ = from._impl_.result_logical_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.result_start_ = from._impl_.result_start_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.result_group_ = from._impl_.result_group_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.result_len_ = from._impl_.result_len_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.found_ = from._impl_.found_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.groups_ = from._impl_.groups_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.buddy_ = from._impl_.buddy_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.tail_ = from._impl_.tail_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.cr_ = from._impl_.cr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MballocAllocFtraceEvent::CopyFrom(const Ext4MballocAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocAllocFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocAllocFtraceEvent::InternalSwap(Ext4MballocAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MballocAllocFtraceEvent, _impl_.cr_)
      + sizeof(Ext4MballocAllocFtraceEvent::_impl_.cr_)
      - PROTOBUF_FIELD_OFFSET(Ext4MballocAllocFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MballocAllocFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[70]);
}
// ===================================================================

class Ext4MballocDiscardFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocDiscardFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MballocDiscardFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MballocDiscardFtraceEvent)
}
Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent(const Ext4MballocDiscardFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocDiscardFtraceEvent)
}

inline void Ext4MballocDiscardFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.result_start_) { 0 }

    , decltype(_impl_.result_group_) { 0u }

    , decltype(_impl_.result_len_) { 0 }

  };
}

Ext4MballocDiscardFtraceEvent::~Ext4MballocDiscardFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MballocDiscardFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MballocDiscardFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MballocDiscardFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.result_len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.result_len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MballocDiscardFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 result_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_result_start(&has_bits);
          _impl_.result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 result_group = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_result_group(&has_bits);
          _impl_.result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 result_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_result_len(&has_bits);
          _impl_.result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MballocDiscardFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int32 result_start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_result_start(), target);
  }

  // optional uint32 result_group = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_result_group(), target);
  }

  // optional int32 result_len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_result_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  return target;
}

::size_t Ext4MballocDiscardFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int32 result_start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_result_start());
    }

    // optional uint32 result_group = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_result_group());
    }

    // optional int32 result_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_result_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MballocDiscardFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MballocDiscardFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MballocDiscardFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MballocDiscardFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MballocDiscardFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MballocDiscardFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.result_start_ = from._impl_.result_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.result_group_ = from._impl_.result_group_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.result_len_ = from._impl_.result_len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MballocDiscardFtraceEvent::CopyFrom(const Ext4MballocDiscardFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocDiscardFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocDiscardFtraceEvent::InternalSwap(Ext4MballocDiscardFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MballocDiscardFtraceEvent, _impl_.result_len_)
      + sizeof(Ext4MballocDiscardFtraceEvent::_impl_.result_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MballocDiscardFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MballocDiscardFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[71]);
}
// ===================================================================

class Ext4MballocFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocFreeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MballocFreeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MballocFreeFtraceEvent)
}
Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent(const Ext4MballocFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocFreeFtraceEvent)
}

inline void Ext4MballocFreeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.result_start_) { 0 }

    , decltype(_impl_.result_group_) { 0u }

    , decltype(_impl_.result_len_) { 0 }

  };
}

Ext4MballocFreeFtraceEvent::~Ext4MballocFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MballocFreeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MballocFreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MballocFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.result_len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.result_len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MballocFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 result_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_result_start(&has_bits);
          _impl_.result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 result_group = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_result_group(&has_bits);
          _impl_.result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 result_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_result_len(&has_bits);
          _impl_.result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MballocFreeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int32 result_start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_result_start(), target);
  }

  // optional uint32 result_group = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_result_group(), target);
  }

  // optional int32 result_len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_result_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MballocFreeFtraceEvent)
  return target;
}

::size_t Ext4MballocFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int32 result_start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_result_start());
    }

    // optional uint32 result_group = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_result_group());
    }

    // optional int32 result_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_result_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MballocFreeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MballocFreeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MballocFreeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MballocFreeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MballocFreeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MballocFreeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.result_start_ = from._impl_.result_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.result_group_ = from._impl_.result_group_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.result_len_ = from._impl_.result_len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MballocFreeFtraceEvent::CopyFrom(const Ext4MballocFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocFreeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocFreeFtraceEvent::InternalSwap(Ext4MballocFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MballocFreeFtraceEvent, _impl_.result_len_)
      + sizeof(Ext4MballocFreeFtraceEvent::_impl_.result_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MballocFreeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MballocFreeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[72]);
}
// ===================================================================

class Ext4MballocPreallocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocPreallocFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4MballocPreallocFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_orig_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_orig_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_orig_group(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_orig_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_result_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MballocPreallocFtraceEvent)
}
Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent(const Ext4MballocPreallocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocPreallocFtraceEvent)
}

inline void Ext4MballocPreallocFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.orig_logical_) { 0u }

    , decltype(_impl_.orig_start_) { 0 }

    , decltype(_impl_.orig_group_) { 0u }

    , decltype(_impl_.orig_len_) { 0 }

    , decltype(_impl_.result_logical_) { 0u }

    , decltype(_impl_.result_start_) { 0 }

    , decltype(_impl_.result_group_) { 0u }

    , decltype(_impl_.result_len_) { 0 }

  };
}

Ext4MballocPreallocFtraceEvent::~Ext4MballocPreallocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MballocPreallocFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MballocPreallocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4MballocPreallocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.result_start_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.result_start_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.result_group_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.result_len_) -
        reinterpret_cast<char*>(&_impl_.result_group_)) + sizeof(_impl_.result_len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4MballocPreallocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 orig_logical = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_orig_logical(&has_bits);
          _impl_.orig_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 orig_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_orig_start(&has_bits);
          _impl_.orig_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 orig_group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_orig_group(&has_bits);
          _impl_.orig_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 orig_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_orig_len(&has_bits);
          _impl_.orig_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 result_logical = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_result_logical(&has_bits);
          _impl_.result_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 result_start = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_result_start(&has_bits);
          _impl_.result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 result_group = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_result_group(&has_bits);
          _impl_.result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 result_len = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_result_len(&has_bits);
          _impl_.result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4MballocPreallocFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 orig_logical = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_orig_logical(), target);
  }

  // optional int32 orig_start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_orig_start(), target);
  }

  // optional uint32 orig_group = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_orig_group(), target);
  }

  // optional int32 orig_len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_orig_len(), target);
  }

  // optional uint32 result_logical = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_result_logical(), target);
  }

  // optional int32 result_start = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_result_start(), target);
  }

  // optional uint32 result_group = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_result_group(), target);
  }

  // optional int32 result_len = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_result_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  return target;
}

::size_t Ext4MballocPreallocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 orig_logical = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_orig_logical());
    }

    // optional int32 orig_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_orig_start());
    }

    // optional uint32 orig_group = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_orig_group());
    }

    // optional int32 orig_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_orig_len());
    }

    // optional uint32 result_logical = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_result_logical());
    }

    // optional int32 result_start = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_result_start());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 result_group = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_result_group());
    }

    // optional int32 result_len = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_result_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4MballocPreallocFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4MballocPreallocFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4MballocPreallocFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4MballocPreallocFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4MballocPreallocFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4MballocPreallocFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.orig_logical_ = from._impl_.orig_logical_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.orig_start_ = from._impl_.orig_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.orig_group_ = from._impl_.orig_group_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.orig_len_ = from._impl_.orig_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.result_logical_ = from._impl_.result_logical_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.result_start_ = from._impl_.result_start_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.result_group_ = from._impl_.result_group_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.result_len_ = from._impl_.result_len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4MballocPreallocFtraceEvent::CopyFrom(const Ext4MballocPreallocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocPreallocFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocPreallocFtraceEvent::InternalSwap(Ext4MballocPreallocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MballocPreallocFtraceEvent, _impl_.result_len_)
      + sizeof(Ext4MballocPreallocFtraceEvent::_impl_.result_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MballocPreallocFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4MballocPreallocFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[73]);
}
// ===================================================================

class Ext4OtherInodeUpdateTimeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4OtherInodeUpdateTimeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4OtherInodeUpdateTimeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_orig_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
}
Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent(const Ext4OtherInodeUpdateTimeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
}

inline void Ext4OtherInodeUpdateTimeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.orig_ino_) { ::uint64_t{0u} }

    , decltype(_impl_.uid_) { 0u }

    , decltype(_impl_.gid_) { 0u }

    , decltype(_impl_.mode_) { 0u }

  };
}

Ext4OtherInodeUpdateTimeFtraceEvent::~Ext4OtherInodeUpdateTimeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4OtherInodeUpdateTimeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4OtherInodeUpdateTimeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4OtherInodeUpdateTimeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4OtherInodeUpdateTimeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 orig_ino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_orig_ino(&has_bits);
          _impl_.orig_ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 uid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_uid(&has_bits);
          _impl_.uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 gid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_gid(&has_bits);
          _impl_.gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4OtherInodeUpdateTimeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 orig_ino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_orig_ino(), target);
  }

  // optional uint32 uid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_uid(), target);
  }

  // optional uint32 gid = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_gid(), target);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  return target;
}

::size_t Ext4OtherInodeUpdateTimeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 orig_ino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_orig_ino());
    }

    // optional uint32 uid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_uid());
    }

    // optional uint32 gid = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gid());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4OtherInodeUpdateTimeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4OtherInodeUpdateTimeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4OtherInodeUpdateTimeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4OtherInodeUpdateTimeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4OtherInodeUpdateTimeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4OtherInodeUpdateTimeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.orig_ino_ = from._impl_.orig_ino_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.uid_ = from._impl_.uid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gid_ = from._impl_.gid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4OtherInodeUpdateTimeFtraceEvent::CopyFrom(const Ext4OtherInodeUpdateTimeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4OtherInodeUpdateTimeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4OtherInodeUpdateTimeFtraceEvent::InternalSwap(Ext4OtherInodeUpdateTimeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4OtherInodeUpdateTimeFtraceEvent, _impl_.mode_)
      + sizeof(Ext4OtherInodeUpdateTimeFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4OtherInodeUpdateTimeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4OtherInodeUpdateTimeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[74]);
}
// ===================================================================

class Ext4PunchHoleFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4PunchHoleFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4PunchHoleFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4PunchHoleFtraceEvent)
}
Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent(const Ext4PunchHoleFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4PunchHoleFtraceEvent)
}

inline void Ext4PunchHoleFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.offset_) { ::int64_t{0} }

    , decltype(_impl_.len_) { ::int64_t{0} }

    , decltype(_impl_.mode_) { 0 }

  };
}

Ext4PunchHoleFtraceEvent::~Ext4PunchHoleFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4PunchHoleFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4PunchHoleFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4PunchHoleFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4PunchHoleFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4PunchHoleFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4PunchHoleFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_len(), target);
  }

  // optional int32 mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4PunchHoleFtraceEvent)
  return target;
}

::size_t Ext4PunchHoleFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_len());
    }

    // optional int32 mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4PunchHoleFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4PunchHoleFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4PunchHoleFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4PunchHoleFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4PunchHoleFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4PunchHoleFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4PunchHoleFtraceEvent::CopyFrom(const Ext4PunchHoleFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4PunchHoleFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4PunchHoleFtraceEvent::InternalSwap(Ext4PunchHoleFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4PunchHoleFtraceEvent, _impl_.mode_)
      + sizeof(Ext4PunchHoleFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4PunchHoleFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4PunchHoleFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[75]);
}
// ===================================================================

class Ext4ReadBlockBitmapLoadFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ReadBlockBitmapLoadFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ReadBlockBitmapLoadFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefetch(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
}
Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent(const Ext4ReadBlockBitmapLoadFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
}

inline void Ext4ReadBlockBitmapLoadFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.group_) { 0u }

    , decltype(_impl_.prefetch_) { 0u }

  };
}

Ext4ReadBlockBitmapLoadFtraceEvent::~Ext4ReadBlockBitmapLoadFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ReadBlockBitmapLoadFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ReadBlockBitmapLoadFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ReadBlockBitmapLoadFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.prefetch_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.prefetch_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ReadBlockBitmapLoadFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          _impl_.group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 prefetch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_prefetch(&has_bits);
          _impl_.prefetch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ReadBlockBitmapLoadFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_group(), target);
  }

  // optional uint32 prefetch = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_prefetch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  return target;
}

::size_t Ext4ReadBlockBitmapLoadFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_group());
    }

    // optional uint32 prefetch = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_prefetch());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ReadBlockBitmapLoadFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ReadBlockBitmapLoadFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ReadBlockBitmapLoadFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ReadBlockBitmapLoadFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ReadBlockBitmapLoadFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ReadBlockBitmapLoadFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_ = from._impl_.group_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prefetch_ = from._impl_.prefetch_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ReadBlockBitmapLoadFtraceEvent::CopyFrom(const Ext4ReadBlockBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ReadBlockBitmapLoadFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ReadBlockBitmapLoadFtraceEvent::InternalSwap(Ext4ReadBlockBitmapLoadFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ReadBlockBitmapLoadFtraceEvent, _impl_.prefetch_)
      + sizeof(Ext4ReadBlockBitmapLoadFtraceEvent::_impl_.prefetch_)
      - PROTOBUF_FIELD_OFFSET(Ext4ReadBlockBitmapLoadFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ReadBlockBitmapLoadFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[76]);
}
// ===================================================================

class Ext4ReadpageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ReadpageFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ReadpageFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ReadpageFtraceEvent)
}
Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent(const Ext4ReadpageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ReadpageFtraceEvent)
}

inline void Ext4ReadpageFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.index_) { ::uint64_t{0u} }

  };
}

Ext4ReadpageFtraceEvent::~Ext4ReadpageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ReadpageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ReadpageFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ReadpageFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ReadpageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.index_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ReadpageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ReadpageFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ReadpageFtraceEvent)
  return target;
}

::size_t Ext4ReadpageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ReadpageFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ReadpageFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ReadpageFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ReadpageFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ReadpageFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ReadpageFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ReadpageFtraceEvent::CopyFrom(const Ext4ReadpageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ReadpageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ReadpageFtraceEvent::InternalSwap(Ext4ReadpageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ReadpageFtraceEvent, _impl_.index_)
      + sizeof(Ext4ReadpageFtraceEvent::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(Ext4ReadpageFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ReadpageFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[77]);
}
// ===================================================================

class Ext4ReleasepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ReleasepageFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ReleasepageFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ReleasepageFtraceEvent)
}
Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent(const Ext4ReleasepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ReleasepageFtraceEvent)
}

inline void Ext4ReleasepageFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.index_) { ::uint64_t{0u} }

  };
}

Ext4ReleasepageFtraceEvent::~Ext4ReleasepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ReleasepageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ReleasepageFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ReleasepageFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ReleasepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.index_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ReleasepageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ReleasepageFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ReleasepageFtraceEvent)
  return target;
}

::size_t Ext4ReleasepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ReleasepageFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ReleasepageFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ReleasepageFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ReleasepageFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ReleasepageFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ReleasepageFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ReleasepageFtraceEvent::CopyFrom(const Ext4ReleasepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ReleasepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ReleasepageFtraceEvent::InternalSwap(Ext4ReleasepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ReleasepageFtraceEvent, _impl_.index_)
      + sizeof(Ext4ReleasepageFtraceEvent::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(Ext4ReleasepageFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ReleasepageFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[78]);
}
// ===================================================================

class Ext4RemoveBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4RemoveBlocksFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4RemoveBlocksFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_to(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ee_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ee_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ee_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pc_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_pc_pclu(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pc_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
}
Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent(const Ext4RemoveBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
}

inline void Ext4RemoveBlocksFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.from_) { 0u }

    , decltype(_impl_.to_) { 0u }

    , decltype(_impl_.partial_) { ::int64_t{0} }

    , decltype(_impl_.ee_pblk_) { ::uint64_t{0u} }

    , decltype(_impl_.ee_lblk_) { 0u }

    , decltype(_impl_.ee_len_) { 0u }

    , decltype(_impl_.pc_pclu_) { ::uint64_t{0u} }

    , decltype(_impl_.pc_lblk_) { 0u }

    , decltype(_impl_.pc_state_) { 0 }

  };
}

Ext4RemoveBlocksFtraceEvent::~Ext4RemoveBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4RemoveBlocksFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4RemoveBlocksFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4RemoveBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ee_len_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ee_len_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.pc_pclu_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pc_state_) -
        reinterpret_cast<char*>(&_impl_.pc_pclu_)) + sizeof(_impl_.pc_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4RemoveBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_from(&has_bits);
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 to = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_to(&has_bits);
          _impl_.to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 partial = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_partial(&has_bits);
          _impl_.partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ee_pblk = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_ee_pblk(&has_bits);
          _impl_.ee_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 ee_lblk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_ee_lblk(&has_bits);
          _impl_.ee_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 ee_len = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_ee_len(&has_bits);
          _impl_.ee_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 pc_lblk = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_pc_lblk(&has_bits);
          _impl_.pc_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pc_pclu = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_pc_pclu(&has_bits);
          _impl_.pc_pclu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pc_state = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_pc_state(&has_bits);
          _impl_.pc_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4RemoveBlocksFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 from = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_from(), target);
  }

  // optional uint32 to = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_to(), target);
  }

  // optional int64 partial = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_partial(), target);
  }

  // optional uint64 ee_pblk = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_ee_pblk(), target);
  }

  // optional uint32 ee_lblk = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_ee_lblk(), target);
  }

  // optional uint32 ee_len = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_ee_len(), target);
  }

  // optional uint32 pc_lblk = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_pc_lblk(), target);
  }

  // optional uint64 pc_pclu = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        10, this->_internal_pc_pclu(), target);
  }

  // optional int32 pc_state = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_pc_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  return target;
}

::size_t Ext4RemoveBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 from = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_from());
    }

    // optional uint32 to = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_to());
    }

    // optional int64 partial = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_partial());
    }

    // optional uint64 ee_pblk = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ee_pblk());
    }

    // optional uint32 ee_lblk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_ee_lblk());
    }

    // optional uint32 ee_len = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_ee_len());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint64 pc_pclu = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pc_pclu());
    }

    // optional uint32 pc_lblk = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_pc_lblk());
    }

    // optional int32 pc_state = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pc_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4RemoveBlocksFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4RemoveBlocksFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4RemoveBlocksFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4RemoveBlocksFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4RemoveBlocksFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4RemoveBlocksFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.from_ = from._impl_.from_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.to_ = from._impl_.to_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.partial_ = from._impl_.partial_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ee_pblk_ = from._impl_.ee_pblk_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ee_lblk_ = from._impl_.ee_lblk_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.ee_len_ = from._impl_.ee_len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.pc_pclu_ = from._impl_.pc_pclu_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pc_lblk_ = from._impl_.pc_lblk_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.pc_state_ = from._impl_.pc_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4RemoveBlocksFtraceEvent::CopyFrom(const Ext4RemoveBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4RemoveBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4RemoveBlocksFtraceEvent::InternalSwap(Ext4RemoveBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4RemoveBlocksFtraceEvent, _impl_.pc_state_)
      + sizeof(Ext4RemoveBlocksFtraceEvent::_impl_.pc_state_)
      - PROTOBUF_FIELD_OFFSET(Ext4RemoveBlocksFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4RemoveBlocksFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[79]);
}
// ===================================================================

class Ext4RequestBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4RequestBlocksFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4RequestBlocksFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lleft(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lright(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_goal(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pleft(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pright(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4RequestBlocksFtraceEvent)
}
Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent(const Ext4RequestBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4RequestBlocksFtraceEvent)
}

inline void Ext4RequestBlocksFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.logical_) { 0u }

    , decltype(_impl_.lleft_) { 0u }

    , decltype(_impl_.lright_) { 0u }

    , decltype(_impl_.goal_) { ::uint64_t{0u} }

    , decltype(_impl_.pleft_) { ::uint64_t{0u} }

    , decltype(_impl_.pright_) { ::uint64_t{0u} }

    , decltype(_impl_.flags_) { 0u }

  };
}

Ext4RequestBlocksFtraceEvent::~Ext4RequestBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4RequestBlocksFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4RequestBlocksFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4RequestBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.pleft_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.pleft_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.pright_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.pright_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4RequestBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 logical = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_logical(&has_bits);
          _impl_.logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lleft = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_lleft(&has_bits);
          _impl_.lleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 lright = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_lright(&has_bits);
          _impl_.lright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 goal = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_goal(&has_bits);
          _impl_.goal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pleft = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_pleft(&has_bits);
          _impl_.pleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 pright = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_pright(&has_bits);
          _impl_.pright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4RequestBlocksFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint32 len = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_len(), target);
  }

  // optional uint32 logical = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_logical(), target);
  }

  // optional uint32 lleft = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_lleft(), target);
  }

  // optional uint32 lright = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_lright(), target);
  }

  // optional uint64 goal = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_goal(), target);
  }

  // optional uint64 pleft = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_pleft(), target);
  }

  // optional uint64 pright = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        9, this->_internal_pright(), target);
  }

  // optional uint32 flags = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        10, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  return target;
}

::size_t Ext4RequestBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint32 len = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 logical = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_logical());
    }

    // optional uint32 lleft = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lleft());
    }

    // optional uint32 lright = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lright());
    }

    // optional uint64 goal = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_goal());
    }

    // optional uint64 pleft = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pleft());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint64 pright = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_pright());
    }

    // optional uint32 flags = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4RequestBlocksFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4RequestBlocksFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4RequestBlocksFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4RequestBlocksFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4RequestBlocksFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4RequestBlocksFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.logical_ = from._impl_.logical_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.lleft_ = from._impl_.lleft_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.lright_ = from._impl_.lright_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.goal_ = from._impl_.goal_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.pleft_ = from._impl_.pleft_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.pright_ = from._impl_.pright_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4RequestBlocksFtraceEvent::CopyFrom(const Ext4RequestBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4RequestBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4RequestBlocksFtraceEvent::InternalSwap(Ext4RequestBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4RequestBlocksFtraceEvent, _impl_.flags_)
      + sizeof(Ext4RequestBlocksFtraceEvent::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4RequestBlocksFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4RequestBlocksFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[80]);
}
// ===================================================================

class Ext4RequestInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4RequestInodeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4RequestInodeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4RequestInodeFtraceEvent)
}
Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent(const Ext4RequestInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4RequestInodeFtraceEvent)
}

inline void Ext4RequestInodeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.dir_) { ::uint64_t{0u} }

    , decltype(_impl_.mode_) { 0u }

  };
}

Ext4RequestInodeFtraceEvent::~Ext4RequestInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4RequestInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4RequestInodeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4RequestInodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4RequestInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4RequestInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_dir(&has_bits);
          _impl_.dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4RequestInodeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_dir(), target);
  }

  // optional uint32 mode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4RequestInodeFtraceEvent)
  return target;
}

::size_t Ext4RequestInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dir());
    }

    // optional uint32 mode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4RequestInodeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4RequestInodeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4RequestInodeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4RequestInodeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4RequestInodeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4RequestInodeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dir_ = from._impl_.dir_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4RequestInodeFtraceEvent::CopyFrom(const Ext4RequestInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4RequestInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4RequestInodeFtraceEvent::InternalSwap(Ext4RequestInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4RequestInodeFtraceEvent, _impl_.mode_)
      + sizeof(Ext4RequestInodeFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4RequestInodeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4RequestInodeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[81]);
}
// ===================================================================

class Ext4SyncFsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4SyncFsFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4SyncFsFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4SyncFsFtraceEvent)
}
Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent(const Ext4SyncFsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4SyncFsFtraceEvent)
}

inline void Ext4SyncFsFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.wait_) { 0 }

  };
}

Ext4SyncFsFtraceEvent::~Ext4SyncFsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4SyncFsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4SyncFsFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4SyncFsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4SyncFsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.wait_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.wait_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4SyncFsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 wait = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_wait(&has_bits);
          _impl_.wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4SyncFsFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional int32 wait = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_wait(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4SyncFsFtraceEvent)
  return target;
}

::size_t Ext4SyncFsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional int32 wait = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_wait());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4SyncFsFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4SyncFsFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4SyncFsFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4SyncFsFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4SyncFsFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4SyncFsFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.wait_ = from._impl_.wait_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4SyncFsFtraceEvent::CopyFrom(const Ext4SyncFsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4SyncFsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4SyncFsFtraceEvent::InternalSwap(Ext4SyncFsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4SyncFsFtraceEvent, _impl_.wait_)
      + sizeof(Ext4SyncFsFtraceEvent::_impl_.wait_)
      - PROTOBUF_FIELD_OFFSET(Ext4SyncFsFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4SyncFsFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[82]);
}
// ===================================================================

class Ext4TrimAllFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TrimAllFreeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4TrimAllFreeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev_major(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dev_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
}
Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent(const Ext4TrimAllFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
}

inline void Ext4TrimAllFreeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_major_) { 0 }

    , decltype(_impl_.dev_minor_) { 0 }

    , decltype(_impl_.group_) { 0u }

    , decltype(_impl_.start_) { 0 }

    , decltype(_impl_.len_) { 0 }

  };
}

Ext4TrimAllFreeFtraceEvent::~Ext4TrimAllFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4TrimAllFreeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4TrimAllFreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4TrimAllFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_major_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.dev_major_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4TrimAllFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dev_major = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev_major(&has_bits);
          _impl_.dev_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 dev_minor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_dev_minor(&has_bits);
          _impl_.dev_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 group = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_group(&has_bits);
          _impl_.group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4TrimAllFreeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 dev_major = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_dev_major(), target);
  }

  // optional int32 dev_minor = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_dev_minor(), target);
  }

  // optional uint32 group = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_group(), target);
  }

  // optional int32 start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_start(), target);
  }

  // optional int32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  return target;
}

::size_t Ext4TrimAllFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 dev_major = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_dev_major());
    }

    // optional int32 dev_minor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_dev_minor());
    }

    // optional uint32 group = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_group());
    }

    // optional int32 start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_start());
    }

    // optional int32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4TrimAllFreeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4TrimAllFreeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4TrimAllFreeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4TrimAllFreeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4TrimAllFreeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4TrimAllFreeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_major_ = from._impl_.dev_major_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dev_minor_ = from._impl_.dev_minor_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_ = from._impl_.group_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4TrimAllFreeFtraceEvent::CopyFrom(const Ext4TrimAllFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TrimAllFreeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TrimAllFreeFtraceEvent::InternalSwap(Ext4TrimAllFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4TrimAllFreeFtraceEvent, _impl_.len_)
      + sizeof(Ext4TrimAllFreeFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(Ext4TrimAllFreeFtraceEvent, _impl_.dev_major_)>(
          reinterpret_cast<char*>(&_impl_.dev_major_),
          reinterpret_cast<char*>(&other->_impl_.dev_major_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4TrimAllFreeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[83]);
}
// ===================================================================

class Ext4TrimExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TrimExtentFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4TrimExtentFtraceEvent, _impl_._has_bits_);
  static void set_has_dev_major(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dev_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4TrimExtentFtraceEvent)
}
Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent(const Ext4TrimExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TrimExtentFtraceEvent)
}

inline void Ext4TrimExtentFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_major_) { 0 }

    , decltype(_impl_.dev_minor_) { 0 }

    , decltype(_impl_.group_) { 0u }

    , decltype(_impl_.start_) { 0 }

    , decltype(_impl_.len_) { 0 }

  };
}

Ext4TrimExtentFtraceEvent::~Ext4TrimExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TrimExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4TrimExtentFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4TrimExtentFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4TrimExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_major_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.dev_major_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4TrimExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dev_major = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev_major(&has_bits);
          _impl_.dev_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 dev_minor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_dev_minor(&has_bits);
          _impl_.dev_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 group = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_group(&has_bits);
          _impl_.group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4TrimExtentFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 dev_major = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_dev_major(), target);
  }

  // optional int32 dev_minor = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_dev_minor(), target);
  }

  // optional uint32 group = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_group(), target);
  }

  // optional int32 start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_start(), target);
  }

  // optional int32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4TrimExtentFtraceEvent)
  return target;
}

::size_t Ext4TrimExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 dev_major = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_dev_major());
    }

    // optional int32 dev_minor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_dev_minor());
    }

    // optional uint32 group = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_group());
    }

    // optional int32 start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_start());
    }

    // optional int32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_len());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4TrimExtentFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4TrimExtentFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4TrimExtentFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4TrimExtentFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4TrimExtentFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4TrimExtentFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_major_ = from._impl_.dev_major_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dev_minor_ = from._impl_.dev_minor_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_ = from._impl_.group_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4TrimExtentFtraceEvent::CopyFrom(const Ext4TrimExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TrimExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TrimExtentFtraceEvent::InternalSwap(Ext4TrimExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4TrimExtentFtraceEvent, _impl_.len_)
      + sizeof(Ext4TrimExtentFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(Ext4TrimExtentFtraceEvent, _impl_.dev_major_)>(
          reinterpret_cast<char*>(&_impl_.dev_major_),
          reinterpret_cast<char*>(&other->_impl_.dev_major_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4TrimExtentFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[84]);
}
// ===================================================================

class Ext4TruncateEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TruncateEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4TruncateEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4TruncateEnterFtraceEvent)
}
Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent(const Ext4TruncateEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TruncateEnterFtraceEvent)
}

inline void Ext4TruncateEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.blocks_) { ::uint64_t{0u} }

  };
}

Ext4TruncateEnterFtraceEvent::~Ext4TruncateEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4TruncateEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4TruncateEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4TruncateEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.blocks_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blocks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4TruncateEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4TruncateEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  return target;
}

::size_t Ext4TruncateEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_blocks());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4TruncateEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4TruncateEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4TruncateEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4TruncateEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4TruncateEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4TruncateEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4TruncateEnterFtraceEvent::CopyFrom(const Ext4TruncateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TruncateEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TruncateEnterFtraceEvent::InternalSwap(Ext4TruncateEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4TruncateEnterFtraceEvent, _impl_.blocks_)
      + sizeof(Ext4TruncateEnterFtraceEvent::_impl_.blocks_)
      - PROTOBUF_FIELD_OFFSET(Ext4TruncateEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4TruncateEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[85]);
}
// ===================================================================

class Ext4TruncateExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TruncateExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4TruncateExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4TruncateExitFtraceEvent)
}
Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent(const Ext4TruncateExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TruncateExitFtraceEvent)
}

inline void Ext4TruncateExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.blocks_) { ::uint64_t{0u} }

  };
}

Ext4TruncateExitFtraceEvent::~Ext4TruncateExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TruncateExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4TruncateExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4TruncateExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4TruncateExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.blocks_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blocks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4TruncateExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4TruncateExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4TruncateExitFtraceEvent)
  return target;
}

::size_t Ext4TruncateExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_blocks());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4TruncateExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4TruncateExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4TruncateExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4TruncateExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4TruncateExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4TruncateExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4TruncateExitFtraceEvent::CopyFrom(const Ext4TruncateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TruncateExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TruncateExitFtraceEvent::InternalSwap(Ext4TruncateExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4TruncateExitFtraceEvent, _impl_.blocks_)
      + sizeof(Ext4TruncateExitFtraceEvent::_impl_.blocks_)
      - PROTOBUF_FIELD_OFFSET(Ext4TruncateExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4TruncateExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[86]);
}
// ===================================================================

class Ext4UnlinkEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4UnlinkEnterFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4UnlinkEnterFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
}
Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent(const Ext4UnlinkEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
}

inline void Ext4UnlinkEnterFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.parent_) { ::uint64_t{0u} }

    , decltype(_impl_.size_) { ::int64_t{0} }

  };
}

Ext4UnlinkEnterFtraceEvent::~Ext4UnlinkEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4UnlinkEnterFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4UnlinkEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4UnlinkEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4UnlinkEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_parent(&has_bits);
          _impl_.parent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4UnlinkEnterFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 parent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_parent(), target);
  }

  // optional int64 size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  return target;
}

::size_t Ext4UnlinkEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 parent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_parent());
    }

    // optional int64 size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4UnlinkEnterFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4UnlinkEnterFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4UnlinkEnterFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4UnlinkEnterFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4UnlinkEnterFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4UnlinkEnterFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.parent_ = from._impl_.parent_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4UnlinkEnterFtraceEvent::CopyFrom(const Ext4UnlinkEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4UnlinkEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4UnlinkEnterFtraceEvent::InternalSwap(Ext4UnlinkEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4UnlinkEnterFtraceEvent, _impl_.size_)
      + sizeof(Ext4UnlinkEnterFtraceEvent::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(Ext4UnlinkEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4UnlinkEnterFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[87]);
}
// ===================================================================

class Ext4UnlinkExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4UnlinkExitFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4UnlinkExitFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4UnlinkExitFtraceEvent)
}
Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent(const Ext4UnlinkExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4UnlinkExitFtraceEvent)
}

inline void Ext4UnlinkExitFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.ret_) { 0 }

  };
}

Ext4UnlinkExitFtraceEvent::~Ext4UnlinkExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4UnlinkExitFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4UnlinkExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4UnlinkExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4UnlinkExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4UnlinkExitFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  return target;
}

::size_t Ext4UnlinkExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4UnlinkExitFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4UnlinkExitFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4UnlinkExitFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4UnlinkExitFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4UnlinkExitFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4UnlinkExitFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4UnlinkExitFtraceEvent::CopyFrom(const Ext4UnlinkExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4UnlinkExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4UnlinkExitFtraceEvent::InternalSwap(Ext4UnlinkExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4UnlinkExitFtraceEvent, _impl_.ret_)
      + sizeof(Ext4UnlinkExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4UnlinkExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4UnlinkExitFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[88]);
}
// ===================================================================

class Ext4WriteBeginFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WriteBeginFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4WriteBeginFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WriteBeginFtraceEvent)
}
Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent(const Ext4WriteBeginFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WriteBeginFtraceEvent)
}

inline void Ext4WriteBeginFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pos_) { ::int64_t{0} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.flags_) { 0u }

  };
}

Ext4WriteBeginFtraceEvent::~Ext4WriteBeginFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WriteBeginFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WriteBeginFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WriteBeginFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4WriteBeginFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4WriteBeginFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4WriteBeginFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WriteBeginFtraceEvent)
  return target;
}

::size_t Ext4WriteBeginFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4WriteBeginFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4WriteBeginFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4WriteBeginFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4WriteBeginFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4WriteBeginFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4WriteBeginFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4WriteBeginFtraceEvent::CopyFrom(const Ext4WriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WriteBeginFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WriteBeginFtraceEvent::InternalSwap(Ext4WriteBeginFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WriteBeginFtraceEvent, _impl_.flags_)
      + sizeof(Ext4WriteBeginFtraceEvent::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4WriteBeginFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4WriteBeginFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[89]);
}
// ===================================================================

class Ext4WriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WriteEndFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4WriteEndFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WriteEndFtraceEvent)
}
Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent(const Ext4WriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WriteEndFtraceEvent)
}

inline void Ext4WriteEndFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.pos_) { ::int64_t{0} }

    , decltype(_impl_.len_) { 0u }

    , decltype(_impl_.copied_) { 0u }

  };
}

Ext4WriteEndFtraceEvent::~Ext4WriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WriteEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WriteEndFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WriteEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4WriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.copied_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.copied_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4WriteEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          _impl_.copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4WriteEndFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_len(), target);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_copied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WriteEndFtraceEvent)
  return target;
}

::size_t Ext4WriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_copied());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4WriteEndFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4WriteEndFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4WriteEndFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4WriteEndFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4WriteEndFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4WriteEndFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.copied_ = from._impl_.copied_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4WriteEndFtraceEvent::CopyFrom(const Ext4WriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WriteEndFtraceEvent::InternalSwap(Ext4WriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WriteEndFtraceEvent, _impl_.copied_)
      + sizeof(Ext4WriteEndFtraceEvent::_impl_.copied_)
      - PROTOBUF_FIELD_OFFSET(Ext4WriteEndFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4WriteEndFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[90]);
}
// ===================================================================

class Ext4WritepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WritepageFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4WritepageFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WritepageFtraceEvent)
}
Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent(const Ext4WritepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WritepageFtraceEvent)
}

inline void Ext4WritepageFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.index_) { ::uint64_t{0u} }

  };
}

Ext4WritepageFtraceEvent::~Ext4WritepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WritepageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WritepageFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WritepageFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4WritepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WritepageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.index_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4WritepageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4WritepageFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WritepageFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WritepageFtraceEvent)
  return target;
}

::size_t Ext4WritepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WritepageFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4WritepageFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4WritepageFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4WritepageFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4WritepageFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4WritepageFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4WritepageFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WritepageFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4WritepageFtraceEvent::CopyFrom(const Ext4WritepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WritepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WritepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WritepageFtraceEvent::InternalSwap(Ext4WritepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WritepageFtraceEvent, _impl_.index_)
      + sizeof(Ext4WritepageFtraceEvent::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(Ext4WritepageFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4WritepageFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[91]);
}
// ===================================================================

class Ext4WritepagesFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WritepagesFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4WritepagesFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nr_to_write(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pages_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_range_start(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_range_end(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_writeback_index(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sync_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_for_kupdate(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_range_cyclic(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WritepagesFtraceEvent)
}
Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent(const Ext4WritepagesFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WritepagesFtraceEvent)
}

inline void Ext4WritepagesFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.nr_to_write_) { ::int64_t{0} }

    , decltype(_impl_.pages_skipped_) { ::int64_t{0} }

    , decltype(_impl_.range_start_) { ::int64_t{0} }

    , decltype(_impl_.range_end_) { ::int64_t{0} }

    , decltype(_impl_.writeback_index_) { ::uint64_t{0u} }

    , decltype(_impl_.sync_mode_) { 0 }

    , decltype(_impl_.for_kupdate_) { 0u }

    , decltype(_impl_.range_cyclic_) { 0u }

  };
}

Ext4WritepagesFtraceEvent::~Ext4WritepagesFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WritepagesFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WritepagesFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WritepagesFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4WritepagesFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.sync_mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.sync_mode_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.for_kupdate_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.range_cyclic_) -
        reinterpret_cast<char*>(&_impl_.for_kupdate_)) + sizeof(_impl_.range_cyclic_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4WritepagesFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 nr_to_write = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_nr_to_write(&has_bits);
          _impl_.nr_to_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pages_skipped = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pages_skipped(&has_bits);
          _impl_.pages_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 range_start = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_range_start(&has_bits);
          _impl_.range_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 range_end = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_range_end(&has_bits);
          _impl_.range_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 writeback_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_writeback_index(&has_bits);
          _impl_.writeback_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 sync_mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_sync_mode(&has_bits);
          _impl_.sync_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 for_kupdate = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_for_kupdate(&has_bits);
          _impl_.for_kupdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 range_cyclic = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_range_cyclic(&has_bits);
          _impl_.range_cyclic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4WritepagesFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 nr_to_write = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_nr_to_write(), target);
  }

  // optional int64 pages_skipped = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_pages_skipped(), target);
  }

  // optional int64 range_start = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_range_start(), target);
  }

  // optional int64 range_end = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_range_end(), target);
  }

  // optional uint64 writeback_index = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_writeback_index(), target);
  }

  // optional int32 sync_mode = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_sync_mode(), target);
  }

  // optional uint32 for_kupdate = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_for_kupdate(), target);
  }

  // optional uint32 range_cyclic = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        10, this->_internal_range_cyclic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WritepagesFtraceEvent)
  return target;
}

::size_t Ext4WritepagesFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 nr_to_write = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_nr_to_write());
    }

    // optional int64 pages_skipped = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pages_skipped());
    }

    // optional int64 range_start = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_range_start());
    }

    // optional int64 range_end = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_range_end());
    }

    // optional uint64 writeback_index = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_writeback_index());
    }

    // optional int32 sync_mode = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_sync_mode());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 for_kupdate = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_for_kupdate());
    }

    // optional uint32 range_cyclic = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_range_cyclic());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4WritepagesFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4WritepagesFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4WritepagesFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4WritepagesFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4WritepagesFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4WritepagesFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nr_to_write_ = from._impl_.nr_to_write_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pages_skipped_ = from._impl_.pages_skipped_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.range_start_ = from._impl_.range_start_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.range_end_ = from._impl_.range_end_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.writeback_index_ = from._impl_.writeback_index_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.sync_mode_ = from._impl_.sync_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.for_kupdate_ = from._impl_.for_kupdate_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.range_cyclic_ = from._impl_.range_cyclic_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4WritepagesFtraceEvent::CopyFrom(const Ext4WritepagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WritepagesFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WritepagesFtraceEvent::InternalSwap(Ext4WritepagesFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WritepagesFtraceEvent, _impl_.range_cyclic_)
      + sizeof(Ext4WritepagesFtraceEvent::_impl_.range_cyclic_)
      - PROTOBUF_FIELD_OFFSET(Ext4WritepagesFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4WritepagesFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[92]);
}
// ===================================================================

class Ext4WritepagesResultFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WritepagesResultFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4WritepagesResultFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pages_written(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pages_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_writeback_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_sync_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WritepagesResultFtraceEvent)
}
Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent(const Ext4WritepagesResultFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WritepagesResultFtraceEvent)
}

inline void Ext4WritepagesResultFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.ret_) { 0 }

    , decltype(_impl_.pages_written_) { 0 }

    , decltype(_impl_.pages_skipped_) { ::int64_t{0} }

    , decltype(_impl_.writeback_index_) { ::uint64_t{0u} }

    , decltype(_impl_.sync_mode_) { 0 }

  };
}

Ext4WritepagesResultFtraceEvent::~Ext4WritepagesResultFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WritepagesResultFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WritepagesResultFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4WritepagesResultFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.sync_mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.sync_mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4WritepagesResultFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 pages_written = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_pages_written(&has_bits);
          _impl_.pages_written_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 pages_skipped = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_pages_skipped(&has_bits);
          _impl_.pages_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 writeback_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_writeback_index(&has_bits);
          _impl_.writeback_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 sync_mode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_sync_mode(&has_bits);
          _impl_.sync_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4WritepagesResultFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_ret(), target);
  }

  // optional int32 pages_written = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_pages_written(), target);
  }

  // optional int64 pages_skipped = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_pages_skipped(), target);
  }

  // optional uint64 writeback_index = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_writeback_index(), target);
  }

  // optional int32 sync_mode = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_sync_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  return target;
}

::size_t Ext4WritepagesResultFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_ret());
    }

    // optional int32 pages_written = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_pages_written());
    }

    // optional int64 pages_skipped = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_pages_skipped());
    }

    // optional uint64 writeback_index = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_writeback_index());
    }

    // optional int32 sync_mode = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_sync_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4WritepagesResultFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4WritepagesResultFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4WritepagesResultFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4WritepagesResultFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4WritepagesResultFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4WritepagesResultFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pages_written_ = from._impl_.pages_written_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pages_skipped_ = from._impl_.pages_skipped_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.writeback_index_ = from._impl_.writeback_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.sync_mode_ = from._impl_.sync_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4WritepagesResultFtraceEvent::CopyFrom(const Ext4WritepagesResultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WritepagesResultFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WritepagesResultFtraceEvent::InternalSwap(Ext4WritepagesResultFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WritepagesResultFtraceEvent, _impl_.sync_mode_)
      + sizeof(Ext4WritepagesResultFtraceEvent::_impl_.sync_mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4WritepagesResultFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4WritepagesResultFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[93]);
}
// ===================================================================

class Ext4ZeroRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ZeroRangeFtraceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Ext4ZeroRangeFtraceEvent, _impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ZeroRangeFtraceEvent)
}
Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent(const Ext4ZeroRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ZeroRangeFtraceEvent)
}

inline void Ext4ZeroRangeFtraceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_) { ::uint64_t{0u} }

    , decltype(_impl_.ino_) { ::uint64_t{0u} }

    , decltype(_impl_.offset_) { ::int64_t{0} }

    , decltype(_impl_.len_) { ::int64_t{0} }

    , decltype(_impl_.mode_) { 0 }

  };
}

Ext4ZeroRangeFtraceEvent::~Ext4ZeroRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ZeroRangeFtraceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ZeroRangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ext4ZeroRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ext4ZeroRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Ext4ZeroRangeFtraceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_len(), target);
  }

  // optional int32 mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  return target;
}

::size_t Ext4ZeroRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_len());
    }

    // optional int32 mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ext4ZeroRangeFtraceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ext4ZeroRangeFtraceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ext4ZeroRangeFtraceEvent::GetClassData() const { return &_class_data_; }


void Ext4ZeroRangeFtraceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ext4ZeroRangeFtraceEvent*>(&to_msg);
  auto& from = static_cast<const Ext4ZeroRangeFtraceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ext4ZeroRangeFtraceEvent::CopyFrom(const Ext4ZeroRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ZeroRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ZeroRangeFtraceEvent::InternalSwap(Ext4ZeroRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ZeroRangeFtraceEvent, _impl_.mode_)
      + sizeof(Ext4ZeroRangeFtraceEvent::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4ZeroRangeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ext4ZeroRangeFtraceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_getter, &descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto_once,
      file_level_metadata_protos_2fperfetto_2ftrace_2fftrace_2fext4_2eproto[94]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWriteBeginFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWriteBeginFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaWriteBeginFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWriteEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaWriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4SyncFileEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4SyncFileEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4SyncFileEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4SyncFileExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4SyncFileExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4SyncFileExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4AllocateBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4AllocateBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4AllocateBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4AllocateInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4AllocateInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4AllocateInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4CollapseRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4CollapseRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4CollapseRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWritePagesFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWritePagesFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaWritePagesFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DirectIOEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DirectIOEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DirectIOEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DirectIOExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DirectIOExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DirectIOExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DiscardBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DiscardBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DiscardBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DropInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DropInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DropInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsCacheExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsCacheExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsCacheExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsInsertExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsInsertExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsInsertExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsShrinkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkCountFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkCountFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsShrinkCountFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EvictInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EvictInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EvictInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtInCacheFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtInCacheFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtInCacheFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRmIdxFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRmIdxFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtRmIdxFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRmLeafFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRmLeafFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtRmLeafFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtShowExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtShowExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtShowExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FallocateEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FallocateEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FallocateEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FallocateExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FallocateExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FallocateExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ForgetFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ForgetFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ForgetFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FreeBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FreeBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FreeBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FreeInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FreeInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FreeInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4InsertRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4InsertRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4InsertRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4InvalidatepageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4InvalidatepageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4InvalidatepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4JournalStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalStartReservedFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalStartReservedFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4JournalStartReservedFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4LoadInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4LoadInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4LoadInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbNewInodePaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbNewInodePaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbNewInodePaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocAllocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MballocAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocDiscardFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocDiscardFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MballocDiscardFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MballocFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocPreallocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocPreallocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MballocPreallocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4PunchHoleFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4PunchHoleFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4PunchHoleFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ReadpageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ReadpageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ReadpageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ReleasepageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ReleasepageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ReleasepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4RemoveBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4RemoveBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4RemoveBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4RequestBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4RequestBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4RequestBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4RequestInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4RequestInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4RequestInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4SyncFsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4SyncFsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4SyncFsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TrimAllFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TrimAllFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4TrimAllFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TrimExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TrimExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4TrimExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TruncateEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TruncateEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4TruncateEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TruncateExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TruncateExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4TruncateExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4UnlinkEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4UnlinkEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4UnlinkEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4UnlinkExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4UnlinkExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4UnlinkExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WriteBeginFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WriteBeginFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WriteBeginFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WriteEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WritepageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WritepageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WritepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WritepagesFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WritepagesFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WritepagesFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WritepagesResultFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WritepagesResultFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WritepagesResultFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ZeroRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ZeroRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ZeroRangeFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
