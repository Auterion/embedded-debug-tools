// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/kmem.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
namespace perfetto {
namespace protos {
class AllocPagesIommuEndFtraceEvent;
struct AllocPagesIommuEndFtraceEventDefaultTypeInternal;
extern AllocPagesIommuEndFtraceEventDefaultTypeInternal _AllocPagesIommuEndFtraceEvent_default_instance_;
class AllocPagesIommuFailFtraceEvent;
struct AllocPagesIommuFailFtraceEventDefaultTypeInternal;
extern AllocPagesIommuFailFtraceEventDefaultTypeInternal _AllocPagesIommuFailFtraceEvent_default_instance_;
class AllocPagesIommuStartFtraceEvent;
struct AllocPagesIommuStartFtraceEventDefaultTypeInternal;
extern AllocPagesIommuStartFtraceEventDefaultTypeInternal _AllocPagesIommuStartFtraceEvent_default_instance_;
class AllocPagesSysEndFtraceEvent;
struct AllocPagesSysEndFtraceEventDefaultTypeInternal;
extern AllocPagesSysEndFtraceEventDefaultTypeInternal _AllocPagesSysEndFtraceEvent_default_instance_;
class AllocPagesSysFailFtraceEvent;
struct AllocPagesSysFailFtraceEventDefaultTypeInternal;
extern AllocPagesSysFailFtraceEventDefaultTypeInternal _AllocPagesSysFailFtraceEvent_default_instance_;
class AllocPagesSysStartFtraceEvent;
struct AllocPagesSysStartFtraceEventDefaultTypeInternal;
extern AllocPagesSysStartFtraceEventDefaultTypeInternal _AllocPagesSysStartFtraceEvent_default_instance_;
class DmaAllocContiguousRetryFtraceEvent;
struct DmaAllocContiguousRetryFtraceEventDefaultTypeInternal;
extern DmaAllocContiguousRetryFtraceEventDefaultTypeInternal _DmaAllocContiguousRetryFtraceEvent_default_instance_;
class IommuMapRangeFtraceEvent;
struct IommuMapRangeFtraceEventDefaultTypeInternal;
extern IommuMapRangeFtraceEventDefaultTypeInternal _IommuMapRangeFtraceEvent_default_instance_;
class IommuSecPtblMapRangeEndFtraceEvent;
struct IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal;
extern IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal _IommuSecPtblMapRangeEndFtraceEvent_default_instance_;
class IommuSecPtblMapRangeStartFtraceEvent;
struct IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal;
extern IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal _IommuSecPtblMapRangeStartFtraceEvent_default_instance_;
class IonAllocBufferEndFtraceEvent;
struct IonAllocBufferEndFtraceEventDefaultTypeInternal;
extern IonAllocBufferEndFtraceEventDefaultTypeInternal _IonAllocBufferEndFtraceEvent_default_instance_;
class IonAllocBufferFailFtraceEvent;
struct IonAllocBufferFailFtraceEventDefaultTypeInternal;
extern IonAllocBufferFailFtraceEventDefaultTypeInternal _IonAllocBufferFailFtraceEvent_default_instance_;
class IonAllocBufferFallbackFtraceEvent;
struct IonAllocBufferFallbackFtraceEventDefaultTypeInternal;
extern IonAllocBufferFallbackFtraceEventDefaultTypeInternal _IonAllocBufferFallbackFtraceEvent_default_instance_;
class IonAllocBufferStartFtraceEvent;
struct IonAllocBufferStartFtraceEventDefaultTypeInternal;
extern IonAllocBufferStartFtraceEventDefaultTypeInternal _IonAllocBufferStartFtraceEvent_default_instance_;
class IonBufferCreateFtraceEvent;
struct IonBufferCreateFtraceEventDefaultTypeInternal;
extern IonBufferCreateFtraceEventDefaultTypeInternal _IonBufferCreateFtraceEvent_default_instance_;
class IonBufferDestroyFtraceEvent;
struct IonBufferDestroyFtraceEventDefaultTypeInternal;
extern IonBufferDestroyFtraceEventDefaultTypeInternal _IonBufferDestroyFtraceEvent_default_instance_;
class IonCpAllocRetryFtraceEvent;
struct IonCpAllocRetryFtraceEventDefaultTypeInternal;
extern IonCpAllocRetryFtraceEventDefaultTypeInternal _IonCpAllocRetryFtraceEvent_default_instance_;
class IonCpSecureBufferEndFtraceEvent;
struct IonCpSecureBufferEndFtraceEventDefaultTypeInternal;
extern IonCpSecureBufferEndFtraceEventDefaultTypeInternal _IonCpSecureBufferEndFtraceEvent_default_instance_;
class IonCpSecureBufferStartFtraceEvent;
struct IonCpSecureBufferStartFtraceEventDefaultTypeInternal;
extern IonCpSecureBufferStartFtraceEventDefaultTypeInternal _IonCpSecureBufferStartFtraceEvent_default_instance_;
class IonHeapGrowFtraceEvent;
struct IonHeapGrowFtraceEventDefaultTypeInternal;
extern IonHeapGrowFtraceEventDefaultTypeInternal _IonHeapGrowFtraceEvent_default_instance_;
class IonHeapShrinkFtraceEvent;
struct IonHeapShrinkFtraceEventDefaultTypeInternal;
extern IonHeapShrinkFtraceEventDefaultTypeInternal _IonHeapShrinkFtraceEvent_default_instance_;
class IonPrefetchingFtraceEvent;
struct IonPrefetchingFtraceEventDefaultTypeInternal;
extern IonPrefetchingFtraceEventDefaultTypeInternal _IonPrefetchingFtraceEvent_default_instance_;
class IonSecureCmaAddToPoolEndFtraceEvent;
struct IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal;
extern IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal _IonSecureCmaAddToPoolEndFtraceEvent_default_instance_;
class IonSecureCmaAddToPoolStartFtraceEvent;
struct IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal;
extern IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal _IonSecureCmaAddToPoolStartFtraceEvent_default_instance_;
class IonSecureCmaAllocateEndFtraceEvent;
struct IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal;
extern IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal _IonSecureCmaAllocateEndFtraceEvent_default_instance_;
class IonSecureCmaAllocateStartFtraceEvent;
struct IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal;
extern IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal _IonSecureCmaAllocateStartFtraceEvent_default_instance_;
class IonSecureCmaShrinkPoolEndFtraceEvent;
struct IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal;
extern IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal _IonSecureCmaShrinkPoolEndFtraceEvent_default_instance_;
class IonSecureCmaShrinkPoolStartFtraceEvent;
struct IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal;
extern IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal _IonSecureCmaShrinkPoolStartFtraceEvent_default_instance_;
class KfreeFtraceEvent;
struct KfreeFtraceEventDefaultTypeInternal;
extern KfreeFtraceEventDefaultTypeInternal _KfreeFtraceEvent_default_instance_;
class KmallocFtraceEvent;
struct KmallocFtraceEventDefaultTypeInternal;
extern KmallocFtraceEventDefaultTypeInternal _KmallocFtraceEvent_default_instance_;
class KmallocNodeFtraceEvent;
struct KmallocNodeFtraceEventDefaultTypeInternal;
extern KmallocNodeFtraceEventDefaultTypeInternal _KmallocNodeFtraceEvent_default_instance_;
class KmemCacheAllocFtraceEvent;
struct KmemCacheAllocFtraceEventDefaultTypeInternal;
extern KmemCacheAllocFtraceEventDefaultTypeInternal _KmemCacheAllocFtraceEvent_default_instance_;
class KmemCacheAllocNodeFtraceEvent;
struct KmemCacheAllocNodeFtraceEventDefaultTypeInternal;
extern KmemCacheAllocNodeFtraceEventDefaultTypeInternal _KmemCacheAllocNodeFtraceEvent_default_instance_;
class KmemCacheFreeFtraceEvent;
struct KmemCacheFreeFtraceEventDefaultTypeInternal;
extern KmemCacheFreeFtraceEventDefaultTypeInternal _KmemCacheFreeFtraceEvent_default_instance_;
class MigratePagesEndFtraceEvent;
struct MigratePagesEndFtraceEventDefaultTypeInternal;
extern MigratePagesEndFtraceEventDefaultTypeInternal _MigratePagesEndFtraceEvent_default_instance_;
class MigratePagesStartFtraceEvent;
struct MigratePagesStartFtraceEventDefaultTypeInternal;
extern MigratePagesStartFtraceEventDefaultTypeInternal _MigratePagesStartFtraceEvent_default_instance_;
class MigrateRetryFtraceEvent;
struct MigrateRetryFtraceEventDefaultTypeInternal;
extern MigrateRetryFtraceEventDefaultTypeInternal _MigrateRetryFtraceEvent_default_instance_;
class MmPageAllocExtfragFtraceEvent;
struct MmPageAllocExtfragFtraceEventDefaultTypeInternal;
extern MmPageAllocExtfragFtraceEventDefaultTypeInternal _MmPageAllocExtfragFtraceEvent_default_instance_;
class MmPageAllocFtraceEvent;
struct MmPageAllocFtraceEventDefaultTypeInternal;
extern MmPageAllocFtraceEventDefaultTypeInternal _MmPageAllocFtraceEvent_default_instance_;
class MmPageAllocZoneLockedFtraceEvent;
struct MmPageAllocZoneLockedFtraceEventDefaultTypeInternal;
extern MmPageAllocZoneLockedFtraceEventDefaultTypeInternal _MmPageAllocZoneLockedFtraceEvent_default_instance_;
class MmPageFreeBatchedFtraceEvent;
struct MmPageFreeBatchedFtraceEventDefaultTypeInternal;
extern MmPageFreeBatchedFtraceEventDefaultTypeInternal _MmPageFreeBatchedFtraceEvent_default_instance_;
class MmPageFreeFtraceEvent;
struct MmPageFreeFtraceEventDefaultTypeInternal;
extern MmPageFreeFtraceEventDefaultTypeInternal _MmPageFreeFtraceEvent_default_instance_;
class MmPagePcpuDrainFtraceEvent;
struct MmPagePcpuDrainFtraceEventDefaultTypeInternal;
extern MmPagePcpuDrainFtraceEventDefaultTypeInternal _MmPagePcpuDrainFtraceEvent_default_instance_;
class RssStatFtraceEvent;
struct RssStatFtraceEventDefaultTypeInternal;
extern RssStatFtraceEventDefaultTypeInternal _RssStatFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template <>
::perfetto::protos::AllocPagesIommuEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesIommuEndFtraceEvent>(Arena*);
template <>
::perfetto::protos::AllocPagesIommuFailFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesIommuFailFtraceEvent>(Arena*);
template <>
::perfetto::protos::AllocPagesIommuStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesIommuStartFtraceEvent>(Arena*);
template <>
::perfetto::protos::AllocPagesSysEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesSysEndFtraceEvent>(Arena*);
template <>
::perfetto::protos::AllocPagesSysFailFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesSysFailFtraceEvent>(Arena*);
template <>
::perfetto::protos::AllocPagesSysStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::AllocPagesSysStartFtraceEvent>(Arena*);
template <>
::perfetto::protos::DmaAllocContiguousRetryFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::DmaAllocContiguousRetryFtraceEvent>(Arena*);
template <>
::perfetto::protos::IommuMapRangeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IommuMapRangeFtraceEvent>(Arena*);
template <>
::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent>(Arena*);
template <>
::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonAllocBufferEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonAllocBufferEndFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonAllocBufferFailFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonAllocBufferFailFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonAllocBufferFallbackFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonAllocBufferFallbackFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonAllocBufferStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonAllocBufferStartFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonBufferCreateFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonBufferCreateFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonBufferDestroyFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonBufferDestroyFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonCpAllocRetryFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonCpAllocRetryFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonCpSecureBufferEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonCpSecureBufferEndFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonCpSecureBufferStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonCpSecureBufferStartFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonHeapGrowFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonHeapGrowFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonHeapShrinkFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonHeapShrinkFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonPrefetchingFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonPrefetchingFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent>(Arena*);
template <>
::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent>(Arena*);
template <>
::perfetto::protos::KfreeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KfreeFtraceEvent>(Arena*);
template <>
::perfetto::protos::KmallocFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmallocFtraceEvent>(Arena*);
template <>
::perfetto::protos::KmallocNodeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmallocNodeFtraceEvent>(Arena*);
template <>
::perfetto::protos::KmemCacheAllocFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmemCacheAllocFtraceEvent>(Arena*);
template <>
::perfetto::protos::KmemCacheAllocNodeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmemCacheAllocNodeFtraceEvent>(Arena*);
template <>
::perfetto::protos::KmemCacheFreeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::KmemCacheFreeFtraceEvent>(Arena*);
template <>
::perfetto::protos::MigratePagesEndFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MigratePagesEndFtraceEvent>(Arena*);
template <>
::perfetto::protos::MigratePagesStartFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MigratePagesStartFtraceEvent>(Arena*);
template <>
::perfetto::protos::MigrateRetryFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MigrateRetryFtraceEvent>(Arena*);
template <>
::perfetto::protos::MmPageAllocExtfragFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageAllocExtfragFtraceEvent>(Arena*);
template <>
::perfetto::protos::MmPageAllocFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageAllocFtraceEvent>(Arena*);
template <>
::perfetto::protos::MmPageAllocZoneLockedFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageAllocZoneLockedFtraceEvent>(Arena*);
template <>
::perfetto::protos::MmPageFreeBatchedFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageFreeBatchedFtraceEvent>(Arena*);
template <>
::perfetto::protos::MmPageFreeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPageFreeFtraceEvent>(Arena*);
template <>
::perfetto::protos::MmPagePcpuDrainFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::MmPagePcpuDrainFtraceEvent>(Arena*);
template <>
::perfetto::protos::RssStatFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::RssStatFtraceEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace perfetto {
namespace protos {

// ===================================================================


// -------------------------------------------------------------------

class AllocPagesIommuEndFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesIommuEndFtraceEvent) */ {
 public:
  inline AllocPagesIommuEndFtraceEvent() : AllocPagesIommuEndFtraceEvent(nullptr) {}
  ~AllocPagesIommuEndFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocPagesIommuEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllocPagesIommuEndFtraceEvent(const AllocPagesIommuEndFtraceEvent& from);
  AllocPagesIommuEndFtraceEvent(AllocPagesIommuEndFtraceEvent&& from) noexcept
    : AllocPagesIommuEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesIommuEndFtraceEvent& operator=(const AllocPagesIommuEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesIommuEndFtraceEvent& operator=(AllocPagesIommuEndFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocPagesIommuEndFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocPagesIommuEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesIommuEndFtraceEvent*>(
               &_AllocPagesIommuEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AllocPagesIommuEndFtraceEvent& a, AllocPagesIommuEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesIommuEndFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocPagesIommuEndFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocPagesIommuEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocPagesIommuEndFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllocPagesIommuEndFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllocPagesIommuEndFtraceEvent& from) {
    AllocPagesIommuEndFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocPagesIommuEndFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.AllocPagesIommuEndFtraceEvent";
  }
  protected:
  explicit AllocPagesIommuEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesIommuEndFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t gfp_flags_;
    ::uint32_t order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class AllocPagesIommuFailFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesIommuFailFtraceEvent) */ {
 public:
  inline AllocPagesIommuFailFtraceEvent() : AllocPagesIommuFailFtraceEvent(nullptr) {}
  ~AllocPagesIommuFailFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocPagesIommuFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllocPagesIommuFailFtraceEvent(const AllocPagesIommuFailFtraceEvent& from);
  AllocPagesIommuFailFtraceEvent(AllocPagesIommuFailFtraceEvent&& from) noexcept
    : AllocPagesIommuFailFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesIommuFailFtraceEvent& operator=(const AllocPagesIommuFailFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesIommuFailFtraceEvent& operator=(AllocPagesIommuFailFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocPagesIommuFailFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocPagesIommuFailFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesIommuFailFtraceEvent*>(
               &_AllocPagesIommuFailFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AllocPagesIommuFailFtraceEvent& a, AllocPagesIommuFailFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesIommuFailFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocPagesIommuFailFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocPagesIommuFailFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocPagesIommuFailFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllocPagesIommuFailFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllocPagesIommuFailFtraceEvent& from) {
    AllocPagesIommuFailFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocPagesIommuFailFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.AllocPagesIommuFailFtraceEvent";
  }
  protected:
  explicit AllocPagesIommuFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesIommuFailFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t gfp_flags_;
    ::uint32_t order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class AllocPagesIommuStartFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesIommuStartFtraceEvent) */ {
 public:
  inline AllocPagesIommuStartFtraceEvent() : AllocPagesIommuStartFtraceEvent(nullptr) {}
  ~AllocPagesIommuStartFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocPagesIommuStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllocPagesIommuStartFtraceEvent(const AllocPagesIommuStartFtraceEvent& from);
  AllocPagesIommuStartFtraceEvent(AllocPagesIommuStartFtraceEvent&& from) noexcept
    : AllocPagesIommuStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesIommuStartFtraceEvent& operator=(const AllocPagesIommuStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesIommuStartFtraceEvent& operator=(AllocPagesIommuStartFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocPagesIommuStartFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocPagesIommuStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesIommuStartFtraceEvent*>(
               &_AllocPagesIommuStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AllocPagesIommuStartFtraceEvent& a, AllocPagesIommuStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesIommuStartFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocPagesIommuStartFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocPagesIommuStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocPagesIommuStartFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllocPagesIommuStartFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllocPagesIommuStartFtraceEvent& from) {
    AllocPagesIommuStartFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocPagesIommuStartFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.AllocPagesIommuStartFtraceEvent";
  }
  protected:
  explicit AllocPagesIommuStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesIommuStartFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t gfp_flags_;
    ::uint32_t order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class AllocPagesSysEndFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesSysEndFtraceEvent) */ {
 public:
  inline AllocPagesSysEndFtraceEvent() : AllocPagesSysEndFtraceEvent(nullptr) {}
  ~AllocPagesSysEndFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocPagesSysEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllocPagesSysEndFtraceEvent(const AllocPagesSysEndFtraceEvent& from);
  AllocPagesSysEndFtraceEvent(AllocPagesSysEndFtraceEvent&& from) noexcept
    : AllocPagesSysEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesSysEndFtraceEvent& operator=(const AllocPagesSysEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesSysEndFtraceEvent& operator=(AllocPagesSysEndFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocPagesSysEndFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocPagesSysEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesSysEndFtraceEvent*>(
               &_AllocPagesSysEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AllocPagesSysEndFtraceEvent& a, AllocPagesSysEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesSysEndFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocPagesSysEndFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocPagesSysEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocPagesSysEndFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllocPagesSysEndFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllocPagesSysEndFtraceEvent& from) {
    AllocPagesSysEndFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocPagesSysEndFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.AllocPagesSysEndFtraceEvent";
  }
  protected:
  explicit AllocPagesSysEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesSysEndFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t gfp_flags_;
    ::uint32_t order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class AllocPagesSysFailFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesSysFailFtraceEvent) */ {
 public:
  inline AllocPagesSysFailFtraceEvent() : AllocPagesSysFailFtraceEvent(nullptr) {}
  ~AllocPagesSysFailFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocPagesSysFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllocPagesSysFailFtraceEvent(const AllocPagesSysFailFtraceEvent& from);
  AllocPagesSysFailFtraceEvent(AllocPagesSysFailFtraceEvent&& from) noexcept
    : AllocPagesSysFailFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesSysFailFtraceEvent& operator=(const AllocPagesSysFailFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesSysFailFtraceEvent& operator=(AllocPagesSysFailFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocPagesSysFailFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocPagesSysFailFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesSysFailFtraceEvent*>(
               &_AllocPagesSysFailFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AllocPagesSysFailFtraceEvent& a, AllocPagesSysFailFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesSysFailFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocPagesSysFailFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocPagesSysFailFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocPagesSysFailFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllocPagesSysFailFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllocPagesSysFailFtraceEvent& from) {
    AllocPagesSysFailFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocPagesSysFailFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.AllocPagesSysFailFtraceEvent";
  }
  protected:
  explicit AllocPagesSysFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesSysFailFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t gfp_flags_;
    ::uint32_t order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class AllocPagesSysStartFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.AllocPagesSysStartFtraceEvent) */ {
 public:
  inline AllocPagesSysStartFtraceEvent() : AllocPagesSysStartFtraceEvent(nullptr) {}
  ~AllocPagesSysStartFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllocPagesSysStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllocPagesSysStartFtraceEvent(const AllocPagesSysStartFtraceEvent& from);
  AllocPagesSysStartFtraceEvent(AllocPagesSysStartFtraceEvent&& from) noexcept
    : AllocPagesSysStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline AllocPagesSysStartFtraceEvent& operator=(const AllocPagesSysStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocPagesSysStartFtraceEvent& operator=(AllocPagesSysStartFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocPagesSysStartFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocPagesSysStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const AllocPagesSysStartFtraceEvent*>(
               &_AllocPagesSysStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AllocPagesSysStartFtraceEvent& a, AllocPagesSysStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocPagesSysStartFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocPagesSysStartFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocPagesSysStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocPagesSysStartFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllocPagesSysStartFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllocPagesSysStartFtraceEvent& from) {
    AllocPagesSysStartFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocPagesSysStartFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.AllocPagesSysStartFtraceEvent";
  }
  protected:
  explicit AllocPagesSysStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.AllocPagesSysStartFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t gfp_flags_;
    ::uint32_t order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class DmaAllocContiguousRetryFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.DmaAllocContiguousRetryFtraceEvent) */ {
 public:
  inline DmaAllocContiguousRetryFtraceEvent() : DmaAllocContiguousRetryFtraceEvent(nullptr) {}
  ~DmaAllocContiguousRetryFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DmaAllocContiguousRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DmaAllocContiguousRetryFtraceEvent(const DmaAllocContiguousRetryFtraceEvent& from);
  DmaAllocContiguousRetryFtraceEvent(DmaAllocContiguousRetryFtraceEvent&& from) noexcept
    : DmaAllocContiguousRetryFtraceEvent() {
    *this = ::std::move(from);
  }

  inline DmaAllocContiguousRetryFtraceEvent& operator=(const DmaAllocContiguousRetryFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DmaAllocContiguousRetryFtraceEvent& operator=(DmaAllocContiguousRetryFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DmaAllocContiguousRetryFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DmaAllocContiguousRetryFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const DmaAllocContiguousRetryFtraceEvent*>(
               &_DmaAllocContiguousRetryFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DmaAllocContiguousRetryFtraceEvent& a, DmaAllocContiguousRetryFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DmaAllocContiguousRetryFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DmaAllocContiguousRetryFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DmaAllocContiguousRetryFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DmaAllocContiguousRetryFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DmaAllocContiguousRetryFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DmaAllocContiguousRetryFtraceEvent& from) {
    DmaAllocContiguousRetryFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DmaAllocContiguousRetryFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.DmaAllocContiguousRetryFtraceEvent";
  }
  protected:
  explicit DmaAllocContiguousRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriesFieldNumber = 1,
  };
  // optional int32 tries = 1;
  bool has_tries() const;
  void clear_tries() ;
  ::int32_t tries() const;
  void set_tries(::int32_t value);

  private:
  ::int32_t _internal_tries() const;
  void _internal_set_tries(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t tries_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IommuMapRangeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IommuMapRangeFtraceEvent) */ {
 public:
  inline IommuMapRangeFtraceEvent() : IommuMapRangeFtraceEvent(nullptr) {}
  ~IommuMapRangeFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IommuMapRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IommuMapRangeFtraceEvent(const IommuMapRangeFtraceEvent& from);
  IommuMapRangeFtraceEvent(IommuMapRangeFtraceEvent&& from) noexcept
    : IommuMapRangeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IommuMapRangeFtraceEvent& operator=(const IommuMapRangeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IommuMapRangeFtraceEvent& operator=(IommuMapRangeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IommuMapRangeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IommuMapRangeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IommuMapRangeFtraceEvent*>(
               &_IommuMapRangeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IommuMapRangeFtraceEvent& a, IommuMapRangeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IommuMapRangeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IommuMapRangeFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IommuMapRangeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IommuMapRangeFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IommuMapRangeFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IommuMapRangeFtraceEvent& from) {
    IommuMapRangeFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IommuMapRangeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IommuMapRangeFtraceEvent";
  }
  protected:
  explicit IommuMapRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkSizeFieldNumber = 1,
    kLenFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 4,
  };
  // optional uint64 chunk_size = 1;
  bool has_chunk_size() const;
  void clear_chunk_size() ;
  ::uint64_t chunk_size() const;
  void set_chunk_size(::uint64_t value);

  private:
  ::uint64_t _internal_chunk_size() const;
  void _internal_set_chunk_size(::uint64_t value);

  public:
  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional uint64 pa = 3;
  bool has_pa() const;
  void clear_pa() ;
  ::uint64_t pa() const;
  void set_pa(::uint64_t value);

  private:
  ::uint64_t _internal_pa() const;
  void _internal_set_pa(::uint64_t value);

  public:
  // optional uint64 va = 4;
  bool has_va() const;
  void clear_va() ;
  ::uint64_t va() const;
  void set_va(::uint64_t value);

  private:
  ::uint64_t _internal_va() const;
  void _internal_set_va(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IommuMapRangeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t chunk_size_;
    ::uint64_t len_;
    ::uint64_t pa_;
    ::uint64_t va_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IommuSecPtblMapRangeEndFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent) */ {
 public:
  inline IommuSecPtblMapRangeEndFtraceEvent() : IommuSecPtblMapRangeEndFtraceEvent(nullptr) {}
  ~IommuSecPtblMapRangeEndFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IommuSecPtblMapRangeEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IommuSecPtblMapRangeEndFtraceEvent(const IommuSecPtblMapRangeEndFtraceEvent& from);
  IommuSecPtblMapRangeEndFtraceEvent(IommuSecPtblMapRangeEndFtraceEvent&& from) noexcept
    : IommuSecPtblMapRangeEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IommuSecPtblMapRangeEndFtraceEvent& operator=(const IommuSecPtblMapRangeEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IommuSecPtblMapRangeEndFtraceEvent& operator=(IommuSecPtblMapRangeEndFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IommuSecPtblMapRangeEndFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IommuSecPtblMapRangeEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IommuSecPtblMapRangeEndFtraceEvent*>(
               &_IommuSecPtblMapRangeEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IommuSecPtblMapRangeEndFtraceEvent& a, IommuSecPtblMapRangeEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IommuSecPtblMapRangeEndFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IommuSecPtblMapRangeEndFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IommuSecPtblMapRangeEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IommuSecPtblMapRangeEndFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IommuSecPtblMapRangeEndFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IommuSecPtblMapRangeEndFtraceEvent& from) {
    IommuSecPtblMapRangeEndFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IommuSecPtblMapRangeEndFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent";
  }
  protected:
  explicit IommuSecPtblMapRangeEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 5,
    kSecIdFieldNumber = 4,
  };
  // optional uint64 len = 1;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional int32 num = 2;
  bool has_num() const;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // optional uint32 pa = 3;
  bool has_pa() const;
  void clear_pa() ;
  ::uint32_t pa() const;
  void set_pa(::uint32_t value);

  private:
  ::uint32_t _internal_pa() const;
  void _internal_set_pa(::uint32_t value);

  public:
  // optional uint64 va = 5;
  bool has_va() const;
  void clear_va() ;
  ::uint64_t va() const;
  void set_va(::uint64_t value);

  private:
  ::uint64_t _internal_va() const;
  void _internal_set_va(::uint64_t value);

  public:
  // optional int32 sec_id = 4;
  bool has_sec_id() const;
  void clear_sec_id() ;
  ::int32_t sec_id() const;
  void set_sec_id(::int32_t value);

  private:
  ::int32_t _internal_sec_id() const;
  void _internal_set_sec_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t len_;
    ::int32_t num_;
    ::uint32_t pa_;
    ::uint64_t va_;
    ::int32_t sec_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IommuSecPtblMapRangeStartFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent) */ {
 public:
  inline IommuSecPtblMapRangeStartFtraceEvent() : IommuSecPtblMapRangeStartFtraceEvent(nullptr) {}
  ~IommuSecPtblMapRangeStartFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IommuSecPtblMapRangeStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IommuSecPtblMapRangeStartFtraceEvent(const IommuSecPtblMapRangeStartFtraceEvent& from);
  IommuSecPtblMapRangeStartFtraceEvent(IommuSecPtblMapRangeStartFtraceEvent&& from) noexcept
    : IommuSecPtblMapRangeStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IommuSecPtblMapRangeStartFtraceEvent& operator=(const IommuSecPtblMapRangeStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IommuSecPtblMapRangeStartFtraceEvent& operator=(IommuSecPtblMapRangeStartFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IommuSecPtblMapRangeStartFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IommuSecPtblMapRangeStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IommuSecPtblMapRangeStartFtraceEvent*>(
               &_IommuSecPtblMapRangeStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IommuSecPtblMapRangeStartFtraceEvent& a, IommuSecPtblMapRangeStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IommuSecPtblMapRangeStartFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IommuSecPtblMapRangeStartFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IommuSecPtblMapRangeStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IommuSecPtblMapRangeStartFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IommuSecPtblMapRangeStartFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IommuSecPtblMapRangeStartFtraceEvent& from) {
    IommuSecPtblMapRangeStartFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IommuSecPtblMapRangeStartFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent";
  }
  protected:
  explicit IommuSecPtblMapRangeStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 5,
    kSecIdFieldNumber = 4,
  };
  // optional uint64 len = 1;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional int32 num = 2;
  bool has_num() const;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // optional uint32 pa = 3;
  bool has_pa() const;
  void clear_pa() ;
  ::uint32_t pa() const;
  void set_pa(::uint32_t value);

  private:
  ::uint32_t _internal_pa() const;
  void _internal_set_pa(::uint32_t value);

  public:
  // optional uint64 va = 5;
  bool has_va() const;
  void clear_va() ;
  ::uint64_t va() const;
  void set_va(::uint64_t value);

  private:
  ::uint64_t _internal_va() const;
  void _internal_set_va(::uint64_t value);

  public:
  // optional int32 sec_id = 4;
  bool has_sec_id() const;
  void clear_sec_id() ;
  ::int32_t sec_id() const;
  void set_sec_id(::int32_t value);

  private:
  ::int32_t _internal_sec_id() const;
  void _internal_set_sec_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t len_;
    ::int32_t num_;
    ::uint32_t pa_;
    ::uint64_t va_;
    ::int32_t sec_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonAllocBufferEndFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonAllocBufferEndFtraceEvent) */ {
 public:
  inline IonAllocBufferEndFtraceEvent() : IonAllocBufferEndFtraceEvent(nullptr) {}
  ~IonAllocBufferEndFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonAllocBufferEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonAllocBufferEndFtraceEvent(const IonAllocBufferEndFtraceEvent& from);
  IonAllocBufferEndFtraceEvent(IonAllocBufferEndFtraceEvent&& from) noexcept
    : IonAllocBufferEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonAllocBufferEndFtraceEvent& operator=(const IonAllocBufferEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonAllocBufferEndFtraceEvent& operator=(IonAllocBufferEndFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonAllocBufferEndFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonAllocBufferEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonAllocBufferEndFtraceEvent*>(
               &_IonAllocBufferEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(IonAllocBufferEndFtraceEvent& a, IonAllocBufferEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonAllocBufferEndFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonAllocBufferEndFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonAllocBufferEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonAllocBufferEndFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonAllocBufferEndFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonAllocBufferEndFtraceEvent& from) {
    IonAllocBufferEndFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonAllocBufferEndFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonAllocBufferEndFtraceEvent";
  }
  protected:
  explicit IonAllocBufferEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kHeapNameFieldNumber = 3,
    kFlagsFieldNumber = 2,
    kMaskFieldNumber = 5,
    kLenFieldNumber = 4,
  };
  // optional string client_name = 1;
  bool has_client_name() const;
  void clear_client_name() ;
  const std::string& client_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_name(Arg_&& arg, Args_... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* ptr);

  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(
      const std::string& value);
  std::string* _internal_mutable_client_name();

  public:
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional uint32 flags = 2;
  bool has_flags() const;
  void clear_flags() ;
  ::uint32_t flags() const;
  void set_flags(::uint32_t value);

  private:
  ::uint32_t _internal_flags() const;
  void _internal_set_flags(::uint32_t value);

  public:
  // optional uint32 mask = 5;
  bool has_mask() const;
  void clear_mask() ;
  ::uint32_t mask() const;
  void set_mask(::uint32_t value);

  private:
  ::uint32_t _internal_mask() const;
  void _internal_set_mask(::uint32_t value);

  public:
  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonAllocBufferEndFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::uint32_t flags_;
    ::uint32_t mask_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonAllocBufferFailFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonAllocBufferFailFtraceEvent) */ {
 public:
  inline IonAllocBufferFailFtraceEvent() : IonAllocBufferFailFtraceEvent(nullptr) {}
  ~IonAllocBufferFailFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonAllocBufferFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonAllocBufferFailFtraceEvent(const IonAllocBufferFailFtraceEvent& from);
  IonAllocBufferFailFtraceEvent(IonAllocBufferFailFtraceEvent&& from) noexcept
    : IonAllocBufferFailFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonAllocBufferFailFtraceEvent& operator=(const IonAllocBufferFailFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonAllocBufferFailFtraceEvent& operator=(IonAllocBufferFailFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonAllocBufferFailFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonAllocBufferFailFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonAllocBufferFailFtraceEvent*>(
               &_IonAllocBufferFailFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(IonAllocBufferFailFtraceEvent& a, IonAllocBufferFailFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonAllocBufferFailFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonAllocBufferFailFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonAllocBufferFailFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonAllocBufferFailFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonAllocBufferFailFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonAllocBufferFailFtraceEvent& from) {
    IonAllocBufferFailFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonAllocBufferFailFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonAllocBufferFailFtraceEvent";
  }
  protected:
  explicit IonAllocBufferFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kHeapNameFieldNumber = 4,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kMaskFieldNumber = 6,
    kLenFieldNumber = 5,
  };
  // optional string client_name = 1;
  bool has_client_name() const;
  void clear_client_name() ;
  const std::string& client_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_name(Arg_&& arg, Args_... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* ptr);

  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(
      const std::string& value);
  std::string* _internal_mutable_client_name();

  public:
  // optional string heap_name = 4;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional int64 error = 2;
  bool has_error() const;
  void clear_error() ;
  ::int64_t error() const;
  void set_error(::int64_t value);

  private:
  ::int64_t _internal_error() const;
  void _internal_set_error(::int64_t value);

  public:
  // optional uint32 flags = 3;
  bool has_flags() const;
  void clear_flags() ;
  ::uint32_t flags() const;
  void set_flags(::uint32_t value);

  private:
  ::uint32_t _internal_flags() const;
  void _internal_set_flags(::uint32_t value);

  public:
  // optional uint32 mask = 6;
  bool has_mask() const;
  void clear_mask() ;
  ::uint32_t mask() const;
  void set_mask(::uint32_t value);

  private:
  ::uint32_t _internal_mask() const;
  void _internal_set_mask(::uint32_t value);

  public:
  // optional uint64 len = 5;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonAllocBufferFailFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::int64_t error_;
    ::uint32_t flags_;
    ::uint32_t mask_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonAllocBufferFallbackFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonAllocBufferFallbackFtraceEvent) */ {
 public:
  inline IonAllocBufferFallbackFtraceEvent() : IonAllocBufferFallbackFtraceEvent(nullptr) {}
  ~IonAllocBufferFallbackFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonAllocBufferFallbackFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonAllocBufferFallbackFtraceEvent(const IonAllocBufferFallbackFtraceEvent& from);
  IonAllocBufferFallbackFtraceEvent(IonAllocBufferFallbackFtraceEvent&& from) noexcept
    : IonAllocBufferFallbackFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonAllocBufferFallbackFtraceEvent& operator=(const IonAllocBufferFallbackFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonAllocBufferFallbackFtraceEvent& operator=(IonAllocBufferFallbackFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonAllocBufferFallbackFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonAllocBufferFallbackFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonAllocBufferFallbackFtraceEvent*>(
               &_IonAllocBufferFallbackFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(IonAllocBufferFallbackFtraceEvent& a, IonAllocBufferFallbackFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonAllocBufferFallbackFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonAllocBufferFallbackFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonAllocBufferFallbackFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonAllocBufferFallbackFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonAllocBufferFallbackFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonAllocBufferFallbackFtraceEvent& from) {
    IonAllocBufferFallbackFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonAllocBufferFallbackFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonAllocBufferFallbackFtraceEvent";
  }
  protected:
  explicit IonAllocBufferFallbackFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kHeapNameFieldNumber = 4,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kMaskFieldNumber = 6,
    kLenFieldNumber = 5,
  };
  // optional string client_name = 1;
  bool has_client_name() const;
  void clear_client_name() ;
  const std::string& client_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_name(Arg_&& arg, Args_... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* ptr);

  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(
      const std::string& value);
  std::string* _internal_mutable_client_name();

  public:
  // optional string heap_name = 4;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional int64 error = 2;
  bool has_error() const;
  void clear_error() ;
  ::int64_t error() const;
  void set_error(::int64_t value);

  private:
  ::int64_t _internal_error() const;
  void _internal_set_error(::int64_t value);

  public:
  // optional uint32 flags = 3;
  bool has_flags() const;
  void clear_flags() ;
  ::uint32_t flags() const;
  void set_flags(::uint32_t value);

  private:
  ::uint32_t _internal_flags() const;
  void _internal_set_flags(::uint32_t value);

  public:
  // optional uint32 mask = 6;
  bool has_mask() const;
  void clear_mask() ;
  ::uint32_t mask() const;
  void set_mask(::uint32_t value);

  private:
  ::uint32_t _internal_mask() const;
  void _internal_set_mask(::uint32_t value);

  public:
  // optional uint64 len = 5;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::int64_t error_;
    ::uint32_t flags_;
    ::uint32_t mask_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonAllocBufferStartFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonAllocBufferStartFtraceEvent) */ {
 public:
  inline IonAllocBufferStartFtraceEvent() : IonAllocBufferStartFtraceEvent(nullptr) {}
  ~IonAllocBufferStartFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonAllocBufferStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonAllocBufferStartFtraceEvent(const IonAllocBufferStartFtraceEvent& from);
  IonAllocBufferStartFtraceEvent(IonAllocBufferStartFtraceEvent&& from) noexcept
    : IonAllocBufferStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonAllocBufferStartFtraceEvent& operator=(const IonAllocBufferStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonAllocBufferStartFtraceEvent& operator=(IonAllocBufferStartFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonAllocBufferStartFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonAllocBufferStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonAllocBufferStartFtraceEvent*>(
               &_IonAllocBufferStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IonAllocBufferStartFtraceEvent& a, IonAllocBufferStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonAllocBufferStartFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonAllocBufferStartFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonAllocBufferStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonAllocBufferStartFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonAllocBufferStartFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonAllocBufferStartFtraceEvent& from) {
    IonAllocBufferStartFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonAllocBufferStartFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonAllocBufferStartFtraceEvent";
  }
  protected:
  explicit IonAllocBufferStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kHeapNameFieldNumber = 3,
    kFlagsFieldNumber = 2,
    kMaskFieldNumber = 5,
    kLenFieldNumber = 4,
  };
  // optional string client_name = 1;
  bool has_client_name() const;
  void clear_client_name() ;
  const std::string& client_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_name(Arg_&& arg, Args_... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* ptr);

  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(
      const std::string& value);
  std::string* _internal_mutable_client_name();

  public:
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional uint32 flags = 2;
  bool has_flags() const;
  void clear_flags() ;
  ::uint32_t flags() const;
  void set_flags(::uint32_t value);

  private:
  ::uint32_t _internal_flags() const;
  void _internal_set_flags(::uint32_t value);

  public:
  // optional uint32 mask = 5;
  bool has_mask() const;
  void clear_mask() ;
  ::uint32_t mask() const;
  void set_mask(::uint32_t value);

  private:
  ::uint32_t _internal_mask() const;
  void _internal_set_mask(::uint32_t value);

  public:
  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonAllocBufferStartFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::uint32_t flags_;
    ::uint32_t mask_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonCpAllocRetryFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonCpAllocRetryFtraceEvent) */ {
 public:
  inline IonCpAllocRetryFtraceEvent() : IonCpAllocRetryFtraceEvent(nullptr) {}
  ~IonCpAllocRetryFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonCpAllocRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonCpAllocRetryFtraceEvent(const IonCpAllocRetryFtraceEvent& from);
  IonCpAllocRetryFtraceEvent(IonCpAllocRetryFtraceEvent&& from) noexcept
    : IonCpAllocRetryFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonCpAllocRetryFtraceEvent& operator=(const IonCpAllocRetryFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonCpAllocRetryFtraceEvent& operator=(IonCpAllocRetryFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonCpAllocRetryFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonCpAllocRetryFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonCpAllocRetryFtraceEvent*>(
               &_IonCpAllocRetryFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(IonCpAllocRetryFtraceEvent& a, IonCpAllocRetryFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonCpAllocRetryFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonCpAllocRetryFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonCpAllocRetryFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonCpAllocRetryFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonCpAllocRetryFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonCpAllocRetryFtraceEvent& from) {
    IonCpAllocRetryFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonCpAllocRetryFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonCpAllocRetryFtraceEvent";
  }
  protected:
  explicit IonCpAllocRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriesFieldNumber = 1,
  };
  // optional int32 tries = 1;
  bool has_tries() const;
  void clear_tries() ;
  ::int32_t tries() const;
  void set_tries(::int32_t value);

  private:
  ::int32_t _internal_tries() const;
  void _internal_set_tries(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonCpAllocRetryFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t tries_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonCpSecureBufferEndFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonCpSecureBufferEndFtraceEvent) */ {
 public:
  inline IonCpSecureBufferEndFtraceEvent() : IonCpSecureBufferEndFtraceEvent(nullptr) {}
  ~IonCpSecureBufferEndFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonCpSecureBufferEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonCpSecureBufferEndFtraceEvent(const IonCpSecureBufferEndFtraceEvent& from);
  IonCpSecureBufferEndFtraceEvent(IonCpSecureBufferEndFtraceEvent&& from) noexcept
    : IonCpSecureBufferEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonCpSecureBufferEndFtraceEvent& operator=(const IonCpSecureBufferEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonCpSecureBufferEndFtraceEvent& operator=(IonCpSecureBufferEndFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonCpSecureBufferEndFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonCpSecureBufferEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonCpSecureBufferEndFtraceEvent*>(
               &_IonCpSecureBufferEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(IonCpSecureBufferEndFtraceEvent& a, IonCpSecureBufferEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonCpSecureBufferEndFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonCpSecureBufferEndFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonCpSecureBufferEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonCpSecureBufferEndFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonCpSecureBufferEndFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonCpSecureBufferEndFtraceEvent& from) {
    IonCpSecureBufferEndFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonCpSecureBufferEndFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonCpSecureBufferEndFtraceEvent";
  }
  protected:
  explicit IonCpSecureBufferEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 3,
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLenFieldNumber = 4,
  };
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional uint64 align = 1;
  bool has_align() const;
  void clear_align() ;
  ::uint64_t align() const;
  void set_align(::uint64_t value);

  private:
  ::uint64_t _internal_align() const;
  void _internal_set_align(::uint64_t value);

  public:
  // optional uint64 flags = 2;
  bool has_flags() const;
  void clear_flags() ;
  ::uint64_t flags() const;
  void set_flags(::uint64_t value);

  private:
  ::uint64_t _internal_flags() const;
  void _internal_set_flags(::uint64_t value);

  public:
  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::uint64_t align_;
    ::uint64_t flags_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonCpSecureBufferStartFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonCpSecureBufferStartFtraceEvent) */ {
 public:
  inline IonCpSecureBufferStartFtraceEvent() : IonCpSecureBufferStartFtraceEvent(nullptr) {}
  ~IonCpSecureBufferStartFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonCpSecureBufferStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonCpSecureBufferStartFtraceEvent(const IonCpSecureBufferStartFtraceEvent& from);
  IonCpSecureBufferStartFtraceEvent(IonCpSecureBufferStartFtraceEvent&& from) noexcept
    : IonCpSecureBufferStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonCpSecureBufferStartFtraceEvent& operator=(const IonCpSecureBufferStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonCpSecureBufferStartFtraceEvent& operator=(IonCpSecureBufferStartFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonCpSecureBufferStartFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonCpSecureBufferStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonCpSecureBufferStartFtraceEvent*>(
               &_IonCpSecureBufferStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(IonCpSecureBufferStartFtraceEvent& a, IonCpSecureBufferStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonCpSecureBufferStartFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonCpSecureBufferStartFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonCpSecureBufferStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonCpSecureBufferStartFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonCpSecureBufferStartFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonCpSecureBufferStartFtraceEvent& from) {
    IonCpSecureBufferStartFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonCpSecureBufferStartFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonCpSecureBufferStartFtraceEvent";
  }
  protected:
  explicit IonCpSecureBufferStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 3,
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLenFieldNumber = 4,
  };
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional uint64 align = 1;
  bool has_align() const;
  void clear_align() ;
  ::uint64_t align() const;
  void set_align(::uint64_t value);

  private:
  ::uint64_t _internal_align() const;
  void _internal_set_align(::uint64_t value);

  public:
  // optional uint64 flags = 2;
  bool has_flags() const;
  void clear_flags() ;
  ::uint64_t flags() const;
  void set_flags(::uint64_t value);

  private:
  ::uint64_t _internal_flags() const;
  void _internal_set_flags(::uint64_t value);

  public:
  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::uint64_t align_;
    ::uint64_t flags_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonPrefetchingFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonPrefetchingFtraceEvent) */ {
 public:
  inline IonPrefetchingFtraceEvent() : IonPrefetchingFtraceEvent(nullptr) {}
  ~IonPrefetchingFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonPrefetchingFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonPrefetchingFtraceEvent(const IonPrefetchingFtraceEvent& from);
  IonPrefetchingFtraceEvent(IonPrefetchingFtraceEvent&& from) noexcept
    : IonPrefetchingFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonPrefetchingFtraceEvent& operator=(const IonPrefetchingFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonPrefetchingFtraceEvent& operator=(IonPrefetchingFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonPrefetchingFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonPrefetchingFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonPrefetchingFtraceEvent*>(
               &_IonPrefetchingFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(IonPrefetchingFtraceEvent& a, IonPrefetchingFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonPrefetchingFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonPrefetchingFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonPrefetchingFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonPrefetchingFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonPrefetchingFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonPrefetchingFtraceEvent& from) {
    IonPrefetchingFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonPrefetchingFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonPrefetchingFtraceEvent";
  }
  protected:
  explicit IonPrefetchingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 1,
  };
  // optional uint64 len = 1;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonPrefetchingFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonSecureCmaAddToPoolEndFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent) */ {
 public:
  inline IonSecureCmaAddToPoolEndFtraceEvent() : IonSecureCmaAddToPoolEndFtraceEvent(nullptr) {}
  ~IonSecureCmaAddToPoolEndFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonSecureCmaAddToPoolEndFtraceEvent(const IonSecureCmaAddToPoolEndFtraceEvent& from);
  IonSecureCmaAddToPoolEndFtraceEvent(IonSecureCmaAddToPoolEndFtraceEvent&& from) noexcept
    : IonSecureCmaAddToPoolEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaAddToPoolEndFtraceEvent& operator=(const IonSecureCmaAddToPoolEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaAddToPoolEndFtraceEvent& operator=(IonSecureCmaAddToPoolEndFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonSecureCmaAddToPoolEndFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonSecureCmaAddToPoolEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaAddToPoolEndFtraceEvent*>(
               &_IonSecureCmaAddToPoolEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(IonSecureCmaAddToPoolEndFtraceEvent& a, IonSecureCmaAddToPoolEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaAddToPoolEndFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonSecureCmaAddToPoolEndFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonSecureCmaAddToPoolEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonSecureCmaAddToPoolEndFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonSecureCmaAddToPoolEndFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonSecureCmaAddToPoolEndFtraceEvent& from) {
    IonSecureCmaAddToPoolEndFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonSecureCmaAddToPoolEndFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent";
  }
  protected:
  explicit IonSecureCmaAddToPoolEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 2,
    kIsPrefetchFieldNumber = 1,
    kPoolTotalFieldNumber = 3,
  };
  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional uint32 is_prefetch = 1;
  bool has_is_prefetch() const;
  void clear_is_prefetch() ;
  ::uint32_t is_prefetch() const;
  void set_is_prefetch(::uint32_t value);

  private:
  ::uint32_t _internal_is_prefetch() const;
  void _internal_set_is_prefetch(::uint32_t value);

  public:
  // optional int32 pool_total = 3;
  bool has_pool_total() const;
  void clear_pool_total() ;
  ::int32_t pool_total() const;
  void set_pool_total(::int32_t value);

  private:
  ::int32_t _internal_pool_total() const;
  void _internal_set_pool_total(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t len_;
    ::uint32_t is_prefetch_;
    ::int32_t pool_total_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonSecureCmaAddToPoolStartFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent) */ {
 public:
  inline IonSecureCmaAddToPoolStartFtraceEvent() : IonSecureCmaAddToPoolStartFtraceEvent(nullptr) {}
  ~IonSecureCmaAddToPoolStartFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonSecureCmaAddToPoolStartFtraceEvent(const IonSecureCmaAddToPoolStartFtraceEvent& from);
  IonSecureCmaAddToPoolStartFtraceEvent(IonSecureCmaAddToPoolStartFtraceEvent&& from) noexcept
    : IonSecureCmaAddToPoolStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaAddToPoolStartFtraceEvent& operator=(const IonSecureCmaAddToPoolStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaAddToPoolStartFtraceEvent& operator=(IonSecureCmaAddToPoolStartFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonSecureCmaAddToPoolStartFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonSecureCmaAddToPoolStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaAddToPoolStartFtraceEvent*>(
               &_IonSecureCmaAddToPoolStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(IonSecureCmaAddToPoolStartFtraceEvent& a, IonSecureCmaAddToPoolStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaAddToPoolStartFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonSecureCmaAddToPoolStartFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonSecureCmaAddToPoolStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonSecureCmaAddToPoolStartFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonSecureCmaAddToPoolStartFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonSecureCmaAddToPoolStartFtraceEvent& from) {
    IonSecureCmaAddToPoolStartFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonSecureCmaAddToPoolStartFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent";
  }
  protected:
  explicit IonSecureCmaAddToPoolStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 2,
    kIsPrefetchFieldNumber = 1,
    kPoolTotalFieldNumber = 3,
  };
  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional uint32 is_prefetch = 1;
  bool has_is_prefetch() const;
  void clear_is_prefetch() ;
  ::uint32_t is_prefetch() const;
  void set_is_prefetch(::uint32_t value);

  private:
  ::uint32_t _internal_is_prefetch() const;
  void _internal_set_is_prefetch(::uint32_t value);

  public:
  // optional int32 pool_total = 3;
  bool has_pool_total() const;
  void clear_pool_total() ;
  ::int32_t pool_total() const;
  void set_pool_total(::int32_t value);

  private:
  ::int32_t _internal_pool_total() const;
  void _internal_set_pool_total(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t len_;
    ::uint32_t is_prefetch_;
    ::int32_t pool_total_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonSecureCmaAllocateEndFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent) */ {
 public:
  inline IonSecureCmaAllocateEndFtraceEvent() : IonSecureCmaAllocateEndFtraceEvent(nullptr) {}
  ~IonSecureCmaAllocateEndFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonSecureCmaAllocateEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonSecureCmaAllocateEndFtraceEvent(const IonSecureCmaAllocateEndFtraceEvent& from);
  IonSecureCmaAllocateEndFtraceEvent(IonSecureCmaAllocateEndFtraceEvent&& from) noexcept
    : IonSecureCmaAllocateEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaAllocateEndFtraceEvent& operator=(const IonSecureCmaAllocateEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaAllocateEndFtraceEvent& operator=(IonSecureCmaAllocateEndFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonSecureCmaAllocateEndFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonSecureCmaAllocateEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaAllocateEndFtraceEvent*>(
               &_IonSecureCmaAllocateEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(IonSecureCmaAllocateEndFtraceEvent& a, IonSecureCmaAllocateEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaAllocateEndFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonSecureCmaAllocateEndFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonSecureCmaAllocateEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonSecureCmaAllocateEndFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonSecureCmaAllocateEndFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonSecureCmaAllocateEndFtraceEvent& from) {
    IonSecureCmaAllocateEndFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonSecureCmaAllocateEndFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonSecureCmaAllocateEndFtraceEvent";
  }
  protected:
  explicit IonSecureCmaAllocateEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 3,
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLenFieldNumber = 4,
  };
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional uint64 align = 1;
  bool has_align() const;
  void clear_align() ;
  ::uint64_t align() const;
  void set_align(::uint64_t value);

  private:
  ::uint64_t _internal_align() const;
  void _internal_set_align(::uint64_t value);

  public:
  // optional uint64 flags = 2;
  bool has_flags() const;
  void clear_flags() ;
  ::uint64_t flags() const;
  void set_flags(::uint64_t value);

  private:
  ::uint64_t _internal_flags() const;
  void _internal_set_flags(::uint64_t value);

  public:
  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::uint64_t align_;
    ::uint64_t flags_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonSecureCmaAllocateStartFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent) */ {
 public:
  inline IonSecureCmaAllocateStartFtraceEvent() : IonSecureCmaAllocateStartFtraceEvent(nullptr) {}
  ~IonSecureCmaAllocateStartFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonSecureCmaAllocateStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonSecureCmaAllocateStartFtraceEvent(const IonSecureCmaAllocateStartFtraceEvent& from);
  IonSecureCmaAllocateStartFtraceEvent(IonSecureCmaAllocateStartFtraceEvent&& from) noexcept
    : IonSecureCmaAllocateStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaAllocateStartFtraceEvent& operator=(const IonSecureCmaAllocateStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaAllocateStartFtraceEvent& operator=(IonSecureCmaAllocateStartFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonSecureCmaAllocateStartFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonSecureCmaAllocateStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaAllocateStartFtraceEvent*>(
               &_IonSecureCmaAllocateStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(IonSecureCmaAllocateStartFtraceEvent& a, IonSecureCmaAllocateStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaAllocateStartFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonSecureCmaAllocateStartFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonSecureCmaAllocateStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonSecureCmaAllocateStartFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonSecureCmaAllocateStartFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonSecureCmaAllocateStartFtraceEvent& from) {
    IonSecureCmaAllocateStartFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonSecureCmaAllocateStartFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonSecureCmaAllocateStartFtraceEvent";
  }
  protected:
  explicit IonSecureCmaAllocateStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 3,
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLenFieldNumber = 4,
  };
  // optional string heap_name = 3;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional uint64 align = 1;
  bool has_align() const;
  void clear_align() ;
  ::uint64_t align() const;
  void set_align(::uint64_t value);

  private:
  ::uint64_t _internal_align() const;
  void _internal_set_align(::uint64_t value);

  public:
  // optional uint64 flags = 2;
  bool has_flags() const;
  void clear_flags() ;
  ::uint64_t flags() const;
  void set_flags(::uint64_t value);

  private:
  ::uint64_t _internal_flags() const;
  void _internal_set_flags(::uint64_t value);

  public:
  // optional uint64 len = 4;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::uint64_t align_;
    ::uint64_t flags_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonSecureCmaShrinkPoolEndFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent) */ {
 public:
  inline IonSecureCmaShrinkPoolEndFtraceEvent() : IonSecureCmaShrinkPoolEndFtraceEvent(nullptr) {}
  ~IonSecureCmaShrinkPoolEndFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonSecureCmaShrinkPoolEndFtraceEvent(const IonSecureCmaShrinkPoolEndFtraceEvent& from);
  IonSecureCmaShrinkPoolEndFtraceEvent(IonSecureCmaShrinkPoolEndFtraceEvent&& from) noexcept
    : IonSecureCmaShrinkPoolEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaShrinkPoolEndFtraceEvent& operator=(const IonSecureCmaShrinkPoolEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaShrinkPoolEndFtraceEvent& operator=(IonSecureCmaShrinkPoolEndFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonSecureCmaShrinkPoolEndFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonSecureCmaShrinkPoolEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaShrinkPoolEndFtraceEvent*>(
               &_IonSecureCmaShrinkPoolEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(IonSecureCmaShrinkPoolEndFtraceEvent& a, IonSecureCmaShrinkPoolEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaShrinkPoolEndFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonSecureCmaShrinkPoolEndFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonSecureCmaShrinkPoolEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonSecureCmaShrinkPoolEndFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonSecureCmaShrinkPoolEndFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonSecureCmaShrinkPoolEndFtraceEvent& from) {
    IonSecureCmaShrinkPoolEndFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonSecureCmaShrinkPoolEndFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent";
  }
  protected:
  explicit IonSecureCmaShrinkPoolEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  // optional uint64 drained_size = 1;
  bool has_drained_size() const;
  void clear_drained_size() ;
  ::uint64_t drained_size() const;
  void set_drained_size(::uint64_t value);

  private:
  ::uint64_t _internal_drained_size() const;
  void _internal_set_drained_size(::uint64_t value);

  public:
  // optional uint64 skipped_size = 2;
  bool has_skipped_size() const;
  void clear_skipped_size() ;
  ::uint64_t skipped_size() const;
  void set_skipped_size(::uint64_t value);

  private:
  ::uint64_t _internal_skipped_size() const;
  void _internal_set_skipped_size(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t drained_size_;
    ::uint64_t skipped_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonSecureCmaShrinkPoolStartFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent) */ {
 public:
  inline IonSecureCmaShrinkPoolStartFtraceEvent() : IonSecureCmaShrinkPoolStartFtraceEvent(nullptr) {}
  ~IonSecureCmaShrinkPoolStartFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonSecureCmaShrinkPoolStartFtraceEvent(const IonSecureCmaShrinkPoolStartFtraceEvent& from);
  IonSecureCmaShrinkPoolStartFtraceEvent(IonSecureCmaShrinkPoolStartFtraceEvent&& from) noexcept
    : IonSecureCmaShrinkPoolStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonSecureCmaShrinkPoolStartFtraceEvent& operator=(const IonSecureCmaShrinkPoolStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonSecureCmaShrinkPoolStartFtraceEvent& operator=(IonSecureCmaShrinkPoolStartFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonSecureCmaShrinkPoolStartFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonSecureCmaShrinkPoolStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonSecureCmaShrinkPoolStartFtraceEvent*>(
               &_IonSecureCmaShrinkPoolStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(IonSecureCmaShrinkPoolStartFtraceEvent& a, IonSecureCmaShrinkPoolStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonSecureCmaShrinkPoolStartFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonSecureCmaShrinkPoolStartFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonSecureCmaShrinkPoolStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonSecureCmaShrinkPoolStartFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonSecureCmaShrinkPoolStartFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonSecureCmaShrinkPoolStartFtraceEvent& from) {
    IonSecureCmaShrinkPoolStartFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonSecureCmaShrinkPoolStartFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent";
  }
  protected:
  explicit IonSecureCmaShrinkPoolStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  // optional uint64 drained_size = 1;
  bool has_drained_size() const;
  void clear_drained_size() ;
  ::uint64_t drained_size() const;
  void set_drained_size(::uint64_t value);

  private:
  ::uint64_t _internal_drained_size() const;
  void _internal_set_drained_size(::uint64_t value);

  public:
  // optional uint64 skipped_size = 2;
  bool has_skipped_size() const;
  void clear_skipped_size() ;
  ::uint64_t skipped_size() const;
  void set_skipped_size(::uint64_t value);

  private:
  ::uint64_t _internal_skipped_size() const;
  void _internal_set_skipped_size(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t drained_size_;
    ::uint64_t skipped_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class KfreeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.KfreeFtraceEvent) */ {
 public:
  inline KfreeFtraceEvent() : KfreeFtraceEvent(nullptr) {}
  ~KfreeFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KfreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KfreeFtraceEvent(const KfreeFtraceEvent& from);
  KfreeFtraceEvent(KfreeFtraceEvent&& from) noexcept
    : KfreeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KfreeFtraceEvent& operator=(const KfreeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KfreeFtraceEvent& operator=(KfreeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KfreeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KfreeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KfreeFtraceEvent*>(
               &_KfreeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(KfreeFtraceEvent& a, KfreeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KfreeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KfreeFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KfreeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KfreeFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KfreeFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KfreeFtraceEvent& from) {
    KfreeFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KfreeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.KfreeFtraceEvent";
  }
  protected:
  explicit KfreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  // optional uint64 call_site = 1;
  bool has_call_site() const;
  void clear_call_site() ;
  ::uint64_t call_site() const;
  void set_call_site(::uint64_t value);

  private:
  ::uint64_t _internal_call_site() const;
  void _internal_set_call_site(::uint64_t value);

  public:
  // optional uint64 ptr = 2;
  bool has_ptr() const;
  void clear_ptr() ;
  ::uint64_t ptr() const;
  void set_ptr(::uint64_t value);

  private:
  ::uint64_t _internal_ptr() const;
  void _internal_set_ptr(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.KfreeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t call_site_;
    ::uint64_t ptr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class KmallocFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.KmallocFtraceEvent) */ {
 public:
  inline KmallocFtraceEvent() : KmallocFtraceEvent(nullptr) {}
  ~KmallocFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KmallocFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KmallocFtraceEvent(const KmallocFtraceEvent& from);
  KmallocFtraceEvent(KmallocFtraceEvent&& from) noexcept
    : KmallocFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmallocFtraceEvent& operator=(const KmallocFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmallocFtraceEvent& operator=(KmallocFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KmallocFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KmallocFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmallocFtraceEvent*>(
               &_KmallocFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(KmallocFtraceEvent& a, KmallocFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmallocFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KmallocFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KmallocFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KmallocFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KmallocFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KmallocFtraceEvent& from) {
    KmallocFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KmallocFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.KmallocFtraceEvent";
  }
  protected:
  explicit KmallocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kPtrFieldNumber = 5,
    kGfpFlagsFieldNumber = 4,
  };
  // optional uint64 bytes_alloc = 1;
  bool has_bytes_alloc() const;
  void clear_bytes_alloc() ;
  ::uint64_t bytes_alloc() const;
  void set_bytes_alloc(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_alloc() const;
  void _internal_set_bytes_alloc(::uint64_t value);

  public:
  // optional uint64 bytes_req = 2;
  bool has_bytes_req() const;
  void clear_bytes_req() ;
  ::uint64_t bytes_req() const;
  void set_bytes_req(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_req() const;
  void _internal_set_bytes_req(::uint64_t value);

  public:
  // optional uint64 call_site = 3;
  bool has_call_site() const;
  void clear_call_site() ;
  ::uint64_t call_site() const;
  void set_call_site(::uint64_t value);

  private:
  ::uint64_t _internal_call_site() const;
  void _internal_set_call_site(::uint64_t value);

  public:
  // optional uint64 ptr = 5;
  bool has_ptr() const;
  void clear_ptr() ;
  ::uint64_t ptr() const;
  void set_ptr(::uint64_t value);

  private:
  ::uint64_t _internal_ptr() const;
  void _internal_set_ptr(::uint64_t value);

  public:
  // optional uint32 gfp_flags = 4;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.KmallocFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t bytes_alloc_;
    ::uint64_t bytes_req_;
    ::uint64_t call_site_;
    ::uint64_t ptr_;
    ::uint32_t gfp_flags_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class KmallocNodeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.KmallocNodeFtraceEvent) */ {
 public:
  inline KmallocNodeFtraceEvent() : KmallocNodeFtraceEvent(nullptr) {}
  ~KmallocNodeFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KmallocNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KmallocNodeFtraceEvent(const KmallocNodeFtraceEvent& from);
  KmallocNodeFtraceEvent(KmallocNodeFtraceEvent&& from) noexcept
    : KmallocNodeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmallocNodeFtraceEvent& operator=(const KmallocNodeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmallocNodeFtraceEvent& operator=(KmallocNodeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KmallocNodeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KmallocNodeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmallocNodeFtraceEvent*>(
               &_KmallocNodeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(KmallocNodeFtraceEvent& a, KmallocNodeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmallocNodeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KmallocNodeFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KmallocNodeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KmallocNodeFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KmallocNodeFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KmallocNodeFtraceEvent& from) {
    KmallocNodeFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KmallocNodeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.KmallocNodeFtraceEvent";
  }
  protected:
  explicit KmallocNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  // optional uint64 bytes_alloc = 1;
  bool has_bytes_alloc() const;
  void clear_bytes_alloc() ;
  ::uint64_t bytes_alloc() const;
  void set_bytes_alloc(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_alloc() const;
  void _internal_set_bytes_alloc(::uint64_t value);

  public:
  // optional uint64 bytes_req = 2;
  bool has_bytes_req() const;
  void clear_bytes_req() ;
  ::uint64_t bytes_req() const;
  void set_bytes_req(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_req() const;
  void _internal_set_bytes_req(::uint64_t value);

  public:
  // optional uint64 call_site = 3;
  bool has_call_site() const;
  void clear_call_site() ;
  ::uint64_t call_site() const;
  void set_call_site(::uint64_t value);

  private:
  ::uint64_t _internal_call_site() const;
  void _internal_set_call_site(::uint64_t value);

  public:
  // optional uint32 gfp_flags = 4;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // optional int32 node = 5;
  bool has_node() const;
  void clear_node() ;
  ::int32_t node() const;
  void set_node(::int32_t value);

  private:
  ::int32_t _internal_node() const;
  void _internal_set_node(::int32_t value);

  public:
  // optional uint64 ptr = 6;
  bool has_ptr() const;
  void clear_ptr() ;
  ::uint64_t ptr() const;
  void set_ptr(::uint64_t value);

  private:
  ::uint64_t _internal_ptr() const;
  void _internal_set_ptr(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.KmallocNodeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t bytes_alloc_;
    ::uint64_t bytes_req_;
    ::uint64_t call_site_;
    ::uint32_t gfp_flags_;
    ::int32_t node_;
    ::uint64_t ptr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class KmemCacheAllocFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.KmemCacheAllocFtraceEvent) */ {
 public:
  inline KmemCacheAllocFtraceEvent() : KmemCacheAllocFtraceEvent(nullptr) {}
  ~KmemCacheAllocFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KmemCacheAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KmemCacheAllocFtraceEvent(const KmemCacheAllocFtraceEvent& from);
  KmemCacheAllocFtraceEvent(KmemCacheAllocFtraceEvent&& from) noexcept
    : KmemCacheAllocFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmemCacheAllocFtraceEvent& operator=(const KmemCacheAllocFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmemCacheAllocFtraceEvent& operator=(KmemCacheAllocFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KmemCacheAllocFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KmemCacheAllocFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmemCacheAllocFtraceEvent*>(
               &_KmemCacheAllocFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(KmemCacheAllocFtraceEvent& a, KmemCacheAllocFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmemCacheAllocFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KmemCacheAllocFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KmemCacheAllocFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KmemCacheAllocFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KmemCacheAllocFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KmemCacheAllocFtraceEvent& from) {
    KmemCacheAllocFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KmemCacheAllocFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.KmemCacheAllocFtraceEvent";
  }
  protected:
  explicit KmemCacheAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kPtrFieldNumber = 5,
    kGfpFlagsFieldNumber = 4,
  };
  // optional uint64 bytes_alloc = 1;
  bool has_bytes_alloc() const;
  void clear_bytes_alloc() ;
  ::uint64_t bytes_alloc() const;
  void set_bytes_alloc(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_alloc() const;
  void _internal_set_bytes_alloc(::uint64_t value);

  public:
  // optional uint64 bytes_req = 2;
  bool has_bytes_req() const;
  void clear_bytes_req() ;
  ::uint64_t bytes_req() const;
  void set_bytes_req(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_req() const;
  void _internal_set_bytes_req(::uint64_t value);

  public:
  // optional uint64 call_site = 3;
  bool has_call_site() const;
  void clear_call_site() ;
  ::uint64_t call_site() const;
  void set_call_site(::uint64_t value);

  private:
  ::uint64_t _internal_call_site() const;
  void _internal_set_call_site(::uint64_t value);

  public:
  // optional uint64 ptr = 5;
  bool has_ptr() const;
  void clear_ptr() ;
  ::uint64_t ptr() const;
  void set_ptr(::uint64_t value);

  private:
  ::uint64_t _internal_ptr() const;
  void _internal_set_ptr(::uint64_t value);

  public:
  // optional uint32 gfp_flags = 4;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.KmemCacheAllocFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t bytes_alloc_;
    ::uint64_t bytes_req_;
    ::uint64_t call_site_;
    ::uint64_t ptr_;
    ::uint32_t gfp_flags_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class KmemCacheAllocNodeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.KmemCacheAllocNodeFtraceEvent) */ {
 public:
  inline KmemCacheAllocNodeFtraceEvent() : KmemCacheAllocNodeFtraceEvent(nullptr) {}
  ~KmemCacheAllocNodeFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KmemCacheAllocNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KmemCacheAllocNodeFtraceEvent(const KmemCacheAllocNodeFtraceEvent& from);
  KmemCacheAllocNodeFtraceEvent(KmemCacheAllocNodeFtraceEvent&& from) noexcept
    : KmemCacheAllocNodeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmemCacheAllocNodeFtraceEvent& operator=(const KmemCacheAllocNodeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmemCacheAllocNodeFtraceEvent& operator=(KmemCacheAllocNodeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KmemCacheAllocNodeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KmemCacheAllocNodeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmemCacheAllocNodeFtraceEvent*>(
               &_KmemCacheAllocNodeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(KmemCacheAllocNodeFtraceEvent& a, KmemCacheAllocNodeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmemCacheAllocNodeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KmemCacheAllocNodeFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KmemCacheAllocNodeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KmemCacheAllocNodeFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KmemCacheAllocNodeFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KmemCacheAllocNodeFtraceEvent& from) {
    KmemCacheAllocNodeFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KmemCacheAllocNodeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.KmemCacheAllocNodeFtraceEvent";
  }
  protected:
  explicit KmemCacheAllocNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  // optional uint64 bytes_alloc = 1;
  bool has_bytes_alloc() const;
  void clear_bytes_alloc() ;
  ::uint64_t bytes_alloc() const;
  void set_bytes_alloc(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_alloc() const;
  void _internal_set_bytes_alloc(::uint64_t value);

  public:
  // optional uint64 bytes_req = 2;
  bool has_bytes_req() const;
  void clear_bytes_req() ;
  ::uint64_t bytes_req() const;
  void set_bytes_req(::uint64_t value);

  private:
  ::uint64_t _internal_bytes_req() const;
  void _internal_set_bytes_req(::uint64_t value);

  public:
  // optional uint64 call_site = 3;
  bool has_call_site() const;
  void clear_call_site() ;
  ::uint64_t call_site() const;
  void set_call_site(::uint64_t value);

  private:
  ::uint64_t _internal_call_site() const;
  void _internal_set_call_site(::uint64_t value);

  public:
  // optional uint32 gfp_flags = 4;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // optional int32 node = 5;
  bool has_node() const;
  void clear_node() ;
  ::int32_t node() const;
  void set_node(::int32_t value);

  private:
  ::int32_t _internal_node() const;
  void _internal_set_node(::int32_t value);

  public:
  // optional uint64 ptr = 6;
  bool has_ptr() const;
  void clear_ptr() ;
  ::uint64_t ptr() const;
  void set_ptr(::uint64_t value);

  private:
  ::uint64_t _internal_ptr() const;
  void _internal_set_ptr(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t bytes_alloc_;
    ::uint64_t bytes_req_;
    ::uint64_t call_site_;
    ::uint32_t gfp_flags_;
    ::int32_t node_;
    ::uint64_t ptr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class KmemCacheFreeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.KmemCacheFreeFtraceEvent) */ {
 public:
  inline KmemCacheFreeFtraceEvent() : KmemCacheFreeFtraceEvent(nullptr) {}
  ~KmemCacheFreeFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KmemCacheFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KmemCacheFreeFtraceEvent(const KmemCacheFreeFtraceEvent& from);
  KmemCacheFreeFtraceEvent(KmemCacheFreeFtraceEvent&& from) noexcept
    : KmemCacheFreeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline KmemCacheFreeFtraceEvent& operator=(const KmemCacheFreeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmemCacheFreeFtraceEvent& operator=(KmemCacheFreeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KmemCacheFreeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KmemCacheFreeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const KmemCacheFreeFtraceEvent*>(
               &_KmemCacheFreeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(KmemCacheFreeFtraceEvent& a, KmemCacheFreeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KmemCacheFreeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KmemCacheFreeFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KmemCacheFreeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KmemCacheFreeFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KmemCacheFreeFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KmemCacheFreeFtraceEvent& from) {
    KmemCacheFreeFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KmemCacheFreeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.KmemCacheFreeFtraceEvent";
  }
  protected:
  explicit KmemCacheFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  // optional uint64 call_site = 1;
  bool has_call_site() const;
  void clear_call_site() ;
  ::uint64_t call_site() const;
  void set_call_site(::uint64_t value);

  private:
  ::uint64_t _internal_call_site() const;
  void _internal_set_call_site(::uint64_t value);

  public:
  // optional uint64 ptr = 2;
  bool has_ptr() const;
  void clear_ptr() ;
  ::uint64_t ptr() const;
  void set_ptr(::uint64_t value);

  private:
  ::uint64_t _internal_ptr() const;
  void _internal_set_ptr(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.KmemCacheFreeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t call_site_;
    ::uint64_t ptr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class MigratePagesEndFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.MigratePagesEndFtraceEvent) */ {
 public:
  inline MigratePagesEndFtraceEvent() : MigratePagesEndFtraceEvent(nullptr) {}
  ~MigratePagesEndFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MigratePagesEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigratePagesEndFtraceEvent(const MigratePagesEndFtraceEvent& from);
  MigratePagesEndFtraceEvent(MigratePagesEndFtraceEvent&& from) noexcept
    : MigratePagesEndFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MigratePagesEndFtraceEvent& operator=(const MigratePagesEndFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigratePagesEndFtraceEvent& operator=(MigratePagesEndFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigratePagesEndFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigratePagesEndFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MigratePagesEndFtraceEvent*>(
               &_MigratePagesEndFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MigratePagesEndFtraceEvent& a, MigratePagesEndFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MigratePagesEndFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigratePagesEndFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MigratePagesEndFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MigratePagesEndFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigratePagesEndFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MigratePagesEndFtraceEvent& from) {
    MigratePagesEndFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigratePagesEndFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.MigratePagesEndFtraceEvent";
  }
  protected:
  explicit MigratePagesEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // optional int32 mode = 1;
  bool has_mode() const;
  void clear_mode() ;
  ::int32_t mode() const;
  void set_mode(::int32_t value);

  private:
  ::int32_t _internal_mode() const;
  void _internal_set_mode(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.MigratePagesEndFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class MigratePagesStartFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.MigratePagesStartFtraceEvent) */ {
 public:
  inline MigratePagesStartFtraceEvent() : MigratePagesStartFtraceEvent(nullptr) {}
  ~MigratePagesStartFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MigratePagesStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigratePagesStartFtraceEvent(const MigratePagesStartFtraceEvent& from);
  MigratePagesStartFtraceEvent(MigratePagesStartFtraceEvent&& from) noexcept
    : MigratePagesStartFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MigratePagesStartFtraceEvent& operator=(const MigratePagesStartFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigratePagesStartFtraceEvent& operator=(MigratePagesStartFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigratePagesStartFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigratePagesStartFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MigratePagesStartFtraceEvent*>(
               &_MigratePagesStartFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(MigratePagesStartFtraceEvent& a, MigratePagesStartFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MigratePagesStartFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigratePagesStartFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MigratePagesStartFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MigratePagesStartFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigratePagesStartFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MigratePagesStartFtraceEvent& from) {
    MigratePagesStartFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigratePagesStartFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.MigratePagesStartFtraceEvent";
  }
  protected:
  explicit MigratePagesStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // optional int32 mode = 1;
  bool has_mode() const;
  void clear_mode() ;
  ::int32_t mode() const;
  void set_mode(::int32_t value);

  private:
  ::int32_t _internal_mode() const;
  void _internal_set_mode(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.MigratePagesStartFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class MigrateRetryFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.MigrateRetryFtraceEvent) */ {
 public:
  inline MigrateRetryFtraceEvent() : MigrateRetryFtraceEvent(nullptr) {}
  ~MigrateRetryFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MigrateRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigrateRetryFtraceEvent(const MigrateRetryFtraceEvent& from);
  MigrateRetryFtraceEvent(MigrateRetryFtraceEvent&& from) noexcept
    : MigrateRetryFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MigrateRetryFtraceEvent& operator=(const MigrateRetryFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrateRetryFtraceEvent& operator=(MigrateRetryFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigrateRetryFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigrateRetryFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MigrateRetryFtraceEvent*>(
               &_MigrateRetryFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MigrateRetryFtraceEvent& a, MigrateRetryFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MigrateRetryFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigrateRetryFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MigrateRetryFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MigrateRetryFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigrateRetryFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MigrateRetryFtraceEvent& from) {
    MigrateRetryFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigrateRetryFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.MigrateRetryFtraceEvent";
  }
  protected:
  explicit MigrateRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriesFieldNumber = 1,
  };
  // optional int32 tries = 1;
  bool has_tries() const;
  void clear_tries() ;
  ::int32_t tries() const;
  void set_tries(::int32_t value);

  private:
  ::int32_t _internal_tries() const;
  void _internal_set_tries(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.MigrateRetryFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t tries_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class MmPageAllocFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageAllocFtraceEvent) */ {
 public:
  inline MmPageAllocFtraceEvent() : MmPageAllocFtraceEvent(nullptr) {}
  ~MmPageAllocFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MmPageAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MmPageAllocFtraceEvent(const MmPageAllocFtraceEvent& from);
  MmPageAllocFtraceEvent(MmPageAllocFtraceEvent&& from) noexcept
    : MmPageAllocFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageAllocFtraceEvent& operator=(const MmPageAllocFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageAllocFtraceEvent& operator=(MmPageAllocFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MmPageAllocFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MmPageAllocFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageAllocFtraceEvent*>(
               &_MmPageAllocFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MmPageAllocFtraceEvent& a, MmPageAllocFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageAllocFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MmPageAllocFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MmPageAllocFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MmPageAllocFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MmPageAllocFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MmPageAllocFtraceEvent& from) {
    MmPageAllocFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MmPageAllocFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.MmPageAllocFtraceEvent";
  }
  protected:
  explicit MmPageAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGfpFlagsFieldNumber = 1,
    kMigratetypeFieldNumber = 2,
    kPageFieldNumber = 4,
    kPfnFieldNumber = 5,
    kOrderFieldNumber = 3,
  };
  // optional uint32 gfp_flags = 1;
  bool has_gfp_flags() const;
  void clear_gfp_flags() ;
  ::uint32_t gfp_flags() const;
  void set_gfp_flags(::uint32_t value);

  private:
  ::uint32_t _internal_gfp_flags() const;
  void _internal_set_gfp_flags(::uint32_t value);

  public:
  // optional int32 migratetype = 2;
  bool has_migratetype() const;
  void clear_migratetype() ;
  ::int32_t migratetype() const;
  void set_migratetype(::int32_t value);

  private:
  ::int32_t _internal_migratetype() const;
  void _internal_set_migratetype(::int32_t value);

  public:
  // optional uint64 page = 4;
  bool has_page() const;
  void clear_page() ;
  ::uint64_t page() const;
  void set_page(::uint64_t value);

  private:
  ::uint64_t _internal_page() const;
  void _internal_set_page(::uint64_t value);

  public:
  // optional uint64 pfn = 5;
  bool has_pfn() const;
  void clear_pfn() ;
  ::uint64_t pfn() const;
  void set_pfn(::uint64_t value);

  private:
  ::uint64_t _internal_pfn() const;
  void _internal_set_pfn(::uint64_t value);

  public:
  // optional uint32 order = 3;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageAllocFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t gfp_flags_;
    ::int32_t migratetype_;
    ::uint64_t page_;
    ::uint64_t pfn_;
    ::uint32_t order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class MmPageAllocExtfragFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageAllocExtfragFtraceEvent) */ {
 public:
  inline MmPageAllocExtfragFtraceEvent() : MmPageAllocExtfragFtraceEvent(nullptr) {}
  ~MmPageAllocExtfragFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MmPageAllocExtfragFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MmPageAllocExtfragFtraceEvent(const MmPageAllocExtfragFtraceEvent& from);
  MmPageAllocExtfragFtraceEvent(MmPageAllocExtfragFtraceEvent&& from) noexcept
    : MmPageAllocExtfragFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageAllocExtfragFtraceEvent& operator=(const MmPageAllocExtfragFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageAllocExtfragFtraceEvent& operator=(MmPageAllocExtfragFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MmPageAllocExtfragFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MmPageAllocExtfragFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageAllocExtfragFtraceEvent*>(
               &_MmPageAllocExtfragFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(MmPageAllocExtfragFtraceEvent& a, MmPageAllocExtfragFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageAllocExtfragFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MmPageAllocExtfragFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MmPageAllocExtfragFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MmPageAllocExtfragFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MmPageAllocExtfragFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MmPageAllocExtfragFtraceEvent& from) {
    MmPageAllocExtfragFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MmPageAllocExtfragFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.MmPageAllocExtfragFtraceEvent";
  }
  protected:
  explicit MmPageAllocExtfragFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllocMigratetypeFieldNumber = 1,
    kAllocOrderFieldNumber = 2,
    kFallbackMigratetypeFieldNumber = 3,
    kFallbackOrderFieldNumber = 4,
    kPageFieldNumber = 5,
    kPfnFieldNumber = 7,
    kChangeOwnershipFieldNumber = 6,
  };
  // optional int32 alloc_migratetype = 1;
  bool has_alloc_migratetype() const;
  void clear_alloc_migratetype() ;
  ::int32_t alloc_migratetype() const;
  void set_alloc_migratetype(::int32_t value);

  private:
  ::int32_t _internal_alloc_migratetype() const;
  void _internal_set_alloc_migratetype(::int32_t value);

  public:
  // optional int32 alloc_order = 2;
  bool has_alloc_order() const;
  void clear_alloc_order() ;
  ::int32_t alloc_order() const;
  void set_alloc_order(::int32_t value);

  private:
  ::int32_t _internal_alloc_order() const;
  void _internal_set_alloc_order(::int32_t value);

  public:
  // optional int32 fallback_migratetype = 3;
  bool has_fallback_migratetype() const;
  void clear_fallback_migratetype() ;
  ::int32_t fallback_migratetype() const;
  void set_fallback_migratetype(::int32_t value);

  private:
  ::int32_t _internal_fallback_migratetype() const;
  void _internal_set_fallback_migratetype(::int32_t value);

  public:
  // optional int32 fallback_order = 4;
  bool has_fallback_order() const;
  void clear_fallback_order() ;
  ::int32_t fallback_order() const;
  void set_fallback_order(::int32_t value);

  private:
  ::int32_t _internal_fallback_order() const;
  void _internal_set_fallback_order(::int32_t value);

  public:
  // optional uint64 page = 5;
  bool has_page() const;
  void clear_page() ;
  ::uint64_t page() const;
  void set_page(::uint64_t value);

  private:
  ::uint64_t _internal_page() const;
  void _internal_set_page(::uint64_t value);

  public:
  // optional uint64 pfn = 7;
  bool has_pfn() const;
  void clear_pfn() ;
  ::uint64_t pfn() const;
  void set_pfn(::uint64_t value);

  private:
  ::uint64_t _internal_pfn() const;
  void _internal_set_pfn(::uint64_t value);

  public:
  // optional int32 change_ownership = 6;
  bool has_change_ownership() const;
  void clear_change_ownership() ;
  ::int32_t change_ownership() const;
  void set_change_ownership(::int32_t value);

  private:
  ::int32_t _internal_change_ownership() const;
  void _internal_set_change_ownership(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageAllocExtfragFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t alloc_migratetype_;
    ::int32_t alloc_order_;
    ::int32_t fallback_migratetype_;
    ::int32_t fallback_order_;
    ::uint64_t page_;
    ::uint64_t pfn_;
    ::int32_t change_ownership_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class MmPageAllocZoneLockedFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageAllocZoneLockedFtraceEvent) */ {
 public:
  inline MmPageAllocZoneLockedFtraceEvent() : MmPageAllocZoneLockedFtraceEvent(nullptr) {}
  ~MmPageAllocZoneLockedFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MmPageAllocZoneLockedFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MmPageAllocZoneLockedFtraceEvent(const MmPageAllocZoneLockedFtraceEvent& from);
  MmPageAllocZoneLockedFtraceEvent(MmPageAllocZoneLockedFtraceEvent&& from) noexcept
    : MmPageAllocZoneLockedFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageAllocZoneLockedFtraceEvent& operator=(const MmPageAllocZoneLockedFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageAllocZoneLockedFtraceEvent& operator=(MmPageAllocZoneLockedFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MmPageAllocZoneLockedFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MmPageAllocZoneLockedFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageAllocZoneLockedFtraceEvent*>(
               &_MmPageAllocZoneLockedFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(MmPageAllocZoneLockedFtraceEvent& a, MmPageAllocZoneLockedFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageAllocZoneLockedFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MmPageAllocZoneLockedFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MmPageAllocZoneLockedFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MmPageAllocZoneLockedFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MmPageAllocZoneLockedFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MmPageAllocZoneLockedFtraceEvent& from) {
    MmPageAllocZoneLockedFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MmPageAllocZoneLockedFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.MmPageAllocZoneLockedFtraceEvent";
  }
  protected:
  explicit MmPageAllocZoneLockedFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  // optional int32 migratetype = 1;
  bool has_migratetype() const;
  void clear_migratetype() ;
  ::int32_t migratetype() const;
  void set_migratetype(::int32_t value);

  private:
  ::int32_t _internal_migratetype() const;
  void _internal_set_migratetype(::int32_t value);

  public:
  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // optional uint64 page = 3;
  bool has_page() const;
  void clear_page() ;
  ::uint64_t page() const;
  void set_page(::uint64_t value);

  private:
  ::uint64_t _internal_page() const;
  void _internal_set_page(::uint64_t value);

  public:
  // optional uint64 pfn = 4;
  bool has_pfn() const;
  void clear_pfn() ;
  ::uint64_t pfn() const;
  void set_pfn(::uint64_t value);

  private:
  ::uint64_t _internal_pfn() const;
  void _internal_set_pfn(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t migratetype_;
    ::uint32_t order_;
    ::uint64_t page_;
    ::uint64_t pfn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class MmPageFreeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageFreeFtraceEvent) */ {
 public:
  inline MmPageFreeFtraceEvent() : MmPageFreeFtraceEvent(nullptr) {}
  ~MmPageFreeFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MmPageFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MmPageFreeFtraceEvent(const MmPageFreeFtraceEvent& from);
  MmPageFreeFtraceEvent(MmPageFreeFtraceEvent&& from) noexcept
    : MmPageFreeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageFreeFtraceEvent& operator=(const MmPageFreeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageFreeFtraceEvent& operator=(MmPageFreeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MmPageFreeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MmPageFreeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageFreeFtraceEvent*>(
               &_MmPageFreeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MmPageFreeFtraceEvent& a, MmPageFreeFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageFreeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MmPageFreeFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MmPageFreeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MmPageFreeFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MmPageFreeFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MmPageFreeFtraceEvent& from) {
    MmPageFreeFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MmPageFreeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.MmPageFreeFtraceEvent";
  }
  protected:
  explicit MmPageFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
    kOrderFieldNumber = 1,
  };
  // optional uint64 page = 2;
  bool has_page() const;
  void clear_page() ;
  ::uint64_t page() const;
  void set_page(::uint64_t value);

  private:
  ::uint64_t _internal_page() const;
  void _internal_set_page(::uint64_t value);

  public:
  // optional uint64 pfn = 3;
  bool has_pfn() const;
  void clear_pfn() ;
  ::uint64_t pfn() const;
  void set_pfn(::uint64_t value);

  private:
  ::uint64_t _internal_pfn() const;
  void _internal_set_pfn(::uint64_t value);

  public:
  // optional uint32 order = 1;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageFreeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t page_;
    ::uint64_t pfn_;
    ::uint32_t order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class MmPageFreeBatchedFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPageFreeBatchedFtraceEvent) */ {
 public:
  inline MmPageFreeBatchedFtraceEvent() : MmPageFreeBatchedFtraceEvent(nullptr) {}
  ~MmPageFreeBatchedFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MmPageFreeBatchedFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MmPageFreeBatchedFtraceEvent(const MmPageFreeBatchedFtraceEvent& from);
  MmPageFreeBatchedFtraceEvent(MmPageFreeBatchedFtraceEvent&& from) noexcept
    : MmPageFreeBatchedFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPageFreeBatchedFtraceEvent& operator=(const MmPageFreeBatchedFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPageFreeBatchedFtraceEvent& operator=(MmPageFreeBatchedFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MmPageFreeBatchedFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MmPageFreeBatchedFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPageFreeBatchedFtraceEvent*>(
               &_MmPageFreeBatchedFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(MmPageFreeBatchedFtraceEvent& a, MmPageFreeBatchedFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPageFreeBatchedFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MmPageFreeBatchedFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MmPageFreeBatchedFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MmPageFreeBatchedFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MmPageFreeBatchedFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MmPageFreeBatchedFtraceEvent& from) {
    MmPageFreeBatchedFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MmPageFreeBatchedFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.MmPageFreeBatchedFtraceEvent";
  }
  protected:
  explicit MmPageFreeBatchedFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
    kColdFieldNumber = 1,
  };
  // optional uint64 page = 2;
  bool has_page() const;
  void clear_page() ;
  ::uint64_t page() const;
  void set_page(::uint64_t value);

  private:
  ::uint64_t _internal_page() const;
  void _internal_set_page(::uint64_t value);

  public:
  // optional uint64 pfn = 3;
  bool has_pfn() const;
  void clear_pfn() ;
  ::uint64_t pfn() const;
  void set_pfn(::uint64_t value);

  private:
  ::uint64_t _internal_pfn() const;
  void _internal_set_pfn(::uint64_t value);

  public:
  // optional int32 cold = 1;
  bool has_cold() const;
  void clear_cold() ;
  ::int32_t cold() const;
  void set_cold(::int32_t value);

  private:
  ::int32_t _internal_cold() const;
  void _internal_set_cold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPageFreeBatchedFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t page_;
    ::uint64_t pfn_;
    ::int32_t cold_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class MmPagePcpuDrainFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.MmPagePcpuDrainFtraceEvent) */ {
 public:
  inline MmPagePcpuDrainFtraceEvent() : MmPagePcpuDrainFtraceEvent(nullptr) {}
  ~MmPagePcpuDrainFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MmPagePcpuDrainFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MmPagePcpuDrainFtraceEvent(const MmPagePcpuDrainFtraceEvent& from);
  MmPagePcpuDrainFtraceEvent(MmPagePcpuDrainFtraceEvent&& from) noexcept
    : MmPagePcpuDrainFtraceEvent() {
    *this = ::std::move(from);
  }

  inline MmPagePcpuDrainFtraceEvent& operator=(const MmPagePcpuDrainFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmPagePcpuDrainFtraceEvent& operator=(MmPagePcpuDrainFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MmPagePcpuDrainFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MmPagePcpuDrainFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const MmPagePcpuDrainFtraceEvent*>(
               &_MmPagePcpuDrainFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(MmPagePcpuDrainFtraceEvent& a, MmPagePcpuDrainFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MmPagePcpuDrainFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MmPagePcpuDrainFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MmPagePcpuDrainFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MmPagePcpuDrainFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MmPagePcpuDrainFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MmPagePcpuDrainFtraceEvent& from) {
    MmPagePcpuDrainFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MmPagePcpuDrainFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.MmPagePcpuDrainFtraceEvent";
  }
  protected:
  explicit MmPagePcpuDrainFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  // optional int32 migratetype = 1;
  bool has_migratetype() const;
  void clear_migratetype() ;
  ::int32_t migratetype() const;
  void set_migratetype(::int32_t value);

  private:
  ::int32_t _internal_migratetype() const;
  void _internal_set_migratetype(::int32_t value);

  public:
  // optional uint32 order = 2;
  bool has_order() const;
  void clear_order() ;
  ::uint32_t order() const;
  void set_order(::uint32_t value);

  private:
  ::uint32_t _internal_order() const;
  void _internal_set_order(::uint32_t value);

  public:
  // optional uint64 page = 3;
  bool has_page() const;
  void clear_page() ;
  ::uint64_t page() const;
  void set_page(::uint64_t value);

  private:
  ::uint64_t _internal_page() const;
  void _internal_set_page(::uint64_t value);

  public:
  // optional uint64 pfn = 4;
  bool has_pfn() const;
  void clear_pfn() ;
  ::uint64_t pfn() const;
  void set_pfn(::uint64_t value);

  private:
  ::uint64_t _internal_pfn() const;
  void _internal_set_pfn(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.MmPagePcpuDrainFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t migratetype_;
    ::uint32_t order_;
    ::uint64_t page_;
    ::uint64_t pfn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class RssStatFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.RssStatFtraceEvent) */ {
 public:
  inline RssStatFtraceEvent() : RssStatFtraceEvent(nullptr) {}
  ~RssStatFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RssStatFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RssStatFtraceEvent(const RssStatFtraceEvent& from);
  RssStatFtraceEvent(RssStatFtraceEvent&& from) noexcept
    : RssStatFtraceEvent() {
    *this = ::std::move(from);
  }

  inline RssStatFtraceEvent& operator=(const RssStatFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RssStatFtraceEvent& operator=(RssStatFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RssStatFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const RssStatFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const RssStatFtraceEvent*>(
               &_RssStatFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RssStatFtraceEvent& a, RssStatFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RssStatFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RssStatFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RssStatFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RssStatFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RssStatFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RssStatFtraceEvent& from) {
    RssStatFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RssStatFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.RssStatFtraceEvent";
  }
  protected:
  explicit RssStatFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 2,
    kMemberFieldNumber = 1,
    kCurrFieldNumber = 3,
    kMmIdFieldNumber = 4,
  };
  // optional int64 size = 2;
  bool has_size() const;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // optional int32 member = 1;
  bool has_member() const;
  void clear_member() ;
  ::int32_t member() const;
  void set_member(::int32_t value);

  private:
  ::int32_t _internal_member() const;
  void _internal_set_member(::int32_t value);

  public:
  // optional uint32 curr = 3;
  bool has_curr() const;
  void clear_curr() ;
  ::uint32_t curr() const;
  void set_curr(::uint32_t value);

  private:
  ::uint32_t _internal_curr() const;
  void _internal_set_curr(::uint32_t value);

  public:
  // optional uint32 mm_id = 4;
  bool has_mm_id() const;
  void clear_mm_id() ;
  ::uint32_t mm_id() const;
  void set_mm_id(::uint32_t value);

  private:
  ::uint32_t _internal_mm_id() const;
  void _internal_set_mm_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.RssStatFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t size_;
    ::int32_t member_;
    ::uint32_t curr_;
    ::uint32_t mm_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonHeapShrinkFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonHeapShrinkFtraceEvent) */ {
 public:
  inline IonHeapShrinkFtraceEvent() : IonHeapShrinkFtraceEvent(nullptr) {}
  ~IonHeapShrinkFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonHeapShrinkFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonHeapShrinkFtraceEvent(const IonHeapShrinkFtraceEvent& from);
  IonHeapShrinkFtraceEvent(IonHeapShrinkFtraceEvent&& from) noexcept
    : IonHeapShrinkFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonHeapShrinkFtraceEvent& operator=(const IonHeapShrinkFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonHeapShrinkFtraceEvent& operator=(IonHeapShrinkFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonHeapShrinkFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonHeapShrinkFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonHeapShrinkFtraceEvent*>(
               &_IonHeapShrinkFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(IonHeapShrinkFtraceEvent& a, IonHeapShrinkFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonHeapShrinkFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonHeapShrinkFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonHeapShrinkFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonHeapShrinkFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonHeapShrinkFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonHeapShrinkFtraceEvent& from) {
    IonHeapShrinkFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonHeapShrinkFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonHeapShrinkFtraceEvent";
  }
  protected:
  explicit IonHeapShrinkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  // optional string heap_name = 1;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional int64 total_allocated = 3;
  bool has_total_allocated() const;
  void clear_total_allocated() ;
  ::int64_t total_allocated() const;
  void set_total_allocated(::int64_t value);

  private:
  ::int64_t _internal_total_allocated() const;
  void _internal_set_total_allocated(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonHeapShrinkFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::uint64_t len_;
    ::int64_t total_allocated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonHeapGrowFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonHeapGrowFtraceEvent) */ {
 public:
  inline IonHeapGrowFtraceEvent() : IonHeapGrowFtraceEvent(nullptr) {}
  ~IonHeapGrowFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonHeapGrowFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonHeapGrowFtraceEvent(const IonHeapGrowFtraceEvent& from);
  IonHeapGrowFtraceEvent(IonHeapGrowFtraceEvent&& from) noexcept
    : IonHeapGrowFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonHeapGrowFtraceEvent& operator=(const IonHeapGrowFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonHeapGrowFtraceEvent& operator=(IonHeapGrowFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonHeapGrowFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonHeapGrowFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonHeapGrowFtraceEvent*>(
               &_IonHeapGrowFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(IonHeapGrowFtraceEvent& a, IonHeapGrowFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonHeapGrowFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonHeapGrowFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonHeapGrowFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonHeapGrowFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonHeapGrowFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonHeapGrowFtraceEvent& from) {
    IonHeapGrowFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonHeapGrowFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonHeapGrowFtraceEvent";
  }
  protected:
  explicit IonHeapGrowFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  // optional string heap_name = 1;
  bool has_heap_name() const;
  void clear_heap_name() ;
  const std::string& heap_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heap_name(Arg_&& arg, Args_... args);
  std::string* mutable_heap_name();
  PROTOBUF_NODISCARD std::string* release_heap_name();
  void set_allocated_heap_name(std::string* ptr);

  private:
  const std::string& _internal_heap_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heap_name(
      const std::string& value);
  std::string* _internal_mutable_heap_name();

  public:
  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional int64 total_allocated = 3;
  bool has_total_allocated() const;
  void clear_total_allocated() ;
  ::int64_t total_allocated() const;
  void set_total_allocated(::int64_t value);

  private:
  ::int64_t _internal_total_allocated() const;
  void _internal_set_total_allocated(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonHeapGrowFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heap_name_;
    ::uint64_t len_;
    ::int64_t total_allocated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonBufferCreateFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonBufferCreateFtraceEvent) */ {
 public:
  inline IonBufferCreateFtraceEvent() : IonBufferCreateFtraceEvent(nullptr) {}
  ~IonBufferCreateFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonBufferCreateFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonBufferCreateFtraceEvent(const IonBufferCreateFtraceEvent& from);
  IonBufferCreateFtraceEvent(IonBufferCreateFtraceEvent&& from) noexcept
    : IonBufferCreateFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonBufferCreateFtraceEvent& operator=(const IonBufferCreateFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonBufferCreateFtraceEvent& operator=(IonBufferCreateFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonBufferCreateFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonBufferCreateFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonBufferCreateFtraceEvent*>(
               &_IonBufferCreateFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(IonBufferCreateFtraceEvent& a, IonBufferCreateFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonBufferCreateFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonBufferCreateFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonBufferCreateFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonBufferCreateFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonBufferCreateFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonBufferCreateFtraceEvent& from) {
    IonBufferCreateFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonBufferCreateFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonBufferCreateFtraceEvent";
  }
  protected:
  explicit IonBufferCreateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };
  // optional uint64 addr = 1;
  bool has_addr() const;
  void clear_addr() ;
  ::uint64_t addr() const;
  void set_addr(::uint64_t value);

  private:
  ::uint64_t _internal_addr() const;
  void _internal_set_addr(::uint64_t value);

  public:
  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonBufferCreateFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t addr_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};// -------------------------------------------------------------------

class IonBufferDestroyFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perfetto.protos.IonBufferDestroyFtraceEvent) */ {
 public:
  inline IonBufferDestroyFtraceEvent() : IonBufferDestroyFtraceEvent(nullptr) {}
  ~IonBufferDestroyFtraceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IonBufferDestroyFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IonBufferDestroyFtraceEvent(const IonBufferDestroyFtraceEvent& from);
  IonBufferDestroyFtraceEvent(IonBufferDestroyFtraceEvent&& from) noexcept
    : IonBufferDestroyFtraceEvent() {
    *this = ::std::move(from);
  }

  inline IonBufferDestroyFtraceEvent& operator=(const IonBufferDestroyFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IonBufferDestroyFtraceEvent& operator=(IonBufferDestroyFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IonBufferDestroyFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IonBufferDestroyFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const IonBufferDestroyFtraceEvent*>(
               &_IonBufferDestroyFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(IonBufferDestroyFtraceEvent& a, IonBufferDestroyFtraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IonBufferDestroyFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IonBufferDestroyFtraceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IonBufferDestroyFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IonBufferDestroyFtraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IonBufferDestroyFtraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IonBufferDestroyFtraceEvent& from) {
    IonBufferDestroyFtraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IonBufferDestroyFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "perfetto.protos.IonBufferDestroyFtraceEvent";
  }
  protected:
  explicit IonBufferDestroyFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };
  // optional uint64 addr = 1;
  bool has_addr() const;
  void clear_addr() ;
  ::uint64_t addr() const;
  void set_addr(::uint64_t value);

  private:
  ::uint64_t _internal_addr() const;
  void _internal_set_addr(::uint64_t value);

  public:
  // optional uint64 len = 2;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:perfetto.protos.IonBufferDestroyFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t addr_;
    ::uint64_t len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AllocPagesIommuEndFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesIommuEndFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AllocPagesIommuEndFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AllocPagesIommuEndFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuEndFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void AllocPagesIommuEndFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuEndFtraceEvent.gfp_flags)
}
inline ::uint32_t AllocPagesIommuEndFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void AllocPagesIommuEndFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gfp_flags_ = value;
}

// optional uint32 order = 2;
inline bool AllocPagesIommuEndFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AllocPagesIommuEndFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AllocPagesIommuEndFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuEndFtraceEvent.order)
  return _internal_order();
}
inline void AllocPagesIommuEndFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuEndFtraceEvent.order)
}
inline ::uint32_t AllocPagesIommuEndFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void AllocPagesIommuEndFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.order_ = value;
}

// -------------------------------------------------------------------

// AllocPagesIommuFailFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesIommuFailFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AllocPagesIommuFailFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AllocPagesIommuFailFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuFailFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void AllocPagesIommuFailFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuFailFtraceEvent.gfp_flags)
}
inline ::uint32_t AllocPagesIommuFailFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void AllocPagesIommuFailFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gfp_flags_ = value;
}

// optional uint32 order = 2;
inline bool AllocPagesIommuFailFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AllocPagesIommuFailFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AllocPagesIommuFailFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuFailFtraceEvent.order)
  return _internal_order();
}
inline void AllocPagesIommuFailFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuFailFtraceEvent.order)
}
inline ::uint32_t AllocPagesIommuFailFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void AllocPagesIommuFailFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.order_ = value;
}

// -------------------------------------------------------------------

// AllocPagesIommuStartFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesIommuStartFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AllocPagesIommuStartFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AllocPagesIommuStartFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuStartFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void AllocPagesIommuStartFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuStartFtraceEvent.gfp_flags)
}
inline ::uint32_t AllocPagesIommuStartFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void AllocPagesIommuStartFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gfp_flags_ = value;
}

// optional uint32 order = 2;
inline bool AllocPagesIommuStartFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AllocPagesIommuStartFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AllocPagesIommuStartFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesIommuStartFtraceEvent.order)
  return _internal_order();
}
inline void AllocPagesIommuStartFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesIommuStartFtraceEvent.order)
}
inline ::uint32_t AllocPagesIommuStartFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void AllocPagesIommuStartFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.order_ = value;
}

// -------------------------------------------------------------------

// AllocPagesSysEndFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesSysEndFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AllocPagesSysEndFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AllocPagesSysEndFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysEndFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void AllocPagesSysEndFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysEndFtraceEvent.gfp_flags)
}
inline ::uint32_t AllocPagesSysEndFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void AllocPagesSysEndFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gfp_flags_ = value;
}

// optional uint32 order = 2;
inline bool AllocPagesSysEndFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AllocPagesSysEndFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AllocPagesSysEndFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysEndFtraceEvent.order)
  return _internal_order();
}
inline void AllocPagesSysEndFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysEndFtraceEvent.order)
}
inline ::uint32_t AllocPagesSysEndFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void AllocPagesSysEndFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.order_ = value;
}

// -------------------------------------------------------------------

// AllocPagesSysFailFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesSysFailFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AllocPagesSysFailFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AllocPagesSysFailFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysFailFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void AllocPagesSysFailFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysFailFtraceEvent.gfp_flags)
}
inline ::uint32_t AllocPagesSysFailFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void AllocPagesSysFailFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gfp_flags_ = value;
}

// optional uint32 order = 2;
inline bool AllocPagesSysFailFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AllocPagesSysFailFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AllocPagesSysFailFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysFailFtraceEvent.order)
  return _internal_order();
}
inline void AllocPagesSysFailFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysFailFtraceEvent.order)
}
inline ::uint32_t AllocPagesSysFailFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void AllocPagesSysFailFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.order_ = value;
}

// -------------------------------------------------------------------

// AllocPagesSysStartFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool AllocPagesSysStartFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AllocPagesSysStartFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AllocPagesSysStartFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysStartFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void AllocPagesSysStartFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysStartFtraceEvent.gfp_flags)
}
inline ::uint32_t AllocPagesSysStartFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void AllocPagesSysStartFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gfp_flags_ = value;
}

// optional uint32 order = 2;
inline bool AllocPagesSysStartFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AllocPagesSysStartFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AllocPagesSysStartFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AllocPagesSysStartFtraceEvent.order)
  return _internal_order();
}
inline void AllocPagesSysStartFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AllocPagesSysStartFtraceEvent.order)
}
inline ::uint32_t AllocPagesSysStartFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void AllocPagesSysStartFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.order_ = value;
}

// -------------------------------------------------------------------

// DmaAllocContiguousRetryFtraceEvent

// optional int32 tries = 1;
inline bool DmaAllocContiguousRetryFtraceEvent::has_tries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DmaAllocContiguousRetryFtraceEvent::clear_tries() {
  _impl_.tries_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t DmaAllocContiguousRetryFtraceEvent::tries() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DmaAllocContiguousRetryFtraceEvent.tries)
  return _internal_tries();
}
inline void DmaAllocContiguousRetryFtraceEvent::set_tries(::int32_t value) {
  _internal_set_tries(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DmaAllocContiguousRetryFtraceEvent.tries)
}
inline ::int32_t DmaAllocContiguousRetryFtraceEvent::_internal_tries() const {
  return _impl_.tries_;
}
inline void DmaAllocContiguousRetryFtraceEvent::_internal_set_tries(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tries_ = value;
}

// -------------------------------------------------------------------

// IommuMapRangeFtraceEvent

// optional uint64 chunk_size = 1;
inline bool IommuMapRangeFtraceEvent::has_chunk_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IommuMapRangeFtraceEvent::clear_chunk_size() {
  _impl_.chunk_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IommuMapRangeFtraceEvent::chunk_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuMapRangeFtraceEvent.chunk_size)
  return _internal_chunk_size();
}
inline void IommuMapRangeFtraceEvent::set_chunk_size(::uint64_t value) {
  _internal_set_chunk_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuMapRangeFtraceEvent.chunk_size)
}
inline ::uint64_t IommuMapRangeFtraceEvent::_internal_chunk_size() const {
  return _impl_.chunk_size_;
}
inline void IommuMapRangeFtraceEvent::_internal_set_chunk_size(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chunk_size_ = value;
}

// optional uint64 len = 2;
inline bool IommuMapRangeFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IommuMapRangeFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IommuMapRangeFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuMapRangeFtraceEvent.len)
  return _internal_len();
}
inline void IommuMapRangeFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuMapRangeFtraceEvent.len)
}
inline ::uint64_t IommuMapRangeFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IommuMapRangeFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.len_ = value;
}

// optional uint64 pa = 3;
inline bool IommuMapRangeFtraceEvent::has_pa() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IommuMapRangeFtraceEvent::clear_pa() {
  _impl_.pa_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t IommuMapRangeFtraceEvent::pa() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuMapRangeFtraceEvent.pa)
  return _internal_pa();
}
inline void IommuMapRangeFtraceEvent::set_pa(::uint64_t value) {
  _internal_set_pa(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuMapRangeFtraceEvent.pa)
}
inline ::uint64_t IommuMapRangeFtraceEvent::_internal_pa() const {
  return _impl_.pa_;
}
inline void IommuMapRangeFtraceEvent::_internal_set_pa(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pa_ = value;
}

// optional uint64 va = 4;
inline bool IommuMapRangeFtraceEvent::has_va() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IommuMapRangeFtraceEvent::clear_va() {
  _impl_.va_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t IommuMapRangeFtraceEvent::va() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuMapRangeFtraceEvent.va)
  return _internal_va();
}
inline void IommuMapRangeFtraceEvent::set_va(::uint64_t value) {
  _internal_set_va(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuMapRangeFtraceEvent.va)
}
inline ::uint64_t IommuMapRangeFtraceEvent::_internal_va() const {
  return _impl_.va_;
}
inline void IommuMapRangeFtraceEvent::_internal_set_va(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.va_ = value;
}

// -------------------------------------------------------------------

// IommuSecPtblMapRangeEndFtraceEvent

// optional uint64 len = 1;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IommuSecPtblMapRangeEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.len)
  return _internal_len();
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.len)
}
inline ::uint64_t IommuSecPtblMapRangeEndFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.len_ = value;
}

// optional int32 num = 2;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_num() {
  _impl_.num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t IommuSecPtblMapRangeEndFtraceEvent::num() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.num)
  return _internal_num();
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_num(::int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.num)
}
inline ::int32_t IommuSecPtblMapRangeEndFtraceEvent::_internal_num() const {
  return _impl_.num_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::_internal_set_num(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_ = value;
}

// optional uint32 pa = 3;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_pa() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_pa() {
  _impl_.pa_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t IommuSecPtblMapRangeEndFtraceEvent::pa() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.pa)
  return _internal_pa();
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_pa(::uint32_t value) {
  _internal_set_pa(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.pa)
}
inline ::uint32_t IommuSecPtblMapRangeEndFtraceEvent::_internal_pa() const {
  return _impl_.pa_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::_internal_set_pa(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pa_ = value;
}

// optional int32 sec_id = 4;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_sec_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_sec_id() {
  _impl_.sec_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t IommuSecPtblMapRangeEndFtraceEvent::sec_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.sec_id)
  return _internal_sec_id();
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_sec_id(::int32_t value) {
  _internal_set_sec_id(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.sec_id)
}
inline ::int32_t IommuSecPtblMapRangeEndFtraceEvent::_internal_sec_id() const {
  return _impl_.sec_id_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::_internal_set_sec_id(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sec_id_ = value;
}

// optional uint64 va = 5;
inline bool IommuSecPtblMapRangeEndFtraceEvent::has_va() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::clear_va() {
  _impl_.va_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t IommuSecPtblMapRangeEndFtraceEvent::va() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.va)
  return _internal_va();
}
inline void IommuSecPtblMapRangeEndFtraceEvent::set_va(::uint64_t value) {
  _internal_set_va(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent.va)
}
inline ::uint64_t IommuSecPtblMapRangeEndFtraceEvent::_internal_va() const {
  return _impl_.va_;
}
inline void IommuSecPtblMapRangeEndFtraceEvent::_internal_set_va(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.va_ = value;
}

// -------------------------------------------------------------------

// IommuSecPtblMapRangeStartFtraceEvent

// optional uint64 len = 1;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IommuSecPtblMapRangeStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.len)
  return _internal_len();
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.len)
}
inline ::uint64_t IommuSecPtblMapRangeStartFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.len_ = value;
}

// optional int32 num = 2;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_num() {
  _impl_.num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t IommuSecPtblMapRangeStartFtraceEvent::num() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.num)
  return _internal_num();
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_num(::int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.num)
}
inline ::int32_t IommuSecPtblMapRangeStartFtraceEvent::_internal_num() const {
  return _impl_.num_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::_internal_set_num(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_ = value;
}

// optional uint32 pa = 3;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_pa() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_pa() {
  _impl_.pa_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t IommuSecPtblMapRangeStartFtraceEvent::pa() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.pa)
  return _internal_pa();
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_pa(::uint32_t value) {
  _internal_set_pa(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.pa)
}
inline ::uint32_t IommuSecPtblMapRangeStartFtraceEvent::_internal_pa() const {
  return _impl_.pa_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::_internal_set_pa(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pa_ = value;
}

// optional int32 sec_id = 4;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_sec_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_sec_id() {
  _impl_.sec_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t IommuSecPtblMapRangeStartFtraceEvent::sec_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.sec_id)
  return _internal_sec_id();
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_sec_id(::int32_t value) {
  _internal_set_sec_id(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.sec_id)
}
inline ::int32_t IommuSecPtblMapRangeStartFtraceEvent::_internal_sec_id() const {
  return _impl_.sec_id_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::_internal_set_sec_id(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sec_id_ = value;
}

// optional uint64 va = 5;
inline bool IommuSecPtblMapRangeStartFtraceEvent::has_va() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::clear_va() {
  _impl_.va_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t IommuSecPtblMapRangeStartFtraceEvent::va() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.va)
  return _internal_va();
}
inline void IommuSecPtblMapRangeStartFtraceEvent::set_va(::uint64_t value) {
  _internal_set_va(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent.va)
}
inline ::uint64_t IommuSecPtblMapRangeStartFtraceEvent::_internal_va() const {
  return _impl_.va_;
}
inline void IommuSecPtblMapRangeStartFtraceEvent::_internal_set_va(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.va_ = value;
}

// -------------------------------------------------------------------

// IonAllocBufferEndFtraceEvent

// optional string client_name = 1;
inline bool IonAllocBufferEndFtraceEvent::has_client_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonAllocBufferEndFtraceEvent::clear_client_name() {
  _impl_.client_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonAllocBufferEndFtraceEvent::client_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
  return _internal_client_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonAllocBufferEndFtraceEvent::set_client_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
}
inline std::string* IonAllocBufferEndFtraceEvent::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
  return _s;
}
inline const std::string& IonAllocBufferEndFtraceEvent::_internal_client_name() const {
  return _impl_.client_name_.Get();
}
inline void IonAllocBufferEndFtraceEvent::_internal_set_client_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonAllocBufferEndFtraceEvent::_internal_mutable_client_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonAllocBufferEndFtraceEvent::release_client_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.client_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonAllocBufferEndFtraceEvent::set_allocated_client_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_name_.IsDefault()) {
          _impl_.client_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferEndFtraceEvent.client_name)
}

// optional uint32 flags = 2;
inline bool IonAllocBufferEndFtraceEvent::has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonAllocBufferEndFtraceEvent::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t IonAllocBufferEndFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.flags)
  return _internal_flags();
}
inline void IonAllocBufferEndFtraceEvent::set_flags(::uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.flags)
}
inline ::uint32_t IonAllocBufferEndFtraceEvent::_internal_flags() const {
  return _impl_.flags_;
}
inline void IonAllocBufferEndFtraceEvent::_internal_set_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.flags_ = value;
}

// optional string heap_name = 3;
inline bool IonAllocBufferEndFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonAllocBufferEndFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IonAllocBufferEndFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonAllocBufferEndFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
}
inline std::string* IonAllocBufferEndFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonAllocBufferEndFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonAllocBufferEndFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonAllocBufferEndFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonAllocBufferEndFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonAllocBufferEndFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferEndFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonAllocBufferEndFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void IonAllocBufferEndFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t IonAllocBufferEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.len)
  return _internal_len();
}
inline void IonAllocBufferEndFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.len)
}
inline ::uint64_t IonAllocBufferEndFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonAllocBufferEndFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.len_ = value;
}

// optional uint32 mask = 5;
inline bool IonAllocBufferEndFtraceEvent::has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IonAllocBufferEndFtraceEvent::clear_mask() {
  _impl_.mask_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t IonAllocBufferEndFtraceEvent::mask() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferEndFtraceEvent.mask)
  return _internal_mask();
}
inline void IonAllocBufferEndFtraceEvent::set_mask(::uint32_t value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferEndFtraceEvent.mask)
}
inline ::uint32_t IonAllocBufferEndFtraceEvent::_internal_mask() const {
  return _impl_.mask_;
}
inline void IonAllocBufferEndFtraceEvent::_internal_set_mask(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mask_ = value;
}

// -------------------------------------------------------------------

// IonAllocBufferFailFtraceEvent

// optional string client_name = 1;
inline bool IonAllocBufferFailFtraceEvent::has_client_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonAllocBufferFailFtraceEvent::clear_client_name() {
  _impl_.client_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonAllocBufferFailFtraceEvent::client_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
  return _internal_client_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonAllocBufferFailFtraceEvent::set_client_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
}
inline std::string* IonAllocBufferFailFtraceEvent::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
  return _s;
}
inline const std::string& IonAllocBufferFailFtraceEvent::_internal_client_name() const {
  return _impl_.client_name_.Get();
}
inline void IonAllocBufferFailFtraceEvent::_internal_set_client_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonAllocBufferFailFtraceEvent::_internal_mutable_client_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonAllocBufferFailFtraceEvent::release_client_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.client_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonAllocBufferFailFtraceEvent::set_allocated_client_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_name_.IsDefault()) {
          _impl_.client_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferFailFtraceEvent.client_name)
}

// optional int64 error = 2;
inline bool IonAllocBufferFailFtraceEvent::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonAllocBufferFailFtraceEvent::clear_error() {
  _impl_.error_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t IonAllocBufferFailFtraceEvent::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.error)
  return _internal_error();
}
inline void IonAllocBufferFailFtraceEvent::set_error(::int64_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.error)
}
inline ::int64_t IonAllocBufferFailFtraceEvent::_internal_error() const {
  return _impl_.error_;
}
inline void IonAllocBufferFailFtraceEvent::_internal_set_error(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_ = value;
}

// optional uint32 flags = 3;
inline bool IonAllocBufferFailFtraceEvent::has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IonAllocBufferFailFtraceEvent::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t IonAllocBufferFailFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.flags)
  return _internal_flags();
}
inline void IonAllocBufferFailFtraceEvent::set_flags(::uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.flags)
}
inline ::uint32_t IonAllocBufferFailFtraceEvent::_internal_flags() const {
  return _impl_.flags_;
}
inline void IonAllocBufferFailFtraceEvent::_internal_set_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.flags_ = value;
}

// optional string heap_name = 4;
inline bool IonAllocBufferFailFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonAllocBufferFailFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IonAllocBufferFailFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonAllocBufferFailFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
}
inline std::string* IonAllocBufferFailFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonAllocBufferFailFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonAllocBufferFailFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonAllocBufferFailFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonAllocBufferFailFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonAllocBufferFailFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferFailFtraceEvent.heap_name)
}

// optional uint64 len = 5;
inline bool IonAllocBufferFailFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void IonAllocBufferFailFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t IonAllocBufferFailFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.len)
  return _internal_len();
}
inline void IonAllocBufferFailFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.len)
}
inline ::uint64_t IonAllocBufferFailFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonAllocBufferFailFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.len_ = value;
}

// optional uint32 mask = 6;
inline bool IonAllocBufferFailFtraceEvent::has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void IonAllocBufferFailFtraceEvent::clear_mask() {
  _impl_.mask_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t IonAllocBufferFailFtraceEvent::mask() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFailFtraceEvent.mask)
  return _internal_mask();
}
inline void IonAllocBufferFailFtraceEvent::set_mask(::uint32_t value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFailFtraceEvent.mask)
}
inline ::uint32_t IonAllocBufferFailFtraceEvent::_internal_mask() const {
  return _impl_.mask_;
}
inline void IonAllocBufferFailFtraceEvent::_internal_set_mask(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mask_ = value;
}

// -------------------------------------------------------------------

// IonAllocBufferFallbackFtraceEvent

// optional string client_name = 1;
inline bool IonAllocBufferFallbackFtraceEvent::has_client_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_client_name() {
  _impl_.client_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonAllocBufferFallbackFtraceEvent::client_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
  return _internal_client_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonAllocBufferFallbackFtraceEvent::set_client_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
}
inline std::string* IonAllocBufferFallbackFtraceEvent::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
  return _s;
}
inline const std::string& IonAllocBufferFallbackFtraceEvent::_internal_client_name() const {
  return _impl_.client_name_.Get();
}
inline void IonAllocBufferFallbackFtraceEvent::_internal_set_client_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonAllocBufferFallbackFtraceEvent::_internal_mutable_client_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonAllocBufferFallbackFtraceEvent::release_client_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.client_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonAllocBufferFallbackFtraceEvent::set_allocated_client_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_name_.IsDefault()) {
          _impl_.client_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferFallbackFtraceEvent.client_name)
}

// optional int64 error = 2;
inline bool IonAllocBufferFallbackFtraceEvent::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_error() {
  _impl_.error_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t IonAllocBufferFallbackFtraceEvent::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.error)
  return _internal_error();
}
inline void IonAllocBufferFallbackFtraceEvent::set_error(::int64_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.error)
}
inline ::int64_t IonAllocBufferFallbackFtraceEvent::_internal_error() const {
  return _impl_.error_;
}
inline void IonAllocBufferFallbackFtraceEvent::_internal_set_error(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_ = value;
}

// optional uint32 flags = 3;
inline bool IonAllocBufferFallbackFtraceEvent::has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t IonAllocBufferFallbackFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.flags)
  return _internal_flags();
}
inline void IonAllocBufferFallbackFtraceEvent::set_flags(::uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.flags)
}
inline ::uint32_t IonAllocBufferFallbackFtraceEvent::_internal_flags() const {
  return _impl_.flags_;
}
inline void IonAllocBufferFallbackFtraceEvent::_internal_set_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.flags_ = value;
}

// optional string heap_name = 4;
inline bool IonAllocBufferFallbackFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IonAllocBufferFallbackFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonAllocBufferFallbackFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
}
inline std::string* IonAllocBufferFallbackFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonAllocBufferFallbackFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonAllocBufferFallbackFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonAllocBufferFallbackFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonAllocBufferFallbackFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonAllocBufferFallbackFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferFallbackFtraceEvent.heap_name)
}

// optional uint64 len = 5;
inline bool IonAllocBufferFallbackFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t IonAllocBufferFallbackFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.len)
  return _internal_len();
}
inline void IonAllocBufferFallbackFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.len)
}
inline ::uint64_t IonAllocBufferFallbackFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonAllocBufferFallbackFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.len_ = value;
}

// optional uint32 mask = 6;
inline bool IonAllocBufferFallbackFtraceEvent::has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void IonAllocBufferFallbackFtraceEvent::clear_mask() {
  _impl_.mask_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t IonAllocBufferFallbackFtraceEvent::mask() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferFallbackFtraceEvent.mask)
  return _internal_mask();
}
inline void IonAllocBufferFallbackFtraceEvent::set_mask(::uint32_t value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferFallbackFtraceEvent.mask)
}
inline ::uint32_t IonAllocBufferFallbackFtraceEvent::_internal_mask() const {
  return _impl_.mask_;
}
inline void IonAllocBufferFallbackFtraceEvent::_internal_set_mask(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mask_ = value;
}

// -------------------------------------------------------------------

// IonAllocBufferStartFtraceEvent

// optional string client_name = 1;
inline bool IonAllocBufferStartFtraceEvent::has_client_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonAllocBufferStartFtraceEvent::clear_client_name() {
  _impl_.client_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonAllocBufferStartFtraceEvent::client_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
  return _internal_client_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonAllocBufferStartFtraceEvent::set_client_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
}
inline std::string* IonAllocBufferStartFtraceEvent::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
  return _s;
}
inline const std::string& IonAllocBufferStartFtraceEvent::_internal_client_name() const {
  return _impl_.client_name_.Get();
}
inline void IonAllocBufferStartFtraceEvent::_internal_set_client_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonAllocBufferStartFtraceEvent::_internal_mutable_client_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonAllocBufferStartFtraceEvent::release_client_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.client_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonAllocBufferStartFtraceEvent::set_allocated_client_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_name_.IsDefault()) {
          _impl_.client_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferStartFtraceEvent.client_name)
}

// optional uint32 flags = 2;
inline bool IonAllocBufferStartFtraceEvent::has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonAllocBufferStartFtraceEvent::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t IonAllocBufferStartFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.flags)
  return _internal_flags();
}
inline void IonAllocBufferStartFtraceEvent::set_flags(::uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.flags)
}
inline ::uint32_t IonAllocBufferStartFtraceEvent::_internal_flags() const {
  return _impl_.flags_;
}
inline void IonAllocBufferStartFtraceEvent::_internal_set_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.flags_ = value;
}

// optional string heap_name = 3;
inline bool IonAllocBufferStartFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonAllocBufferStartFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IonAllocBufferStartFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonAllocBufferStartFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
}
inline std::string* IonAllocBufferStartFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonAllocBufferStartFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonAllocBufferStartFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonAllocBufferStartFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonAllocBufferStartFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonAllocBufferStartFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonAllocBufferStartFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonAllocBufferStartFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void IonAllocBufferStartFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t IonAllocBufferStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.len)
  return _internal_len();
}
inline void IonAllocBufferStartFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.len)
}
inline ::uint64_t IonAllocBufferStartFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonAllocBufferStartFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.len_ = value;
}

// optional uint32 mask = 5;
inline bool IonAllocBufferStartFtraceEvent::has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IonAllocBufferStartFtraceEvent::clear_mask() {
  _impl_.mask_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t IonAllocBufferStartFtraceEvent::mask() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonAllocBufferStartFtraceEvent.mask)
  return _internal_mask();
}
inline void IonAllocBufferStartFtraceEvent::set_mask(::uint32_t value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonAllocBufferStartFtraceEvent.mask)
}
inline ::uint32_t IonAllocBufferStartFtraceEvent::_internal_mask() const {
  return _impl_.mask_;
}
inline void IonAllocBufferStartFtraceEvent::_internal_set_mask(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mask_ = value;
}

// -------------------------------------------------------------------

// IonCpAllocRetryFtraceEvent

// optional int32 tries = 1;
inline bool IonCpAllocRetryFtraceEvent::has_tries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonCpAllocRetryFtraceEvent::clear_tries() {
  _impl_.tries_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t IonCpAllocRetryFtraceEvent::tries() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpAllocRetryFtraceEvent.tries)
  return _internal_tries();
}
inline void IonCpAllocRetryFtraceEvent::set_tries(::int32_t value) {
  _internal_set_tries(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpAllocRetryFtraceEvent.tries)
}
inline ::int32_t IonCpAllocRetryFtraceEvent::_internal_tries() const {
  return _impl_.tries_;
}
inline void IonCpAllocRetryFtraceEvent::_internal_set_tries(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tries_ = value;
}

// -------------------------------------------------------------------

// IonCpSecureBufferEndFtraceEvent

// optional uint64 align = 1;
inline bool IonCpSecureBufferEndFtraceEvent::has_align() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonCpSecureBufferEndFtraceEvent::clear_align() {
  _impl_.align_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonCpSecureBufferEndFtraceEvent::align() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferEndFtraceEvent.align)
  return _internal_align();
}
inline void IonCpSecureBufferEndFtraceEvent::set_align(::uint64_t value) {
  _internal_set_align(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferEndFtraceEvent.align)
}
inline ::uint64_t IonCpSecureBufferEndFtraceEvent::_internal_align() const {
  return _impl_.align_;
}
inline void IonCpSecureBufferEndFtraceEvent::_internal_set_align(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.align_ = value;
}

// optional uint64 flags = 2;
inline bool IonCpSecureBufferEndFtraceEvent::has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonCpSecureBufferEndFtraceEvent::clear_flags() {
  _impl_.flags_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t IonCpSecureBufferEndFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferEndFtraceEvent.flags)
  return _internal_flags();
}
inline void IonCpSecureBufferEndFtraceEvent::set_flags(::uint64_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferEndFtraceEvent.flags)
}
inline ::uint64_t IonCpSecureBufferEndFtraceEvent::_internal_flags() const {
  return _impl_.flags_;
}
inline void IonCpSecureBufferEndFtraceEvent::_internal_set_flags(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.flags_ = value;
}

// optional string heap_name = 3;
inline bool IonCpSecureBufferEndFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonCpSecureBufferEndFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonCpSecureBufferEndFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonCpSecureBufferEndFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
}
inline std::string* IonCpSecureBufferEndFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonCpSecureBufferEndFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonCpSecureBufferEndFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonCpSecureBufferEndFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonCpSecureBufferEndFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonCpSecureBufferEndFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonCpSecureBufferEndFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonCpSecureBufferEndFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IonCpSecureBufferEndFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t IonCpSecureBufferEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferEndFtraceEvent.len)
  return _internal_len();
}
inline void IonCpSecureBufferEndFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferEndFtraceEvent.len)
}
inline ::uint64_t IonCpSecureBufferEndFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonCpSecureBufferEndFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.len_ = value;
}

// -------------------------------------------------------------------

// IonCpSecureBufferStartFtraceEvent

// optional uint64 align = 1;
inline bool IonCpSecureBufferStartFtraceEvent::has_align() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonCpSecureBufferStartFtraceEvent::clear_align() {
  _impl_.align_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonCpSecureBufferStartFtraceEvent::align() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferStartFtraceEvent.align)
  return _internal_align();
}
inline void IonCpSecureBufferStartFtraceEvent::set_align(::uint64_t value) {
  _internal_set_align(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferStartFtraceEvent.align)
}
inline ::uint64_t IonCpSecureBufferStartFtraceEvent::_internal_align() const {
  return _impl_.align_;
}
inline void IonCpSecureBufferStartFtraceEvent::_internal_set_align(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.align_ = value;
}

// optional uint64 flags = 2;
inline bool IonCpSecureBufferStartFtraceEvent::has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonCpSecureBufferStartFtraceEvent::clear_flags() {
  _impl_.flags_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t IonCpSecureBufferStartFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferStartFtraceEvent.flags)
  return _internal_flags();
}
inline void IonCpSecureBufferStartFtraceEvent::set_flags(::uint64_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferStartFtraceEvent.flags)
}
inline ::uint64_t IonCpSecureBufferStartFtraceEvent::_internal_flags() const {
  return _impl_.flags_;
}
inline void IonCpSecureBufferStartFtraceEvent::_internal_set_flags(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.flags_ = value;
}

// optional string heap_name = 3;
inline bool IonCpSecureBufferStartFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonCpSecureBufferStartFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonCpSecureBufferStartFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonCpSecureBufferStartFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
}
inline std::string* IonCpSecureBufferStartFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonCpSecureBufferStartFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonCpSecureBufferStartFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonCpSecureBufferStartFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonCpSecureBufferStartFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonCpSecureBufferStartFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonCpSecureBufferStartFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonCpSecureBufferStartFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IonCpSecureBufferStartFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t IonCpSecureBufferStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonCpSecureBufferStartFtraceEvent.len)
  return _internal_len();
}
inline void IonCpSecureBufferStartFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonCpSecureBufferStartFtraceEvent.len)
}
inline ::uint64_t IonCpSecureBufferStartFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonCpSecureBufferStartFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.len_ = value;
}

// -------------------------------------------------------------------

// IonPrefetchingFtraceEvent

// optional uint64 len = 1;
inline bool IonPrefetchingFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonPrefetchingFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IonPrefetchingFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonPrefetchingFtraceEvent.len)
  return _internal_len();
}
inline void IonPrefetchingFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonPrefetchingFtraceEvent.len)
}
inline ::uint64_t IonPrefetchingFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonPrefetchingFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.len_ = value;
}

// -------------------------------------------------------------------

// IonSecureCmaAddToPoolEndFtraceEvent

// optional uint32 is_prefetch = 1;
inline bool IonSecureCmaAddToPoolEndFtraceEvent::has_is_prefetch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::clear_is_prefetch() {
  _impl_.is_prefetch_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t IonSecureCmaAddToPoolEndFtraceEvent::is_prefetch() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.is_prefetch)
  return _internal_is_prefetch();
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::set_is_prefetch(::uint32_t value) {
  _internal_set_is_prefetch(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.is_prefetch)
}
inline ::uint32_t IonSecureCmaAddToPoolEndFtraceEvent::_internal_is_prefetch() const {
  return _impl_.is_prefetch_;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::_internal_set_is_prefetch(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_prefetch_ = value;
}

// optional uint64 len = 2;
inline bool IonSecureCmaAddToPoolEndFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IonSecureCmaAddToPoolEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.len)
  return _internal_len();
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.len)
}
inline ::uint64_t IonSecureCmaAddToPoolEndFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.len_ = value;
}

// optional int32 pool_total = 3;
inline bool IonSecureCmaAddToPoolEndFtraceEvent::has_pool_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::clear_pool_total() {
  _impl_.pool_total_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t IonSecureCmaAddToPoolEndFtraceEvent::pool_total() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.pool_total)
  return _internal_pool_total();
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::set_pool_total(::int32_t value) {
  _internal_set_pool_total(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent.pool_total)
}
inline ::int32_t IonSecureCmaAddToPoolEndFtraceEvent::_internal_pool_total() const {
  return _impl_.pool_total_;
}
inline void IonSecureCmaAddToPoolEndFtraceEvent::_internal_set_pool_total(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pool_total_ = value;
}

// -------------------------------------------------------------------

// IonSecureCmaAddToPoolStartFtraceEvent

// optional uint32 is_prefetch = 1;
inline bool IonSecureCmaAddToPoolStartFtraceEvent::has_is_prefetch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::clear_is_prefetch() {
  _impl_.is_prefetch_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t IonSecureCmaAddToPoolStartFtraceEvent::is_prefetch() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.is_prefetch)
  return _internal_is_prefetch();
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::set_is_prefetch(::uint32_t value) {
  _internal_set_is_prefetch(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.is_prefetch)
}
inline ::uint32_t IonSecureCmaAddToPoolStartFtraceEvent::_internal_is_prefetch() const {
  return _impl_.is_prefetch_;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::_internal_set_is_prefetch(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_prefetch_ = value;
}

// optional uint64 len = 2;
inline bool IonSecureCmaAddToPoolStartFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IonSecureCmaAddToPoolStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.len)
  return _internal_len();
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.len)
}
inline ::uint64_t IonSecureCmaAddToPoolStartFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.len_ = value;
}

// optional int32 pool_total = 3;
inline bool IonSecureCmaAddToPoolStartFtraceEvent::has_pool_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::clear_pool_total() {
  _impl_.pool_total_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t IonSecureCmaAddToPoolStartFtraceEvent::pool_total() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.pool_total)
  return _internal_pool_total();
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::set_pool_total(::int32_t value) {
  _internal_set_pool_total(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent.pool_total)
}
inline ::int32_t IonSecureCmaAddToPoolStartFtraceEvent::_internal_pool_total() const {
  return _impl_.pool_total_;
}
inline void IonSecureCmaAddToPoolStartFtraceEvent::_internal_set_pool_total(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pool_total_ = value;
}

// -------------------------------------------------------------------

// IonSecureCmaAllocateEndFtraceEvent

// optional uint64 align = 1;
inline bool IonSecureCmaAllocateEndFtraceEvent::has_align() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonSecureCmaAllocateEndFtraceEvent::clear_align() {
  _impl_.align_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonSecureCmaAllocateEndFtraceEvent::align() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.align)
  return _internal_align();
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_align(::uint64_t value) {
  _internal_set_align(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.align)
}
inline ::uint64_t IonSecureCmaAllocateEndFtraceEvent::_internal_align() const {
  return _impl_.align_;
}
inline void IonSecureCmaAllocateEndFtraceEvent::_internal_set_align(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.align_ = value;
}

// optional uint64 flags = 2;
inline bool IonSecureCmaAllocateEndFtraceEvent::has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonSecureCmaAllocateEndFtraceEvent::clear_flags() {
  _impl_.flags_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t IonSecureCmaAllocateEndFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.flags)
  return _internal_flags();
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_flags(::uint64_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.flags)
}
inline ::uint64_t IonSecureCmaAllocateEndFtraceEvent::_internal_flags() const {
  return _impl_.flags_;
}
inline void IonSecureCmaAllocateEndFtraceEvent::_internal_set_flags(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.flags_ = value;
}

// optional string heap_name = 3;
inline bool IonSecureCmaAllocateEndFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonSecureCmaAllocateEndFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonSecureCmaAllocateEndFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonSecureCmaAllocateEndFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
}
inline std::string* IonSecureCmaAllocateEndFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonSecureCmaAllocateEndFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonSecureCmaAllocateEndFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonSecureCmaAllocateEndFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonSecureCmaAllocateEndFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonSecureCmaAllocateEndFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IonSecureCmaAllocateEndFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t IonSecureCmaAllocateEndFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.len)
  return _internal_len();
}
inline void IonSecureCmaAllocateEndFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent.len)
}
inline ::uint64_t IonSecureCmaAllocateEndFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonSecureCmaAllocateEndFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.len_ = value;
}

// -------------------------------------------------------------------

// IonSecureCmaAllocateStartFtraceEvent

// optional uint64 align = 1;
inline bool IonSecureCmaAllocateStartFtraceEvent::has_align() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonSecureCmaAllocateStartFtraceEvent::clear_align() {
  _impl_.align_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonSecureCmaAllocateStartFtraceEvent::align() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.align)
  return _internal_align();
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_align(::uint64_t value) {
  _internal_set_align(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.align)
}
inline ::uint64_t IonSecureCmaAllocateStartFtraceEvent::_internal_align() const {
  return _impl_.align_;
}
inline void IonSecureCmaAllocateStartFtraceEvent::_internal_set_align(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.align_ = value;
}

// optional uint64 flags = 2;
inline bool IonSecureCmaAllocateStartFtraceEvent::has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonSecureCmaAllocateStartFtraceEvent::clear_flags() {
  _impl_.flags_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t IonSecureCmaAllocateStartFtraceEvent::flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.flags)
  return _internal_flags();
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_flags(::uint64_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.flags)
}
inline ::uint64_t IonSecureCmaAllocateStartFtraceEvent::_internal_flags() const {
  return _impl_.flags_;
}
inline void IonSecureCmaAllocateStartFtraceEvent::_internal_set_flags(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.flags_ = value;
}

// optional string heap_name = 3;
inline bool IonSecureCmaAllocateStartFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonSecureCmaAllocateStartFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonSecureCmaAllocateStartFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonSecureCmaAllocateStartFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
}
inline std::string* IonSecureCmaAllocateStartFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonSecureCmaAllocateStartFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonSecureCmaAllocateStartFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonSecureCmaAllocateStartFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonSecureCmaAllocateStartFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.heap_name)
}

// optional uint64 len = 4;
inline bool IonSecureCmaAllocateStartFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IonSecureCmaAllocateStartFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t IonSecureCmaAllocateStartFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.len)
  return _internal_len();
}
inline void IonSecureCmaAllocateStartFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent.len)
}
inline ::uint64_t IonSecureCmaAllocateStartFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonSecureCmaAllocateStartFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.len_ = value;
}

// -------------------------------------------------------------------

// IonSecureCmaShrinkPoolEndFtraceEvent

// optional uint64 drained_size = 1;
inline bool IonSecureCmaShrinkPoolEndFtraceEvent::has_drained_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::clear_drained_size() {
  _impl_.drained_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IonSecureCmaShrinkPoolEndFtraceEvent::drained_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent.drained_size)
  return _internal_drained_size();
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::set_drained_size(::uint64_t value) {
  _internal_set_drained_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent.drained_size)
}
inline ::uint64_t IonSecureCmaShrinkPoolEndFtraceEvent::_internal_drained_size() const {
  return _impl_.drained_size_;
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::_internal_set_drained_size(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.drained_size_ = value;
}

// optional uint64 skipped_size = 2;
inline bool IonSecureCmaShrinkPoolEndFtraceEvent::has_skipped_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::clear_skipped_size() {
  _impl_.skipped_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonSecureCmaShrinkPoolEndFtraceEvent::skipped_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent.skipped_size)
  return _internal_skipped_size();
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::set_skipped_size(::uint64_t value) {
  _internal_set_skipped_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent.skipped_size)
}
inline ::uint64_t IonSecureCmaShrinkPoolEndFtraceEvent::_internal_skipped_size() const {
  return _impl_.skipped_size_;
}
inline void IonSecureCmaShrinkPoolEndFtraceEvent::_internal_set_skipped_size(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.skipped_size_ = value;
}

// -------------------------------------------------------------------

// IonSecureCmaShrinkPoolStartFtraceEvent

// optional uint64 drained_size = 1;
inline bool IonSecureCmaShrinkPoolStartFtraceEvent::has_drained_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::clear_drained_size() {
  _impl_.drained_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IonSecureCmaShrinkPoolStartFtraceEvent::drained_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent.drained_size)
  return _internal_drained_size();
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::set_drained_size(::uint64_t value) {
  _internal_set_drained_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent.drained_size)
}
inline ::uint64_t IonSecureCmaShrinkPoolStartFtraceEvent::_internal_drained_size() const {
  return _impl_.drained_size_;
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::_internal_set_drained_size(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.drained_size_ = value;
}

// optional uint64 skipped_size = 2;
inline bool IonSecureCmaShrinkPoolStartFtraceEvent::has_skipped_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::clear_skipped_size() {
  _impl_.skipped_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonSecureCmaShrinkPoolStartFtraceEvent::skipped_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent.skipped_size)
  return _internal_skipped_size();
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::set_skipped_size(::uint64_t value) {
  _internal_set_skipped_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent.skipped_size)
}
inline ::uint64_t IonSecureCmaShrinkPoolStartFtraceEvent::_internal_skipped_size() const {
  return _impl_.skipped_size_;
}
inline void IonSecureCmaShrinkPoolStartFtraceEvent::_internal_set_skipped_size(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.skipped_size_ = value;
}

// -------------------------------------------------------------------

// KfreeFtraceEvent

// optional uint64 call_site = 1;
inline bool KfreeFtraceEvent::has_call_site() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KfreeFtraceEvent::clear_call_site() {
  _impl_.call_site_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t KfreeFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KfreeFtraceEvent.call_site)
  return _internal_call_site();
}
inline void KfreeFtraceEvent::set_call_site(::uint64_t value) {
  _internal_set_call_site(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KfreeFtraceEvent.call_site)
}
inline ::uint64_t KfreeFtraceEvent::_internal_call_site() const {
  return _impl_.call_site_;
}
inline void KfreeFtraceEvent::_internal_set_call_site(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.call_site_ = value;
}

// optional uint64 ptr = 2;
inline bool KfreeFtraceEvent::has_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KfreeFtraceEvent::clear_ptr() {
  _impl_.ptr_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t KfreeFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KfreeFtraceEvent.ptr)
  return _internal_ptr();
}
inline void KfreeFtraceEvent::set_ptr(::uint64_t value) {
  _internal_set_ptr(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KfreeFtraceEvent.ptr)
}
inline ::uint64_t KfreeFtraceEvent::_internal_ptr() const {
  return _impl_.ptr_;
}
inline void KfreeFtraceEvent::_internal_set_ptr(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ptr_ = value;
}

// -------------------------------------------------------------------

// KmallocFtraceEvent

// optional uint64 bytes_alloc = 1;
inline bool KmallocFtraceEvent::has_bytes_alloc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KmallocFtraceEvent::clear_bytes_alloc() {
  _impl_.bytes_alloc_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t KmallocFtraceEvent::bytes_alloc() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.bytes_alloc)
  return _internal_bytes_alloc();
}
inline void KmallocFtraceEvent::set_bytes_alloc(::uint64_t value) {
  _internal_set_bytes_alloc(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.bytes_alloc)
}
inline ::uint64_t KmallocFtraceEvent::_internal_bytes_alloc() const {
  return _impl_.bytes_alloc_;
}
inline void KmallocFtraceEvent::_internal_set_bytes_alloc(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bytes_alloc_ = value;
}

// optional uint64 bytes_req = 2;
inline bool KmallocFtraceEvent::has_bytes_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KmallocFtraceEvent::clear_bytes_req() {
  _impl_.bytes_req_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t KmallocFtraceEvent::bytes_req() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.bytes_req)
  return _internal_bytes_req();
}
inline void KmallocFtraceEvent::set_bytes_req(::uint64_t value) {
  _internal_set_bytes_req(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.bytes_req)
}
inline ::uint64_t KmallocFtraceEvent::_internal_bytes_req() const {
  return _impl_.bytes_req_;
}
inline void KmallocFtraceEvent::_internal_set_bytes_req(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bytes_req_ = value;
}

// optional uint64 call_site = 3;
inline bool KmallocFtraceEvent::has_call_site() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void KmallocFtraceEvent::clear_call_site() {
  _impl_.call_site_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t KmallocFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.call_site)
  return _internal_call_site();
}
inline void KmallocFtraceEvent::set_call_site(::uint64_t value) {
  _internal_set_call_site(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.call_site)
}
inline ::uint64_t KmallocFtraceEvent::_internal_call_site() const {
  return _impl_.call_site_;
}
inline void KmallocFtraceEvent::_internal_set_call_site(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.call_site_ = value;
}

// optional uint32 gfp_flags = 4;
inline bool KmallocFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void KmallocFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t KmallocFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void KmallocFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.gfp_flags)
}
inline ::uint32_t KmallocFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void KmallocFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.gfp_flags_ = value;
}

// optional uint64 ptr = 5;
inline bool KmallocFtraceEvent::has_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void KmallocFtraceEvent::clear_ptr() {
  _impl_.ptr_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t KmallocFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocFtraceEvent.ptr)
  return _internal_ptr();
}
inline void KmallocFtraceEvent::set_ptr(::uint64_t value) {
  _internal_set_ptr(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocFtraceEvent.ptr)
}
inline ::uint64_t KmallocFtraceEvent::_internal_ptr() const {
  return _impl_.ptr_;
}
inline void KmallocFtraceEvent::_internal_set_ptr(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ptr_ = value;
}

// -------------------------------------------------------------------

// KmallocNodeFtraceEvent

// optional uint64 bytes_alloc = 1;
inline bool KmallocNodeFtraceEvent::has_bytes_alloc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KmallocNodeFtraceEvent::clear_bytes_alloc() {
  _impl_.bytes_alloc_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t KmallocNodeFtraceEvent::bytes_alloc() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.bytes_alloc)
  return _internal_bytes_alloc();
}
inline void KmallocNodeFtraceEvent::set_bytes_alloc(::uint64_t value) {
  _internal_set_bytes_alloc(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.bytes_alloc)
}
inline ::uint64_t KmallocNodeFtraceEvent::_internal_bytes_alloc() const {
  return _impl_.bytes_alloc_;
}
inline void KmallocNodeFtraceEvent::_internal_set_bytes_alloc(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bytes_alloc_ = value;
}

// optional uint64 bytes_req = 2;
inline bool KmallocNodeFtraceEvent::has_bytes_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KmallocNodeFtraceEvent::clear_bytes_req() {
  _impl_.bytes_req_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t KmallocNodeFtraceEvent::bytes_req() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.bytes_req)
  return _internal_bytes_req();
}
inline void KmallocNodeFtraceEvent::set_bytes_req(::uint64_t value) {
  _internal_set_bytes_req(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.bytes_req)
}
inline ::uint64_t KmallocNodeFtraceEvent::_internal_bytes_req() const {
  return _impl_.bytes_req_;
}
inline void KmallocNodeFtraceEvent::_internal_set_bytes_req(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bytes_req_ = value;
}

// optional uint64 call_site = 3;
inline bool KmallocNodeFtraceEvent::has_call_site() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void KmallocNodeFtraceEvent::clear_call_site() {
  _impl_.call_site_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t KmallocNodeFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.call_site)
  return _internal_call_site();
}
inline void KmallocNodeFtraceEvent::set_call_site(::uint64_t value) {
  _internal_set_call_site(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.call_site)
}
inline ::uint64_t KmallocNodeFtraceEvent::_internal_call_site() const {
  return _impl_.call_site_;
}
inline void KmallocNodeFtraceEvent::_internal_set_call_site(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.call_site_ = value;
}

// optional uint32 gfp_flags = 4;
inline bool KmallocNodeFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void KmallocNodeFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t KmallocNodeFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void KmallocNodeFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.gfp_flags)
}
inline ::uint32_t KmallocNodeFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void KmallocNodeFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.gfp_flags_ = value;
}

// optional int32 node = 5;
inline bool KmallocNodeFtraceEvent::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void KmallocNodeFtraceEvent::clear_node() {
  _impl_.node_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t KmallocNodeFtraceEvent::node() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.node)
  return _internal_node();
}
inline void KmallocNodeFtraceEvent::set_node(::int32_t value) {
  _internal_set_node(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.node)
}
inline ::int32_t KmallocNodeFtraceEvent::_internal_node() const {
  return _impl_.node_;
}
inline void KmallocNodeFtraceEvent::_internal_set_node(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.node_ = value;
}

// optional uint64 ptr = 6;
inline bool KmallocNodeFtraceEvent::has_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void KmallocNodeFtraceEvent::clear_ptr() {
  _impl_.ptr_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t KmallocNodeFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmallocNodeFtraceEvent.ptr)
  return _internal_ptr();
}
inline void KmallocNodeFtraceEvent::set_ptr(::uint64_t value) {
  _internal_set_ptr(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmallocNodeFtraceEvent.ptr)
}
inline ::uint64_t KmallocNodeFtraceEvent::_internal_ptr() const {
  return _impl_.ptr_;
}
inline void KmallocNodeFtraceEvent::_internal_set_ptr(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ptr_ = value;
}

// -------------------------------------------------------------------

// KmemCacheAllocFtraceEvent

// optional uint64 bytes_alloc = 1;
inline bool KmemCacheAllocFtraceEvent::has_bytes_alloc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KmemCacheAllocFtraceEvent::clear_bytes_alloc() {
  _impl_.bytes_alloc_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t KmemCacheAllocFtraceEvent::bytes_alloc() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.bytes_alloc)
  return _internal_bytes_alloc();
}
inline void KmemCacheAllocFtraceEvent::set_bytes_alloc(::uint64_t value) {
  _internal_set_bytes_alloc(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.bytes_alloc)
}
inline ::uint64_t KmemCacheAllocFtraceEvent::_internal_bytes_alloc() const {
  return _impl_.bytes_alloc_;
}
inline void KmemCacheAllocFtraceEvent::_internal_set_bytes_alloc(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bytes_alloc_ = value;
}

// optional uint64 bytes_req = 2;
inline bool KmemCacheAllocFtraceEvent::has_bytes_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KmemCacheAllocFtraceEvent::clear_bytes_req() {
  _impl_.bytes_req_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t KmemCacheAllocFtraceEvent::bytes_req() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.bytes_req)
  return _internal_bytes_req();
}
inline void KmemCacheAllocFtraceEvent::set_bytes_req(::uint64_t value) {
  _internal_set_bytes_req(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.bytes_req)
}
inline ::uint64_t KmemCacheAllocFtraceEvent::_internal_bytes_req() const {
  return _impl_.bytes_req_;
}
inline void KmemCacheAllocFtraceEvent::_internal_set_bytes_req(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bytes_req_ = value;
}

// optional uint64 call_site = 3;
inline bool KmemCacheAllocFtraceEvent::has_call_site() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void KmemCacheAllocFtraceEvent::clear_call_site() {
  _impl_.call_site_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t KmemCacheAllocFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.call_site)
  return _internal_call_site();
}
inline void KmemCacheAllocFtraceEvent::set_call_site(::uint64_t value) {
  _internal_set_call_site(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.call_site)
}
inline ::uint64_t KmemCacheAllocFtraceEvent::_internal_call_site() const {
  return _impl_.call_site_;
}
inline void KmemCacheAllocFtraceEvent::_internal_set_call_site(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.call_site_ = value;
}

// optional uint32 gfp_flags = 4;
inline bool KmemCacheAllocFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void KmemCacheAllocFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t KmemCacheAllocFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void KmemCacheAllocFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.gfp_flags)
}
inline ::uint32_t KmemCacheAllocFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void KmemCacheAllocFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.gfp_flags_ = value;
}

// optional uint64 ptr = 5;
inline bool KmemCacheAllocFtraceEvent::has_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void KmemCacheAllocFtraceEvent::clear_ptr() {
  _impl_.ptr_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t KmemCacheAllocFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocFtraceEvent.ptr)
  return _internal_ptr();
}
inline void KmemCacheAllocFtraceEvent::set_ptr(::uint64_t value) {
  _internal_set_ptr(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocFtraceEvent.ptr)
}
inline ::uint64_t KmemCacheAllocFtraceEvent::_internal_ptr() const {
  return _impl_.ptr_;
}
inline void KmemCacheAllocFtraceEvent::_internal_set_ptr(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ptr_ = value;
}

// -------------------------------------------------------------------

// KmemCacheAllocNodeFtraceEvent

// optional uint64 bytes_alloc = 1;
inline bool KmemCacheAllocNodeFtraceEvent::has_bytes_alloc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_bytes_alloc() {
  _impl_.bytes_alloc_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t KmemCacheAllocNodeFtraceEvent::bytes_alloc() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.bytes_alloc)
  return _internal_bytes_alloc();
}
inline void KmemCacheAllocNodeFtraceEvent::set_bytes_alloc(::uint64_t value) {
  _internal_set_bytes_alloc(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.bytes_alloc)
}
inline ::uint64_t KmemCacheAllocNodeFtraceEvent::_internal_bytes_alloc() const {
  return _impl_.bytes_alloc_;
}
inline void KmemCacheAllocNodeFtraceEvent::_internal_set_bytes_alloc(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bytes_alloc_ = value;
}

// optional uint64 bytes_req = 2;
inline bool KmemCacheAllocNodeFtraceEvent::has_bytes_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_bytes_req() {
  _impl_.bytes_req_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t KmemCacheAllocNodeFtraceEvent::bytes_req() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.bytes_req)
  return _internal_bytes_req();
}
inline void KmemCacheAllocNodeFtraceEvent::set_bytes_req(::uint64_t value) {
  _internal_set_bytes_req(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.bytes_req)
}
inline ::uint64_t KmemCacheAllocNodeFtraceEvent::_internal_bytes_req() const {
  return _impl_.bytes_req_;
}
inline void KmemCacheAllocNodeFtraceEvent::_internal_set_bytes_req(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bytes_req_ = value;
}

// optional uint64 call_site = 3;
inline bool KmemCacheAllocNodeFtraceEvent::has_call_site() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_call_site() {
  _impl_.call_site_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t KmemCacheAllocNodeFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.call_site)
  return _internal_call_site();
}
inline void KmemCacheAllocNodeFtraceEvent::set_call_site(::uint64_t value) {
  _internal_set_call_site(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.call_site)
}
inline ::uint64_t KmemCacheAllocNodeFtraceEvent::_internal_call_site() const {
  return _impl_.call_site_;
}
inline void KmemCacheAllocNodeFtraceEvent::_internal_set_call_site(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.call_site_ = value;
}

// optional uint32 gfp_flags = 4;
inline bool KmemCacheAllocNodeFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t KmemCacheAllocNodeFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void KmemCacheAllocNodeFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.gfp_flags)
}
inline ::uint32_t KmemCacheAllocNodeFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void KmemCacheAllocNodeFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.gfp_flags_ = value;
}

// optional int32 node = 5;
inline bool KmemCacheAllocNodeFtraceEvent::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_node() {
  _impl_.node_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t KmemCacheAllocNodeFtraceEvent::node() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.node)
  return _internal_node();
}
inline void KmemCacheAllocNodeFtraceEvent::set_node(::int32_t value) {
  _internal_set_node(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.node)
}
inline ::int32_t KmemCacheAllocNodeFtraceEvent::_internal_node() const {
  return _impl_.node_;
}
inline void KmemCacheAllocNodeFtraceEvent::_internal_set_node(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.node_ = value;
}

// optional uint64 ptr = 6;
inline bool KmemCacheAllocNodeFtraceEvent::has_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void KmemCacheAllocNodeFtraceEvent::clear_ptr() {
  _impl_.ptr_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t KmemCacheAllocNodeFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheAllocNodeFtraceEvent.ptr)
  return _internal_ptr();
}
inline void KmemCacheAllocNodeFtraceEvent::set_ptr(::uint64_t value) {
  _internal_set_ptr(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheAllocNodeFtraceEvent.ptr)
}
inline ::uint64_t KmemCacheAllocNodeFtraceEvent::_internal_ptr() const {
  return _impl_.ptr_;
}
inline void KmemCacheAllocNodeFtraceEvent::_internal_set_ptr(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ptr_ = value;
}

// -------------------------------------------------------------------

// KmemCacheFreeFtraceEvent

// optional uint64 call_site = 1;
inline bool KmemCacheFreeFtraceEvent::has_call_site() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KmemCacheFreeFtraceEvent::clear_call_site() {
  _impl_.call_site_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t KmemCacheFreeFtraceEvent::call_site() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheFreeFtraceEvent.call_site)
  return _internal_call_site();
}
inline void KmemCacheFreeFtraceEvent::set_call_site(::uint64_t value) {
  _internal_set_call_site(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheFreeFtraceEvent.call_site)
}
inline ::uint64_t KmemCacheFreeFtraceEvent::_internal_call_site() const {
  return _impl_.call_site_;
}
inline void KmemCacheFreeFtraceEvent::_internal_set_call_site(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.call_site_ = value;
}

// optional uint64 ptr = 2;
inline bool KmemCacheFreeFtraceEvent::has_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KmemCacheFreeFtraceEvent::clear_ptr() {
  _impl_.ptr_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t KmemCacheFreeFtraceEvent::ptr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.KmemCacheFreeFtraceEvent.ptr)
  return _internal_ptr();
}
inline void KmemCacheFreeFtraceEvent::set_ptr(::uint64_t value) {
  _internal_set_ptr(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.KmemCacheFreeFtraceEvent.ptr)
}
inline ::uint64_t KmemCacheFreeFtraceEvent::_internal_ptr() const {
  return _impl_.ptr_;
}
inline void KmemCacheFreeFtraceEvent::_internal_set_ptr(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ptr_ = value;
}

// -------------------------------------------------------------------

// MigratePagesEndFtraceEvent

// optional int32 mode = 1;
inline bool MigratePagesEndFtraceEvent::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MigratePagesEndFtraceEvent::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MigratePagesEndFtraceEvent::mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MigratePagesEndFtraceEvent.mode)
  return _internal_mode();
}
inline void MigratePagesEndFtraceEvent::set_mode(::int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MigratePagesEndFtraceEvent.mode)
}
inline ::int32_t MigratePagesEndFtraceEvent::_internal_mode() const {
  return _impl_.mode_;
}
inline void MigratePagesEndFtraceEvent::_internal_set_mode(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mode_ = value;
}

// -------------------------------------------------------------------

// MigratePagesStartFtraceEvent

// optional int32 mode = 1;
inline bool MigratePagesStartFtraceEvent::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MigratePagesStartFtraceEvent::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MigratePagesStartFtraceEvent::mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MigratePagesStartFtraceEvent.mode)
  return _internal_mode();
}
inline void MigratePagesStartFtraceEvent::set_mode(::int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MigratePagesStartFtraceEvent.mode)
}
inline ::int32_t MigratePagesStartFtraceEvent::_internal_mode() const {
  return _impl_.mode_;
}
inline void MigratePagesStartFtraceEvent::_internal_set_mode(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mode_ = value;
}

// -------------------------------------------------------------------

// MigrateRetryFtraceEvent

// optional int32 tries = 1;
inline bool MigrateRetryFtraceEvent::has_tries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MigrateRetryFtraceEvent::clear_tries() {
  _impl_.tries_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MigrateRetryFtraceEvent::tries() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MigrateRetryFtraceEvent.tries)
  return _internal_tries();
}
inline void MigrateRetryFtraceEvent::set_tries(::int32_t value) {
  _internal_set_tries(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MigrateRetryFtraceEvent.tries)
}
inline ::int32_t MigrateRetryFtraceEvent::_internal_tries() const {
  return _impl_.tries_;
}
inline void MigrateRetryFtraceEvent::_internal_set_tries(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tries_ = value;
}

// -------------------------------------------------------------------

// MmPageAllocFtraceEvent

// optional uint32 gfp_flags = 1;
inline bool MmPageAllocFtraceEvent::has_gfp_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MmPageAllocFtraceEvent::clear_gfp_flags() {
  _impl_.gfp_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t MmPageAllocFtraceEvent::gfp_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.gfp_flags)
  return _internal_gfp_flags();
}
inline void MmPageAllocFtraceEvent::set_gfp_flags(::uint32_t value) {
  _internal_set_gfp_flags(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.gfp_flags)
}
inline ::uint32_t MmPageAllocFtraceEvent::_internal_gfp_flags() const {
  return _impl_.gfp_flags_;
}
inline void MmPageAllocFtraceEvent::_internal_set_gfp_flags(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gfp_flags_ = value;
}

// optional int32 migratetype = 2;
inline bool MmPageAllocFtraceEvent::has_migratetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MmPageAllocFtraceEvent::clear_migratetype() {
  _impl_.migratetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MmPageAllocFtraceEvent::migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.migratetype)
  return _internal_migratetype();
}
inline void MmPageAllocFtraceEvent::set_migratetype(::int32_t value) {
  _internal_set_migratetype(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.migratetype)
}
inline ::int32_t MmPageAllocFtraceEvent::_internal_migratetype() const {
  return _impl_.migratetype_;
}
inline void MmPageAllocFtraceEvent::_internal_set_migratetype(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.migratetype_ = value;
}

// optional uint32 order = 3;
inline bool MmPageAllocFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MmPageAllocFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t MmPageAllocFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.order)
  return _internal_order();
}
inline void MmPageAllocFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.order)
}
inline ::uint32_t MmPageAllocFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void MmPageAllocFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.order_ = value;
}

// optional uint64 page = 4;
inline bool MmPageAllocFtraceEvent::has_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MmPageAllocFtraceEvent::clear_page() {
  _impl_.page_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t MmPageAllocFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.page)
  return _internal_page();
}
inline void MmPageAllocFtraceEvent::set_page(::uint64_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.page)
}
inline ::uint64_t MmPageAllocFtraceEvent::_internal_page() const {
  return _impl_.page_;
}
inline void MmPageAllocFtraceEvent::_internal_set_page(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.page_ = value;
}

// optional uint64 pfn = 5;
inline bool MmPageAllocFtraceEvent::has_pfn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MmPageAllocFtraceEvent::clear_pfn() {
  _impl_.pfn_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t MmPageAllocFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocFtraceEvent.pfn)
  return _internal_pfn();
}
inline void MmPageAllocFtraceEvent::set_pfn(::uint64_t value) {
  _internal_set_pfn(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocFtraceEvent.pfn)
}
inline ::uint64_t MmPageAllocFtraceEvent::_internal_pfn() const {
  return _impl_.pfn_;
}
inline void MmPageAllocFtraceEvent::_internal_set_pfn(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pfn_ = value;
}

// -------------------------------------------------------------------

// MmPageAllocExtfragFtraceEvent

// optional int32 alloc_migratetype = 1;
inline bool MmPageAllocExtfragFtraceEvent::has_alloc_migratetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MmPageAllocExtfragFtraceEvent::clear_alloc_migratetype() {
  _impl_.alloc_migratetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::alloc_migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.alloc_migratetype)
  return _internal_alloc_migratetype();
}
inline void MmPageAllocExtfragFtraceEvent::set_alloc_migratetype(::int32_t value) {
  _internal_set_alloc_migratetype(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.alloc_migratetype)
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::_internal_alloc_migratetype() const {
  return _impl_.alloc_migratetype_;
}
inline void MmPageAllocExtfragFtraceEvent::_internal_set_alloc_migratetype(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.alloc_migratetype_ = value;
}

// optional int32 alloc_order = 2;
inline bool MmPageAllocExtfragFtraceEvent::has_alloc_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MmPageAllocExtfragFtraceEvent::clear_alloc_order() {
  _impl_.alloc_order_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::alloc_order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.alloc_order)
  return _internal_alloc_order();
}
inline void MmPageAllocExtfragFtraceEvent::set_alloc_order(::int32_t value) {
  _internal_set_alloc_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.alloc_order)
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::_internal_alloc_order() const {
  return _impl_.alloc_order_;
}
inline void MmPageAllocExtfragFtraceEvent::_internal_set_alloc_order(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.alloc_order_ = value;
}

// optional int32 fallback_migratetype = 3;
inline bool MmPageAllocExtfragFtraceEvent::has_fallback_migratetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MmPageAllocExtfragFtraceEvent::clear_fallback_migratetype() {
  _impl_.fallback_migratetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::fallback_migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.fallback_migratetype)
  return _internal_fallback_migratetype();
}
inline void MmPageAllocExtfragFtraceEvent::set_fallback_migratetype(::int32_t value) {
  _internal_set_fallback_migratetype(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.fallback_migratetype)
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::_internal_fallback_migratetype() const {
  return _impl_.fallback_migratetype_;
}
inline void MmPageAllocExtfragFtraceEvent::_internal_set_fallback_migratetype(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fallback_migratetype_ = value;
}

// optional int32 fallback_order = 4;
inline bool MmPageAllocExtfragFtraceEvent::has_fallback_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MmPageAllocExtfragFtraceEvent::clear_fallback_order() {
  _impl_.fallback_order_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::fallback_order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.fallback_order)
  return _internal_fallback_order();
}
inline void MmPageAllocExtfragFtraceEvent::set_fallback_order(::int32_t value) {
  _internal_set_fallback_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.fallback_order)
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::_internal_fallback_order() const {
  return _impl_.fallback_order_;
}
inline void MmPageAllocExtfragFtraceEvent::_internal_set_fallback_order(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fallback_order_ = value;
}

// optional uint64 page = 5;
inline bool MmPageAllocExtfragFtraceEvent::has_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MmPageAllocExtfragFtraceEvent::clear_page() {
  _impl_.page_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t MmPageAllocExtfragFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.page)
  return _internal_page();
}
inline void MmPageAllocExtfragFtraceEvent::set_page(::uint64_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.page)
}
inline ::uint64_t MmPageAllocExtfragFtraceEvent::_internal_page() const {
  return _impl_.page_;
}
inline void MmPageAllocExtfragFtraceEvent::_internal_set_page(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.page_ = value;
}

// optional int32 change_ownership = 6;
inline bool MmPageAllocExtfragFtraceEvent::has_change_ownership() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MmPageAllocExtfragFtraceEvent::clear_change_ownership() {
  _impl_.change_ownership_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::change_ownership() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.change_ownership)
  return _internal_change_ownership();
}
inline void MmPageAllocExtfragFtraceEvent::set_change_ownership(::int32_t value) {
  _internal_set_change_ownership(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.change_ownership)
}
inline ::int32_t MmPageAllocExtfragFtraceEvent::_internal_change_ownership() const {
  return _impl_.change_ownership_;
}
inline void MmPageAllocExtfragFtraceEvent::_internal_set_change_ownership(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.change_ownership_ = value;
}

// optional uint64 pfn = 7;
inline bool MmPageAllocExtfragFtraceEvent::has_pfn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MmPageAllocExtfragFtraceEvent::clear_pfn() {
  _impl_.pfn_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t MmPageAllocExtfragFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocExtfragFtraceEvent.pfn)
  return _internal_pfn();
}
inline void MmPageAllocExtfragFtraceEvent::set_pfn(::uint64_t value) {
  _internal_set_pfn(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocExtfragFtraceEvent.pfn)
}
inline ::uint64_t MmPageAllocExtfragFtraceEvent::_internal_pfn() const {
  return _impl_.pfn_;
}
inline void MmPageAllocExtfragFtraceEvent::_internal_set_pfn(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.pfn_ = value;
}

// -------------------------------------------------------------------

// MmPageAllocZoneLockedFtraceEvent

// optional int32 migratetype = 1;
inline bool MmPageAllocZoneLockedFtraceEvent::has_migratetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MmPageAllocZoneLockedFtraceEvent::clear_migratetype() {
  _impl_.migratetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MmPageAllocZoneLockedFtraceEvent::migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.migratetype)
  return _internal_migratetype();
}
inline void MmPageAllocZoneLockedFtraceEvent::set_migratetype(::int32_t value) {
  _internal_set_migratetype(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.migratetype)
}
inline ::int32_t MmPageAllocZoneLockedFtraceEvent::_internal_migratetype() const {
  return _impl_.migratetype_;
}
inline void MmPageAllocZoneLockedFtraceEvent::_internal_set_migratetype(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.migratetype_ = value;
}

// optional uint32 order = 2;
inline bool MmPageAllocZoneLockedFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MmPageAllocZoneLockedFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t MmPageAllocZoneLockedFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.order)
  return _internal_order();
}
inline void MmPageAllocZoneLockedFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.order)
}
inline ::uint32_t MmPageAllocZoneLockedFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void MmPageAllocZoneLockedFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.order_ = value;
}

// optional uint64 page = 3;
inline bool MmPageAllocZoneLockedFtraceEvent::has_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MmPageAllocZoneLockedFtraceEvent::clear_page() {
  _impl_.page_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t MmPageAllocZoneLockedFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.page)
  return _internal_page();
}
inline void MmPageAllocZoneLockedFtraceEvent::set_page(::uint64_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.page)
}
inline ::uint64_t MmPageAllocZoneLockedFtraceEvent::_internal_page() const {
  return _impl_.page_;
}
inline void MmPageAllocZoneLockedFtraceEvent::_internal_set_page(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.page_ = value;
}

// optional uint64 pfn = 4;
inline bool MmPageAllocZoneLockedFtraceEvent::has_pfn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MmPageAllocZoneLockedFtraceEvent::clear_pfn() {
  _impl_.pfn_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t MmPageAllocZoneLockedFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.pfn)
  return _internal_pfn();
}
inline void MmPageAllocZoneLockedFtraceEvent::set_pfn(::uint64_t value) {
  _internal_set_pfn(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageAllocZoneLockedFtraceEvent.pfn)
}
inline ::uint64_t MmPageAllocZoneLockedFtraceEvent::_internal_pfn() const {
  return _impl_.pfn_;
}
inline void MmPageAllocZoneLockedFtraceEvent::_internal_set_pfn(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pfn_ = value;
}

// -------------------------------------------------------------------

// MmPageFreeFtraceEvent

// optional uint32 order = 1;
inline bool MmPageFreeFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MmPageFreeFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t MmPageFreeFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeFtraceEvent.order)
  return _internal_order();
}
inline void MmPageFreeFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeFtraceEvent.order)
}
inline ::uint32_t MmPageFreeFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void MmPageFreeFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.order_ = value;
}

// optional uint64 page = 2;
inline bool MmPageFreeFtraceEvent::has_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MmPageFreeFtraceEvent::clear_page() {
  _impl_.page_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t MmPageFreeFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeFtraceEvent.page)
  return _internal_page();
}
inline void MmPageFreeFtraceEvent::set_page(::uint64_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeFtraceEvent.page)
}
inline ::uint64_t MmPageFreeFtraceEvent::_internal_page() const {
  return _impl_.page_;
}
inline void MmPageFreeFtraceEvent::_internal_set_page(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_ = value;
}

// optional uint64 pfn = 3;
inline bool MmPageFreeFtraceEvent::has_pfn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MmPageFreeFtraceEvent::clear_pfn() {
  _impl_.pfn_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t MmPageFreeFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeFtraceEvent.pfn)
  return _internal_pfn();
}
inline void MmPageFreeFtraceEvent::set_pfn(::uint64_t value) {
  _internal_set_pfn(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeFtraceEvent.pfn)
}
inline ::uint64_t MmPageFreeFtraceEvent::_internal_pfn() const {
  return _impl_.pfn_;
}
inline void MmPageFreeFtraceEvent::_internal_set_pfn(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pfn_ = value;
}

// -------------------------------------------------------------------

// MmPageFreeBatchedFtraceEvent

// optional int32 cold = 1;
inline bool MmPageFreeBatchedFtraceEvent::has_cold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MmPageFreeBatchedFtraceEvent::clear_cold() {
  _impl_.cold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MmPageFreeBatchedFtraceEvent::cold() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeBatchedFtraceEvent.cold)
  return _internal_cold();
}
inline void MmPageFreeBatchedFtraceEvent::set_cold(::int32_t value) {
  _internal_set_cold(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeBatchedFtraceEvent.cold)
}
inline ::int32_t MmPageFreeBatchedFtraceEvent::_internal_cold() const {
  return _impl_.cold_;
}
inline void MmPageFreeBatchedFtraceEvent::_internal_set_cold(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cold_ = value;
}

// optional uint64 page = 2;
inline bool MmPageFreeBatchedFtraceEvent::has_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MmPageFreeBatchedFtraceEvent::clear_page() {
  _impl_.page_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t MmPageFreeBatchedFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeBatchedFtraceEvent.page)
  return _internal_page();
}
inline void MmPageFreeBatchedFtraceEvent::set_page(::uint64_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeBatchedFtraceEvent.page)
}
inline ::uint64_t MmPageFreeBatchedFtraceEvent::_internal_page() const {
  return _impl_.page_;
}
inline void MmPageFreeBatchedFtraceEvent::_internal_set_page(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.page_ = value;
}

// optional uint64 pfn = 3;
inline bool MmPageFreeBatchedFtraceEvent::has_pfn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MmPageFreeBatchedFtraceEvent::clear_pfn() {
  _impl_.pfn_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t MmPageFreeBatchedFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPageFreeBatchedFtraceEvent.pfn)
  return _internal_pfn();
}
inline void MmPageFreeBatchedFtraceEvent::set_pfn(::uint64_t value) {
  _internal_set_pfn(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPageFreeBatchedFtraceEvent.pfn)
}
inline ::uint64_t MmPageFreeBatchedFtraceEvent::_internal_pfn() const {
  return _impl_.pfn_;
}
inline void MmPageFreeBatchedFtraceEvent::_internal_set_pfn(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pfn_ = value;
}

// -------------------------------------------------------------------

// MmPagePcpuDrainFtraceEvent

// optional int32 migratetype = 1;
inline bool MmPagePcpuDrainFtraceEvent::has_migratetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MmPagePcpuDrainFtraceEvent::clear_migratetype() {
  _impl_.migratetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MmPagePcpuDrainFtraceEvent::migratetype() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPagePcpuDrainFtraceEvent.migratetype)
  return _internal_migratetype();
}
inline void MmPagePcpuDrainFtraceEvent::set_migratetype(::int32_t value) {
  _internal_set_migratetype(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPagePcpuDrainFtraceEvent.migratetype)
}
inline ::int32_t MmPagePcpuDrainFtraceEvent::_internal_migratetype() const {
  return _impl_.migratetype_;
}
inline void MmPagePcpuDrainFtraceEvent::_internal_set_migratetype(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.migratetype_ = value;
}

// optional uint32 order = 2;
inline bool MmPagePcpuDrainFtraceEvent::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MmPagePcpuDrainFtraceEvent::clear_order() {
  _impl_.order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t MmPagePcpuDrainFtraceEvent::order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPagePcpuDrainFtraceEvent.order)
  return _internal_order();
}
inline void MmPagePcpuDrainFtraceEvent::set_order(::uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPagePcpuDrainFtraceEvent.order)
}
inline ::uint32_t MmPagePcpuDrainFtraceEvent::_internal_order() const {
  return _impl_.order_;
}
inline void MmPagePcpuDrainFtraceEvent::_internal_set_order(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.order_ = value;
}

// optional uint64 page = 3;
inline bool MmPagePcpuDrainFtraceEvent::has_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MmPagePcpuDrainFtraceEvent::clear_page() {
  _impl_.page_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t MmPagePcpuDrainFtraceEvent::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPagePcpuDrainFtraceEvent.page)
  return _internal_page();
}
inline void MmPagePcpuDrainFtraceEvent::set_page(::uint64_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPagePcpuDrainFtraceEvent.page)
}
inline ::uint64_t MmPagePcpuDrainFtraceEvent::_internal_page() const {
  return _impl_.page_;
}
inline void MmPagePcpuDrainFtraceEvent::_internal_set_page(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.page_ = value;
}

// optional uint64 pfn = 4;
inline bool MmPagePcpuDrainFtraceEvent::has_pfn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MmPagePcpuDrainFtraceEvent::clear_pfn() {
  _impl_.pfn_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t MmPagePcpuDrainFtraceEvent::pfn() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.MmPagePcpuDrainFtraceEvent.pfn)
  return _internal_pfn();
}
inline void MmPagePcpuDrainFtraceEvent::set_pfn(::uint64_t value) {
  _internal_set_pfn(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.MmPagePcpuDrainFtraceEvent.pfn)
}
inline ::uint64_t MmPagePcpuDrainFtraceEvent::_internal_pfn() const {
  return _impl_.pfn_;
}
inline void MmPagePcpuDrainFtraceEvent::_internal_set_pfn(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pfn_ = value;
}

// -------------------------------------------------------------------

// RssStatFtraceEvent

// optional int32 member = 1;
inline bool RssStatFtraceEvent::has_member() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RssStatFtraceEvent::clear_member() {
  _impl_.member_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t RssStatFtraceEvent::member() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RssStatFtraceEvent.member)
  return _internal_member();
}
inline void RssStatFtraceEvent::set_member(::int32_t value) {
  _internal_set_member(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.RssStatFtraceEvent.member)
}
inline ::int32_t RssStatFtraceEvent::_internal_member() const {
  return _impl_.member_;
}
inline void RssStatFtraceEvent::_internal_set_member(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.member_ = value;
}

// optional int64 size = 2;
inline bool RssStatFtraceEvent::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RssStatFtraceEvent::clear_size() {
  _impl_.size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t RssStatFtraceEvent::size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RssStatFtraceEvent.size)
  return _internal_size();
}
inline void RssStatFtraceEvent::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.RssStatFtraceEvent.size)
}
inline ::int64_t RssStatFtraceEvent::_internal_size() const {
  return _impl_.size_;
}
inline void RssStatFtraceEvent::_internal_set_size(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}

// optional uint32 curr = 3;
inline bool RssStatFtraceEvent::has_curr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RssStatFtraceEvent::clear_curr() {
  _impl_.curr_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t RssStatFtraceEvent::curr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RssStatFtraceEvent.curr)
  return _internal_curr();
}
inline void RssStatFtraceEvent::set_curr(::uint32_t value) {
  _internal_set_curr(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.RssStatFtraceEvent.curr)
}
inline ::uint32_t RssStatFtraceEvent::_internal_curr() const {
  return _impl_.curr_;
}
inline void RssStatFtraceEvent::_internal_set_curr(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.curr_ = value;
}

// optional uint32 mm_id = 4;
inline bool RssStatFtraceEvent::has_mm_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RssStatFtraceEvent::clear_mm_id() {
  _impl_.mm_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RssStatFtraceEvent::mm_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RssStatFtraceEvent.mm_id)
  return _internal_mm_id();
}
inline void RssStatFtraceEvent::set_mm_id(::uint32_t value) {
  _internal_set_mm_id(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.RssStatFtraceEvent.mm_id)
}
inline ::uint32_t RssStatFtraceEvent::_internal_mm_id() const {
  return _impl_.mm_id_;
}
inline void RssStatFtraceEvent::_internal_set_mm_id(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mm_id_ = value;
}

// -------------------------------------------------------------------

// IonHeapShrinkFtraceEvent

// optional string heap_name = 1;
inline bool IonHeapShrinkFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonHeapShrinkFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonHeapShrinkFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonHeapShrinkFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
}
inline std::string* IonHeapShrinkFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonHeapShrinkFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonHeapShrinkFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonHeapShrinkFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonHeapShrinkFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonHeapShrinkFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonHeapShrinkFtraceEvent.heap_name)
}

// optional uint64 len = 2;
inline bool IonHeapShrinkFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonHeapShrinkFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonHeapShrinkFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapShrinkFtraceEvent.len)
  return _internal_len();
}
inline void IonHeapShrinkFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapShrinkFtraceEvent.len)
}
inline ::uint64_t IonHeapShrinkFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonHeapShrinkFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.len_ = value;
}

// optional int64 total_allocated = 3;
inline bool IonHeapShrinkFtraceEvent::has_total_allocated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonHeapShrinkFtraceEvent::clear_total_allocated() {
  _impl_.total_allocated_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t IonHeapShrinkFtraceEvent::total_allocated() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapShrinkFtraceEvent.total_allocated)
  return _internal_total_allocated();
}
inline void IonHeapShrinkFtraceEvent::set_total_allocated(::int64_t value) {
  _internal_set_total_allocated(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapShrinkFtraceEvent.total_allocated)
}
inline ::int64_t IonHeapShrinkFtraceEvent::_internal_total_allocated() const {
  return _impl_.total_allocated_;
}
inline void IonHeapShrinkFtraceEvent::_internal_set_total_allocated(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.total_allocated_ = value;
}

// -------------------------------------------------------------------

// IonHeapGrowFtraceEvent

// optional string heap_name = 1;
inline bool IonHeapGrowFtraceEvent::has_heap_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonHeapGrowFtraceEvent::clear_heap_name() {
  _impl_.heap_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IonHeapGrowFtraceEvent::heap_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
  return _internal_heap_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IonHeapGrowFtraceEvent::set_heap_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.heap_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
}
inline std::string* IonHeapGrowFtraceEvent::mutable_heap_name() {
  std::string* _s = _internal_mutable_heap_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
  return _s;
}
inline const std::string& IonHeapGrowFtraceEvent::_internal_heap_name() const {
  return _impl_.heap_name_.Get();
}
inline void IonHeapGrowFtraceEvent::_internal_set_heap_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.heap_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IonHeapGrowFtraceEvent::_internal_mutable_heap_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.heap_name_.Mutable( GetArenaForAllocation());
}
inline std::string* IonHeapGrowFtraceEvent::release_heap_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.heap_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IonHeapGrowFtraceEvent::set_allocated_heap_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.heap_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heap_name_.IsDefault()) {
          _impl_.heap_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.IonHeapGrowFtraceEvent.heap_name)
}

// optional uint64 len = 2;
inline bool IonHeapGrowFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonHeapGrowFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonHeapGrowFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapGrowFtraceEvent.len)
  return _internal_len();
}
inline void IonHeapGrowFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapGrowFtraceEvent.len)
}
inline ::uint64_t IonHeapGrowFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonHeapGrowFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.len_ = value;
}

// optional int64 total_allocated = 3;
inline bool IonHeapGrowFtraceEvent::has_total_allocated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IonHeapGrowFtraceEvent::clear_total_allocated() {
  _impl_.total_allocated_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t IonHeapGrowFtraceEvent::total_allocated() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonHeapGrowFtraceEvent.total_allocated)
  return _internal_total_allocated();
}
inline void IonHeapGrowFtraceEvent::set_total_allocated(::int64_t value) {
  _internal_set_total_allocated(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonHeapGrowFtraceEvent.total_allocated)
}
inline ::int64_t IonHeapGrowFtraceEvent::_internal_total_allocated() const {
  return _impl_.total_allocated_;
}
inline void IonHeapGrowFtraceEvent::_internal_set_total_allocated(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.total_allocated_ = value;
}

// -------------------------------------------------------------------

// IonBufferCreateFtraceEvent

// optional uint64 addr = 1;
inline bool IonBufferCreateFtraceEvent::has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonBufferCreateFtraceEvent::clear_addr() {
  _impl_.addr_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IonBufferCreateFtraceEvent::addr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonBufferCreateFtraceEvent.addr)
  return _internal_addr();
}
inline void IonBufferCreateFtraceEvent::set_addr(::uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonBufferCreateFtraceEvent.addr)
}
inline ::uint64_t IonBufferCreateFtraceEvent::_internal_addr() const {
  return _impl_.addr_;
}
inline void IonBufferCreateFtraceEvent::_internal_set_addr(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.addr_ = value;
}

// optional uint64 len = 2;
inline bool IonBufferCreateFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonBufferCreateFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonBufferCreateFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonBufferCreateFtraceEvent.len)
  return _internal_len();
}
inline void IonBufferCreateFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonBufferCreateFtraceEvent.len)
}
inline ::uint64_t IonBufferCreateFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonBufferCreateFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.len_ = value;
}

// -------------------------------------------------------------------

// IonBufferDestroyFtraceEvent

// optional uint64 addr = 1;
inline bool IonBufferDestroyFtraceEvent::has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IonBufferDestroyFtraceEvent::clear_addr() {
  _impl_.addr_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t IonBufferDestroyFtraceEvent::addr() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonBufferDestroyFtraceEvent.addr)
  return _internal_addr();
}
inline void IonBufferDestroyFtraceEvent::set_addr(::uint64_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonBufferDestroyFtraceEvent.addr)
}
inline ::uint64_t IonBufferDestroyFtraceEvent::_internal_addr() const {
  return _impl_.addr_;
}
inline void IonBufferDestroyFtraceEvent::_internal_set_addr(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.addr_ = value;
}

// optional uint64 len = 2;
inline bool IonBufferDestroyFtraceEvent::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IonBufferDestroyFtraceEvent::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t IonBufferDestroyFtraceEvent::len() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.IonBufferDestroyFtraceEvent.len)
  return _internal_len();
}
inline void IonBufferDestroyFtraceEvent::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.IonBufferDestroyFtraceEvent.len)
}
inline ::uint64_t IonBufferDestroyFtraceEvent::_internal_len() const {
  return _impl_.len_;
}
inline void IonBufferDestroyFtraceEvent::_internal_set_len(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.len_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fkmem_2eproto_2epb_2eh
